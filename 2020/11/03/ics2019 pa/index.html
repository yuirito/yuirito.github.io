<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="PA1PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下    命令 格式 使用举例 说明    帮助(1) help help 打印命令的帮助信息   继续运行(1) c c 继续运行被暂停的程序   退出(1) q q 退出NEMU   单步执行 si [N] si 10 让程序单步执行N条指令后暂停执行, 当N没有给出时, 缺省为1   打印程序">
<meta property="og:type" content="article">
<meta property="og:title" content="ics2019 pa">
<meta property="og:url" content="http://example.com/2020/11/03/ics2019%20pa/index.html">
<meta property="og:site_name" content="yuirito&#39;s blog">
<meta property="og:description" content="PA1PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下    命令 格式 使用举例 说明    帮助(1) help help 打印命令的帮助信息   继续运行(1) c c 继续运行被暂停的程序   退出(1) q q 退出NEMU   单步执行 si [N] si 10 让程序单步执行N条指令后暂停执行, 当N没有给出时, 缺省为1   打印程序">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/11/03/ics2019%20pa/pa1.jpg">
<meta property="article:published_time" content="2020-11-03T05:21:06.000Z">
<meta property="article:modified_time" content="2020-11-23T08:39:50.454Z">
<meta property="article:author" content="yuirito">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/11/03/ics2019%20pa/pa1.jpg">

<link rel="canonical" href="http://example.com/2020/11/03/ics2019%20pa/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ics2019 pa | yuirito's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yuirito's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/03/ics2019%20pa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuirito">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yuirito's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ics2019 pa
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-03 13:21:06" itemprop="dateCreated datePublished" datetime="2020-11-03T13:21:06+08:00">2020-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-23 16:39:50" itemprop="dateModified" datetime="2020-11-23T16:39:50+08:00">2020-11-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h1><p>PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下</p>
<table>
<thead>
<tr>
<th>命令</th>
<th align="left">格式</th>
<th align="left">使用举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>帮助(1)</td>
<td align="left"><code>help</code></td>
<td align="left"><code>help</code></td>
<td>打印命令的帮助信息</td>
</tr>
<tr>
<td>继续运行(1)</td>
<td align="left"><code>c</code></td>
<td align="left"><code>c</code></td>
<td>继续运行被暂停的程序</td>
</tr>
<tr>
<td>退出(1)</td>
<td align="left"><code>q</code></td>
<td align="left"><code>q</code></td>
<td>退出NEMU</td>
</tr>
<tr>
<td>单步执行</td>
<td align="left"><code>si [N]</code></td>
<td align="left"><code>si 10</code></td>
<td>让程序单步执行<code>N</code>条指令后暂停执行, 当<code>N</code>没有给出时, 缺省为<code>1</code></td>
</tr>
<tr>
<td>打印程序状态</td>
<td align="left"><code>info SUBCMD</code></td>
<td align="left"><code>info r</code> <code>info w</code></td>
<td>打印寄存器状态 打印监视点信息</td>
</tr>
<tr>
<td>表达式求值</td>
<td align="left"><code>p EXPR</code></td>
<td align="left"><code>p $eax + 1</code></td>
<td>求出表达式<code>EXPR</code>的值, <code>EXPR</code>支持的 运算请见<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/1.6.html">调试中的表达式求值</a>小节</td>
</tr>
<tr>
<td>扫描内存(2)</td>
<td align="left"><code>x N EXPR</code></td>
<td align="left"><code>x 10 $esp</code></td>
<td>求出表达式<code>EXPR</code>的值, 将结果作为起始内存 地址, 以十六进制形式输出连续的<code>N</code>个4字节</td>
</tr>
<tr>
<td>设置监视点</td>
<td align="left"><code>w EXPR</code></td>
<td align="left"><code>w *0x2000</code></td>
<td>当表达式<code>EXPR</code>的值发生变化时, 暂停程序执行</td>
</tr>
<tr>
<td>删除监视点</td>
<td align="left"><code>d N</code></td>
<td align="left"><code>d 2</code></td>
<td>删除序号为<code>N</code>的监视点</td>
</tr>
</tbody></table>
<p>备注:</p>
<ul>
<li><p>(1) 命令已实现</p>
</li>
<li><p>(2) 与GDB相比, 我们在这里做了简化, 更改了命令的格式</p>
</li>
</ul>
<p>之后再具体说明上述命令如何实现，先看下PA1需要修改的文件，见下图</p>
<p><img src="/2020/11/03/ics2019%20pa/pa1.jpg"></p>
<p>其中ui.c是主要的交互界面代码，进入主循环后，用户输入的命令在这个文件里面进行解析，再分类处理，PA1.1也是从这里开始，主要增加一些命令，后面PA1.1再详述，包括对reg.c文件的修改。</p>
<p>expr.c是表达式处理，主要是辅助完成p 命令，以及后面的监视点，个人认为是PA1里面最重要的部分，是PA1.2的核心内容，为了测试表达式处理是否正确，gen-expr.c是自己设计随机生成一些表达式进行检测，与主程序无关，仅仅测试使用。</p>
<p>watchpoint.h, watchpoint.c是辅助实现w和d命令，也就是建立监视点和删除监视点，另外cpu-exec.c中需要增加几行代码，实现对监视点的监视。后面PA1.3再详述。</p>
<h2 id="PA1-0"><a href="#PA1-0" class="headerlink" title="PA1.0"></a>PA1.0</h2><p>在正式开始PA1之前，如果你选择的是x86的ISA，还有一些准备工作需要做，如果不是x86，可以直接跳过此节。</p>
<p>打开nemu/src/isa/x86/include/isa/reg.h文件，可以看到对CPU_state定义的结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">uint32_t</span> _32;</span><br><span class="line"> <span class="keyword">uint16_t</span> _16;</span><br><span class="line"> <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line"> &#125;gpr[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line"><span class="keyword">vaddr_t</span> pc;</span><br><span class="line">&#125;CPU_state;</span><br></pre></td></tr></table></figure>

<p>因为原先定义的是struct，gpr数组和8个寄存器并没有关联，物理上是顺序独立的排列，为了让他们相关联起来，就要使用union，改后的代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">union</span>&#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> _32;</span><br><span class="line">            <span class="keyword">uint16_t</span> _16;</span><br><span class="line">            <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">        &#125; gpr[<span class="number">8</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">vaddr_t</span> pc;</span><br><span class="line"></span><br><span class="line">&#125; CPU_state;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以观察reg.c中的reg_test()是如何进行测试的，生成一个随机数，然后赋值给每个32位的寄存器，然后对关联性检查。</p>
<p>修改完代码以后，在menu目录下执行make run，如果看到欢迎提示，进入(menu)等待输入命令就说明成功了。</p>
<h2 id="PA1-1"><a href="#PA1-1" class="headerlink" title="PA1.1"></a>PA1.1</h2><p>PA1.1要实现si, x, info r三条命令。</p>
<p>要增加一条新的命令先写一个对应的函数，然后在cmd_table中增加命令的名称，说明，函数即可</p>
<p>cmd_table的结构定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">char</span> *description;</span><br><span class="line">  <span class="keyword">int</span> (*handler) (<span class="keyword">char</span> *);</span><br><span class="line">&#125; cmd_table []</span><br></pre></td></tr></table></figure>



<h4 id="si命令"><a href="#si命令" class="headerlink" title="si命令"></a>si命令</h4><p>我先上我写的cmd_si()，再具体说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_si</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* extract the first argument */</span></span><br><span class="line">    <span class="keyword">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* no argument given */</span></span><br><span class="line">        cpu_exec(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = atoi(arg);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">            cpu_exec(n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cmd_err(<span class="number">0</span>, <span class="string">&quot;si:N&lt;=0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cmd_si是我觉得这几个命令里面相对来说最简单的一个，因为他只要读出命令中的N，转化为数字再传给cpu_exec()即可，cpu_exec(n)是执行程序，其参数n是执行n步，在这里先用strtok函数读入命令格式中的N，如果没有的话就默认执行1步，即cpu_exec(1)，否则的话用atoi转化为数字后再调用。另外这里cmd_err是一个通用的报错函数，定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_err</span><span class="params">(<span class="keyword">int</span> err_type,<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(err_type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid arguments for command &#x27;%s&#x27;\n&quot;</span>,command);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Lack arguments for command &#x27;%s&#x27;\n&quot;</span>,command);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="x命令"><a href="#x命令" class="headerlink" title="x命令"></a>x命令</h4><p>x命令需要用到vaddr_read(addr,n)函数，其中参数addr是内存地址，n是读出的字节数，思路和刚刚一样，先用strtok函数读出命令的2个参数N和exp，这里暂时不考虑复杂的表达式，仅限于16进制数字，所以可以直接使用sscanf(arg2,”%x”,&amp;addr);将第2个参数地址得到，然后再用vaddr_read(addr,4)每次读出4个字节的内存，循环N次即可。</p>
<h4 id="info-r命令"><a href="#info-r命令" class="headerlink" title="info r命令"></a>info r命令</h4><p>因为监视点是PA1.3建立，相关内容都要在PA1.3实现，所以目前info命令仅限于实现info r查看所有寄存器的值，让我们先到x86下面的reg.c文件，在这里实现一个显示所有寄存器的接口void isa_reg_display()，其实也很简单，就只是printf所有寄存器的值而已，打印的格式可以参考如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isa_reg_display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* PA1.1 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;eax\t0x%-8x\t%u\n&quot;</span>,cpu.eax,cpu.eax);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ecx\t0x%-8x\t%u\n&quot;</span>,cpu.ecx,cpu.ecx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;edx\t0x%-8x\t%u\n&quot;</span>,cpu.edx,cpu.edx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ebx\t0x%-8x\t%u\n&quot;</span>,cpu.ebx,cpu.ebx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;esp\t0x%-8x\t%u\n&quot;</span>,cpu.esp,cpu.esp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ebp\t0x%-8x\t%u\n&quot;</span>,cpu.ebp,cpu.ebp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;esi\t0x%-8x\t%u\n&quot;</span>,cpu.esi,cpu.esi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;edi\t0x%-8x\t%u\n&quot;</span>,cpu.edi,cpu.edi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pc\t0x%-8x\t%u\n&quot;</span>,cpu.pc,cpu.pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个接口实现info r就很简单了，只需要判断参数==’r’，然后直接调用reg.c里面的isa_reg_display()即可</p>
<p>至此PA1.1就完成了，PA1.1本身不难，不过要先理解整个代码框架的结构</p>
<h2 id="PA1-2"><a href="#PA1-2" class="headerlink" title="PA1.2"></a>PA1.2</h2><p>如果你做过编译原理实验，这部分其实也不会太难，就是编译原理实验的一小部分。</p>
<p>我们一步一步来，首先对于一个表达式，我们要识别其中的符号token，例如对于表达式</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;4 +3*(2- 1)&quot;</span></span><br></pre></td></tr></table></figure>

<p>的token表达式为</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+</span><br><span class="line">| NUM | &#x27;+&#x27; | NUM | &#x27;*&#x27; | &#x27;<span class="params">(&#x27; | NUM | &#x27;-&#x27; | NUM | &#x27;)</span>&#x27; |</span><br><span class="line">| <span class="string">&quot;4&quot;</span> |     | <span class="string">&quot;3&quot;</span> |     |     | <span class="string">&quot;2&quot;</span> |     | <span class="string">&quot;1&quot;</span> |     |</span><br><span class="line">+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+</span><br></pre></td></tr></table></figure>

<p>在expr.c中首先在enum中添加你想定义的token。我推荐一步到位，PA1.2就把全部的表达式做好。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>意义</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>TK_NOTYPE</td>
<td>空格</td>
<td>0</td>
</tr>
<tr>
<td>TK_NUM</td>
<td>十进制数字</td>
<td>0</td>
</tr>
<tr>
<td>TK_HEX</td>
<td>十六进制数字</td>
<td>0</td>
</tr>
<tr>
<td>TK_REG</td>
<td>寄存器</td>
<td>0</td>
</tr>
<tr>
<td>TK_OR</td>
<td>||</td>
<td>1</td>
</tr>
<tr>
<td>TK_AND</td>
<td>&amp;&amp;</td>
<td>2</td>
</tr>
<tr>
<td>TK_EQ</td>
<td>==</td>
<td>3</td>
</tr>
<tr>
<td>TK_PLUS</td>
<td>+</td>
<td>4</td>
</tr>
<tr>
<td>TK_SUB</td>
<td>-</td>
<td>4</td>
</tr>
<tr>
<td>TK_MUL</td>
<td>*</td>
<td>5</td>
</tr>
<tr>
<td>TK_DIV</td>
<td>/</td>
<td>5</td>
</tr>
<tr>
<td>TK_NEGTIVE</td>
<td>负数</td>
<td>6</td>
</tr>
<tr>
<td>TK_DEREF</td>
<td>引用(例:*$eax)</td>
<td>6</td>
</tr>
<tr>
<td>TK_LBR</td>
<td>(</td>
<td>7</td>
</tr>
<tr>
<td>TK_RBR</td>
<td>）</td>
<td>7</td>
</tr>
</tbody></table>
<p>TK_NEGTIVE和TK_DEREF比较特殊，因为他们的符号分别和TK_SUB和TK_MUL是一样的，需要特殊处理，将他们区分开来，这个是在识别完所有token之后做的，暂时先忽略这2个，之后会讲。</p>
<p>还有一点是这里建议引入优先级，便于后续操作，所以你也需要把原先代码里面对于rule结构体增加一项优先级的成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *regex;</span><br><span class="line">  <span class="keyword">int</span> token_type;</span><br><span class="line">  <span class="keyword">int</span> priority; <span class="comment">// add priority</span></span><br><span class="line">&#125; rules[]</span><br></pre></td></tr></table></figure>

<p>当然Token结构体也不要忘了加。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">token</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">32</span>];</span><br><span class="line">  <span class="keyword">int</span> priority; <span class="comment">//add priority</span></span><br><span class="line">&#125; Token</span><br></pre></td></tr></table></figure>

<p>填写好rules，正则表达式，符号，优先级。在make_token中会对表达式挨个字符进行分析，从第一条规则开始遍历rules，匹配成功以后，首先对匹配字符串的长度检测，判断是否大于32，如果大于32个字符assert(0)，否则的话，根据匹配的规则，进行进一步操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (rules[i].token_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> TK_NOTYPE: <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TK_NUM:</span><br><span class="line">            <span class="keyword">case</span> TK_HEX:</span><br><span class="line">            <span class="keyword">case</span> TK_REG:</span><br><span class="line">                <span class="built_in">strncpy</span>(tokens[nr_token].str, substr_start, substr_len);</span><br><span class="line">				        tokens[nr_token].str[substr_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">default</span>: </span><br><span class="line">                tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">                tokens[nr_token].priority = rules[i].priority;</span><br><span class="line">				        nr_token++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>对每个规则都要做的是，将其类型和优先级存入tokens数组，而对于数字，额外需要的操作是将其字符串也要保存，为了之后得到具体数值。对于空格就跳过即可。</p>
<p>另外值得一提的是这里可以把tokens数字开大一点，后面测试的时候需要修改。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Token tokens<span class="literal">[<span class="number">65536</span>]</span> <span class="constructor">__attribute__((<span class="params">used</span>)</span>) = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>到这里第一步算是完成了，第一步的工作是利用正则表达式识别给定表达式的token，然后将其顺序的存入tokens数组，保存其类型，优先级，和数字的字符串（相当于是数值）。</p>
<p>接下来在完成手册中提示的eval()函数之前，我们还需要写2个辅助函数——check_parentheses()和get_main_op()。</p>
<p>int check_parentheses(int p, int q)，这里建议将返回类型由bool改为int，因为需要返回3种不同情况。参数p和q分别是tokens数组的起始和结束位置。函数的功能是根据tokens数组从p到q这部分所代表的表达式返回以下3种：</p>
<ul>
<li>返回1    如果表达式是一个由一对左右括号完整包裹的一个有效表达式。</li>
<li>返回0    如果表达式是一个有效的表达式，但是并没有被一对左右括号包裹。</li>
<li>返回-1   如果表达式不是一个有效的表达式。  </li>
</ul>
<p>另外值得一提的是这里需要考虑一种特殊情况，就是虽然是一个有效的表达式，同时左右分别是左括号和号，但是这两个括号并不是一对，例如<br>$$<br>(4+3)*(4+4)<br>$$<br>对于这样的表达式，应该返回0而不是1。这里是对括号的匹配性进行检测，其他方面的细节可以不用管。从p位置开始到q位置，用n进行记录，如果遇到左括号n+1如果遇到右括号n-1,在循环过程中，只要n变为负数可以理解退出返回-1，如果循环结束n不为0也返回-1。剩下的就不用多说了，反正直接看代码也就懂了。</p>
<p>int get_main_op(int p, int q)，参数的意义同上，函数的作用是从p位置开始扫描到q位置，找到一个优先级最低的运算符号且该运算符号不能在括号包裹的表达式里面，同优先级的情况下取最右边的运算符号作为主符号，最后将主符号的位置返回。因为tokens里面有存各个符号的优先级，所以这里就可以非常简单的实现。判断括号内的方法可以参考上面的用n记录的方法，只有当n等于0的时候说明不在括号内，这时候再进行对运算符号优先级的比较。</p>
<p>两个辅助函数写完的情况下，对于PA1.2来说可以去实现关键的eval()函数了，但是我一开始就说过了要一步到位，所以先不急着去写eval()函数，我们需要先到expr()函数里面完成一些前置工作。</p>
<p>uint32_t expr(char <em>e, bool <em>success)，对字符串e进行表达式求值，如果求值成功\</em>success==true，失败\</em>success==false，返回求值的结果。expr()函数首先调用make_token完成我前面说的第一步，将表达式进行符号解析存入tokens数组中，之后就是我们需要添加的代码，在已经完成第一步解析的基础上，需要对*和-进行进一步的分析，识别出TK_DEREF和TK_NEGTIVE。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;nr_token; <span class="built_in">i</span>++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokens[<span class="built_in">i</span>].<span class="built_in">type</span> == TK_MUL &amp;&amp; (<span class="built_in">i</span>==<span class="number">0</span> || (tokens[<span class="built_in">i</span><span class="number">-1</span>].priority!=<span class="number">0</span> &amp;&amp; tokens[<span class="built_in">i</span><span class="number">-1</span>].<span class="built_in">type</span>!=TK_RBR)))&#123;</span><br><span class="line">       tokens[<span class="built_in">i</span>].<span class="built_in">type</span> = TK_DEREF;</span><br><span class="line">       tokens[<span class="built_in">i</span>].priority = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tokens[<span class="built_in">i</span>].<span class="built_in">type</span> == TK_SUB &amp;&amp; (<span class="built_in">i</span>==<span class="number">0</span> || (tokens[<span class="built_in">i</span><span class="number">-1</span>].priority!=<span class="number">0</span> &amp;&amp; tokens[<span class="built_in">i</span><span class="number">-1</span>].<span class="built_in">type</span>!=TK_RBR)))&#123;</span><br><span class="line">       tokens[<span class="built_in">i</span>].<span class="built_in">type</span> = TK_NEGTIVE;</span><br><span class="line">       tokens[<span class="built_in">i</span>].priority = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>对tokens数组扫描，对于其中的*也就是type是TK_MUL，如果位置在第一个，或者他的前一个符号不是数字(可以用优先级简单的判断，因为数字的优先级是0)，且不是右括号，那么将这个TK_MUL重新解释为TK_DEREF，优先级为6。同理对TK_NEGTIVE也进行类似的判断识别。现在所有符号都正确的识别了，可以使用eval对其进行求值了。</p>
<p>uint32_t eval(int p, int q, bool *success)，求出tokens数组从p到q所代表的表达式的值，如果求值成功*success==true，失败*success==false，返回求值的结果。eval的大致框架和思路在手册里面有写，这里就不赘述了。eval流程图如下：</p>
<pre class="mermaid">graph TD
A(开始) --> B{p与q的关系}
    B --> |p > q| err[*success=false<br>return -1]
    B --> |p == q| E["根据tokens[p].type<br>(10进制,16进制或寄存器)求值"]
    B --> |p < q| F["ret=check_parenthese(p,q)"]
    F --> G{ret返回值}
    G --> |ret == -1| err
    G --> |ret == 1| ret1["return eval(p+1,q-1,success)"]
    G --> |ret == 0| ret0["pos=get_main_op(p,q)"]
    ret0 --> |pos == -1| err
    ret0 --> |pos != -1| eval["val1 = eval(p, pos - 1, success);<br>
    val2 = eval(pos + 1, q, success);<br>
    根据tokens[pos].type进行运算"]</pre>

<p>有了流程图，大致的代码思路应该已经有了，再来说下其中的细节。</p>
<p>首先是p==q的时候，这时候说明这个表达式没有运算符号，其本身是一个数值或者寄存器，如果是TK_NUM或者TK_HEX，那么直接strtoul(tokens[p].str, NULL, 0)就可以把字符串转化为数值，如果是TK_REG，那么需要使用isa_reg_str2val(tokens[p].str + 1, success)获取寄存器的值。这个isa_reg_str2val()函数在之前的reg.c中，需要你去实现它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">isa_reg_str2val</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">bool</span> *success)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* PA1.2 */</span></span><br><span class="line">  *success = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, <span class="string">&quot;pc&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(s, <span class="string">&quot;eip&quot;</span>) == <span class="number">0</span>)  <span class="keyword">return</span> cpu.pc;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = R_EAX; i &lt;= R_EDI; ++ i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, regsl[i]) == <span class="number">0</span>) <span class="keyword">return</span> reg_l(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = R_AX; i &lt;= R_DI; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, regsw[i]) == <span class="number">0</span>) <span class="keyword">return</span> reg_w(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = R_AL; i &lt;= R_BH; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, regsb[i]) == <span class="number">0</span>) <span class="keyword">return</span> reg_b(i);</span><br><span class="line">	&#125;</span><br><span class="line">	*success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有的寄存器，比对传入参数s和寄存器的名字，找到s对应的寄存器然后返回寄存器中的值。</p>
<p>第2个细节是根据tokens[pos].type进行运算，pos的位置指向主运算符，如果这个主运算符是除法，那么应该注意一下对于除以0行为的处理，也就是判断val2==0?，简单一点直接assert(0)也可以，也可以输出一段提示后，*success=false。其他的运算符都比较简单，注意TK_DEREF是val=vaddr_read(val2,4)以及TK_NEGTIVE是val=-val2即可。(这两个运算符并没有用到val1)</p>
<p>其实到这里PA1.2已经完成了，但是手册里面要求你还需要对你的表达式写一个程序随机测验，所以你还需要完成gen-expr.c。测试原理在手册里面已经讲了，而我们在这个文件中需要自己补充的仅仅是随机生成一个表达式的部分，我直接贴上我的代码再讲比较方便，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PA1.2 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TOKEN 10</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">5000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">choose</span><span class="params">(<span class="keyword">uint32_t</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rand() % n;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gen_rand_expr</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> op;</span><br><span class="line">  <span class="keyword">if</span>(l==r)buf[l]=choose(<span class="number">10</span>)+<span class="number">48</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(r==l+<span class="number">1</span>)&#123;</span><br><span class="line">	  buf[l]=choose(<span class="number">9</span>)+<span class="number">1</span>+<span class="number">48</span>;</span><br><span class="line">	  buf[r]=choose(<span class="number">10</span>)+<span class="number">48</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">	  <span class="keyword">switch</span>(choose(<span class="number">1</span>))&#123;</span><br><span class="line">		  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              op=l+<span class="number">1</span>+choose(r-l<span class="number">-1</span>);</span><br><span class="line">			  gen_rand_expr(l,op<span class="number">-1</span>);</span><br><span class="line">              <span class="keyword">static</span> <span class="keyword">char</span> ops[] = <span class="string">&quot;+-*/&quot;</span>;</span><br><span class="line">			  buf[op]=ops[choose(<span class="number">4</span>)];</span><br><span class="line">			  gen_rand_expr(op+<span class="number">1</span>,r);</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">		  <span class="keyword">default</span>:</span><br><span class="line">			  buf[l]=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">			  buf[r]=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">			  gen_rand_expr(l+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>N_TOKEN是最后表达式中token的数目，uint32_t choose(uint32_t n)随机生成一个0~n-1的数。</p>
<p>void gen_rand_expr(int l,int r)在字符串位置l和r之间随机生成表达式的token，如果r==l生成一个1位数字，如果r==l+1生成一个两位数，此外，从下面2种情况中生成一种：</p>
<ul>
<li>在l+1到r-1中随机选取一个位置作为主符号的位置op，并从加减乘除当中随机选择一个符号。递归调用gen_rand_expr(l,op-1)和gen_rand_expr(op+1,r)生成两边的表达式。</li>
<li>在l和r的位置生成一对括号，递归调用gen_rand_expr(l+1,r-1)，生成被一对括号包裹的表达式。  </li>
</ul>
<p>最后修改下面的main函数中对gen_rand_expr()的调用，加上参数，就完成了。别忘了修改buf和code_buf数组的大小，至少保证buf的长度小于code_buf。</p>
<p>完成了以后记得去ui.c中加入p命令，方式同PA1.1。这里只要调用expr即可，我附上我的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_p</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* extract the first argument */</span></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* no argument given */</span></span><br><span class="line">        cmd_err(<span class="number">0</span>, <span class="string">&quot;p: no argument given\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> result = expr(args,&amp;success);</span><br><span class="line">        <span class="keyword">if</span>(success) <span class="built_in">printf</span>(<span class="string">&quot;0x%x(%d)\n&quot;</span>,result,result);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Invalid expr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="PA1-3"><a href="#PA1-3" class="headerlink" title="PA1.3"></a>PA1.3</h2><p>PA1.3要求实现监视点的创建和删除。首先我们先到watchpoint.h查看WP结构体，可以看到原始定义只有表示WP的序号NO以及作为链表结点必须的next指针，这显然是不够的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> NO;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more members if necessary */</span></span><br><span class="line">  <span class="comment">/* PA1.3*/</span></span><br><span class="line">  <span class="keyword">char</span> expr[<span class="number">128</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> value;</span><br><span class="line">  <span class="keyword">int</span> hit;</span><br><span class="line">&#125; WP;</span><br></pre></td></tr></table></figure>

<p>需要添加的成员有3个：</p>
<ul>
<li>char expr[128]：用于记录创建的监视点的表达式，例如$eax</li>
<li>uint32_t value：求出当前的表达式的值，表达式是不变的，但是其值会变，因为寄存器值会变，当表达式值改变的时候就要暂停程序，算是命中。</li>
<li>int hit：记录该监视点的命中次数。</li>
</ul>
<p>监视点采用链表池的结构管理，所有监视点保存在wp_pool数组中，而正在使用的监视点由head指针串起的一个链表，空闲的监视点链表由free_指向。</p>
<p>剩下的其实都是基本的链表操作，例如创建一个监视点，就是将free_指向的首结点从空闲链表摘除，加进head指向的链表。并设置其expr,hit,计算expr。而删除一个监视点，就是遍历head指向的链表，找到一个结点其序号NO与给定的相符，将其从head链表中删除，移到free_链表。</p>
<p>除了添加和删除，还需要展示监视点的内容，这里是继续了PA1.1的info w命令，函数自己命名，展示格式可以参考如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_wp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;There is no watchpoint!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Num     What     Value\n&quot;</span>);</span><br><span class="line">	WP *p = head;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%-8d%-9s%u(%#x)\n&quot;</span>, p -&gt; NO, p -&gt; expr, p-&gt;value, p-&gt;value);</span><br><span class="line">		<span class="keyword">if</span>(p -&gt; hit &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\tbreakpoint already hit %d time\n&quot;</span>, p-&gt;hit);</span><br><span class="line">		p = p -&gt; next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，你还需要一个功能，监视点的作用是当监视的表达式的值变化时，暂停程序。我们先实现bool check_wp()，它的功能是检查所有监视点，看是否有监视点的表达式值发生了变化。方法很简单，遍历head指向的所有正在使用的监视点，然后重新计算其expr的值，与之前保存在value当中的值比对，如果不同的话，说明表达式的值发生了变化。然后需要暂停程序，这里手册给了提示，只要把nemu_state.state赋值为NEMU_STOP即可。在cpu_exec.c的cpu_exec()函数，我们会亲切的发现已经有注释写好了你需要添加的位置，而你只需要在这行注释下面添加这么几行代码即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> check watchpoints here. */</span></span><br><span class="line">    <span class="comment">/* PA1.3*/</span></span><br><span class="line">  <span class="keyword">bool</span> changed = check_wp();</span><br><span class="line">	<span class="keyword">if</span>(changed)&#123;</span><br><span class="line">		nemu_state.state = NEMU_STOP;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后别忘了回到ui.c完善你所有的命令，整个PA1就算完成了，其实还算简单，真正痛苦的地狱PA2才正要开始。</p>
<h1 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h1><p>该说不愧是1星难度吗，确实挺难的。</p>
<h2 id="PA2-1"><a href="#PA2-1" class="headerlink" title="PA2.1"></a>PA2.1</h2><p>我觉得有必要先整理一下结构体定义（不过你可以先暂时跳过这部分，直接看完追踪mov指令执行过程会更加清晰）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *pc)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_EHelper(name) void concat(exec_, name) (vaddr_t *pc)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*EHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  DHelper decode;</span><br><span class="line">  EHelper execute;</span><br><span class="line">  <span class="keyword">int</span> width;</span><br><span class="line">&#125; OpcodeEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type;</span><br><span class="line">  <span class="keyword">int</span> width;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg;</span><br><span class="line">    <span class="keyword">rtlreg_t</span> addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> imm;</span><br><span class="line">    <span class="keyword">int32_t</span> simm;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">rtlreg_t</span> val;</span><br><span class="line">  <span class="keyword">char</span> str[OP_STR_SIZE];</span><br><span class="line">&#125; Operand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> opcode;</span><br><span class="line">  <span class="keyword">uint32_t</span> width;</span><br><span class="line">  <span class="keyword">vaddr_t</span> seq_pc;  <span class="comment">// sequential pc</span></span><br><span class="line">  <span class="keyword">bool</span> is_jmp;</span><br><span class="line">  <span class="keyword">vaddr_t</span> jmp_pc;</span><br><span class="line">  Operand src, dest, src2;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ISADecodeInfo</span> <span class="title">isa</span>;</span></span><br><span class="line">&#125; DecodeInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span>  simm   : <span class="number">16</span>;</span><br><span class="line"><span class="comment">//  uint32_t rt     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t rs     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t opcode :  6;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> imm    : <span class="number">16</span>;</span><br><span class="line"><span class="comment">//  uint32_t rt     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t rs     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t opcode :  6;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> jmp_target : <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> opcode     :  <span class="number">6</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> func   : <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> sa     : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> rd     : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> rt     : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> rs     : <span class="number">5</span>;</span><br><span class="line"><span class="comment">//  uint32_t opcode : 6;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">uint32_t</span> val;</span><br><span class="line">&#125; Instr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ISADecodeInfo</span> &#123;</span></span><br><span class="line">  Instr instr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> R_M		:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> reg		:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> mod		:<span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> dont_care	:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> opcode		:<span class="number">3</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">uint8_t</span> val;</span><br><span class="line">&#125; ModR_M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> base	:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> index	:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> ss		:<span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">uint8_t</span> val;</span><br><span class="line">&#125; SIB;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> instr = vaddr_read(*pc, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *p_instr = (<span class="keyword">void</span> *)&amp;instr;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> log_bytebuf[];</span><br><span class="line">    strcatf(log_bytebuf, <span class="string">&quot;%02x &quot;</span>, p_instr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  (*pc) += len;</span><br><span class="line">  <span class="keyword">return</span> instr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Instruction Decode and EXecute */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idex</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, OpcodeEntry *e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;decode)</span><br><span class="line">    e-&gt;decode(pc);</span><br><span class="line">  e-&gt;execute(pc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make_DHelper(mov_I2r) &#123;</span><br><span class="line">  decode_op_r(pc, id_dest, <span class="literal">false</span>);</span><br><span class="line">  decode_op_I(pc, id_src, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This helper function is use to decode register encoded in the opcode. */</span></span><br><span class="line"><span class="comment">/* XX: AL, AH, BL, BH, CL, CH, DL, DH</span></span><br><span class="line"><span class="comment"> * eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(r)</span> </span>&#123;</span><br><span class="line">  op-&gt;type = OP_TYPE_REG;</span><br><span class="line">  op-&gt;reg = decinfo.opcode &amp; <span class="number">0x7</span>;</span><br><span class="line">  <span class="keyword">if</span> (load_val) &#123;</span><br><span class="line">    rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;width);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">&quot;%%%s&quot;</span>, reg_name(op-&gt;reg, op-&gt;width));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Refer to Appendix A in i386 manual for the explanations of these abbreviations */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ib, Iv */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(I)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* pc here is pointing to the immediate */</span></span><br><span class="line">  op-&gt;type = OP_TYPE_IMM;</span><br><span class="line">  op-&gt;imm = instr_fetch(pc, op-&gt;width);</span><br><span class="line">  rtl_li(&amp;op-&gt;val, op-&gt;imm);</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">&quot;$0x%x&quot;</span>, op-&gt;imm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们以追踪mov指令执行过程为例讲解整个流程。</p>
<p>从cpu.c开始首先执行exec_once()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vaddr_t</span> <span class="title">exec_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  decinfo.seq_pc = cpu.pc;</span><br><span class="line">  isa_exec(&amp;decinfo.seq_pc);</span><br><span class="line">  update_pc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> decinfo.seq_pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将cpu.pc的值保存在了decinfo.seq_pc中，然后将该值的索引传进isa_exec()中，最后调用update_pc()更新pc值。关键的译码和执行显然在isa_exec()中，这个函数也有屏蔽isa差别的功能，来到isa/x86/exec/exec.c中，这里有isa_exec()定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isa_exec</span><span class="params">(<span class="keyword">vaddr_t</span> *pc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> opcode = instr_fetch(pc, <span class="number">1</span>);</span><br><span class="line">  decinfo.opcode = opcode;</span><br><span class="line">  set_width(opcode_table[opcode].width);</span><br><span class="line">  idex(pc, &amp;opcode_table[opcode]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>instr_fetch()的定义在include/cpu/exec.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> instr = vaddr_read(*pc, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *p_instr = (<span class="keyword">void</span> *)&amp;instr;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> log_bytebuf[];</span><br><span class="line">    strcatf(log_bytebuf, <span class="string">&quot;%02x &quot;</span>, p_instr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  (*pc) += len;</span><br><span class="line">  <span class="keyword">return</span> instr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能很简单，就是读取pc所指内存len个字节返回，然后pc的值增加len长度。</p>
<p>回到isa_exec()，很明显先是从pc所指地方读取一个字节作为opcode并且保存在decinfo.opcode中，如果是mov指令，以下面这条mov指令为例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">100000</span>:    b<span class="number">8</span> <span class="number">34</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span>        mov    $<span class="number">0</span>x<span class="number">1234</span>,%eax</span><br></pre></td></tr></table></figure>

<p>那么这个opcode一定是0xb8，接着我们用opcode作为索引查表opcode_table</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0xb8 */</span>	<span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>, <span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>, <span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>, <span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>,</span><br></pre></td></tr></table></figure>

<p>也就是IDEX(mov_I2r,mov)，我们先来看看opcode_table的定义。他是一个OpcodeEntry类型的数组，那么OpcodeEntry又是什么呢，他的结构体定义在include/cpu/exec.h中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  DHelper decode;</span><br><span class="line">  EHelper execute;</span><br><span class="line">  <span class="keyword">int</span> width;</span><br><span class="line">&#125; OpcodeEntry;</span><br></pre></td></tr></table></figure>

<p>在这个文件的上面可以找到EHelper的定义：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void <span class="comment">(*EHelper) (vaddr_t *)</span>;</span><br></pre></td></tr></table></figure>

<p>DHelper的定义在decode.h中可以找到，是类似的。总之就是说这个结构体有2个函数指针和一个int类型变量记录宽度，这两个函数指针分别执行译码函数和执行函数的入口。</p>
<p>在exec.h中，我们还可以看到IDEX宏的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEXW(id, ex, w)   &#123;concat(decode_, id), concat(exec_, ex), w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEX(id, ex)       IDEXW(id, ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXW(ex, w)         &#123;NULL, concat(exec_, ex), w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EX(ex)             EXW(ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPTY              EX(inv)</span></span><br></pre></td></tr></table></figure>

<p>IDEX是宽度为0的IDEXW，而IDEXW里面这个concat同样是个宏，这里就不再去找了，直接解释他的作用，就是将后面2个字符串拼接起来，我们回到IDEX(mov_I2r, mov)这个具体实例，通过这层层宏，最终应该被翻译成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  decode_mov_I2r,</span><br><span class="line">  exec_mov,</span><br><span class="line">  <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再回到isa_exec()，现在该执行set_width(opcode_table[opcode].width);这行了，不过根据上面分析，这里宽度的值为0，也就是set_width(0);那么set_width会怎么处理，我们需要看下set_width()函数的定义（exec.c文件）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_width</span><span class="params">(<span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (width == <span class="number">0</span>) &#123;</span><br><span class="line">    width = decinfo.isa.is_operand_size_16 ? <span class="number">2</span> : <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  decinfo.src.width = decinfo.dest.width = decinfo.src2.width = width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为width==0，而decinfo.isa.is_operand_size_16默认值是false，所以操作数的位宽都被设置为了4。</p>
<p>继续执行下一行idex(pc, &amp;opcode_table[opcode]);我们需要看一下idex()函数的定义(exec.h)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Instruction Decode and EXecute */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idex</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, OpcodeEntry *e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;decode)</span><br><span class="line">    e-&gt;decode(pc);</span><br><span class="line">  e-&gt;execute(pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面也说了OpcodeEntry里面有译码函数指针和执行函数指针，这里检测译码函数指针是否为NULL，如果为NULL，就直接进入执行函数，否则以pc作为参数进入译码函数，作为例子的译码函数是decode_mov_I2r()，不过这个函数也是宏定义的，我们先得找到。</p>
<p>我们来到isa/x86/decode.c文件，这里有很多用宏定义构成的译码函数，我们来看看是怎么构成的。</p>
<p>从结果说起吧，第157行make_DHelper(mov_I2r)就是我们要找的decode_mov_I2r().</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make_DHelper(mov_I2r) &#123;</span><br><span class="line">  decode_op_r(pc, id_dest, <span class="literal">false</span>);</span><br><span class="line">  decode_op_I(pc, id_src, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先去include/cpu/decode.h里面可以看到make_DHelper(name)宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *pc)</span></span><br></pre></td></tr></table></figure>

<p>因此按照这个宏定义，将make_DHelper(mov_I2r)翻译过来就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode_mov_I2r</span><span class="params">(<span class="keyword">vaddr_t</span> *pc)</span></span></span><br></pre></td></tr></table></figure>

<p>没错，正是我们所要找的函数，这个函数里面调用了2个decode_op_前缀的函数，在decode.c中我们可以在开头第4行看到这样一行宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *pc, Operand *op, bool load_val)</span></span><br></pre></td></tr></table></figure>

<p>所以，类似的，我们要找make_DopHelper(r)和make_DopHelper(I)，分别在59行和第9行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(r)</span> </span>&#123;</span><br><span class="line">  op-&gt;type = OP_TYPE_REG;</span><br><span class="line">  op-&gt;reg = decinfo.opcode &amp; <span class="number">0x7</span>;</span><br><span class="line">  <span class="keyword">if</span> (load_val) &#123;</span><br><span class="line">    rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;width);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">&quot;%%%s&quot;</span>, reg_name(op-&gt;reg, op-&gt;width));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Refer to Appendix A in i386 manual for the explanations of these abbreviations */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ib, Iv */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(I)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* pc here is pointing to the immediate */</span></span><br><span class="line">  op-&gt;type = OP_TYPE_IMM;</span><br><span class="line">  op-&gt;imm = instr_fetch(pc, op-&gt;width);</span><br><span class="line">  rtl_li(&amp;op-&gt;val, op-&gt;imm);</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">&quot;$0x%x&quot;</span>, op-&gt;imm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先将make_DopHelper(r)翻译一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">decode_op_r</span> <span class="params">(<span class="keyword">vaddr_t</span> *pc, Operand *op, <span class="keyword">bool</span> load_val)</span> </span>&#123;</span><br><span class="line">  op-&gt;type = OP_TYPE_REG;</span><br><span class="line">  op-&gt;reg = decinfo.opcode &amp; <span class="number">0x7</span>;</span><br><span class="line">  <span class="keyword">if</span> (load_val) &#123;</span><br><span class="line">    rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;width);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">&quot;%%%s&quot;</span>, reg_name(op-&gt;reg, op-&gt;width));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就很明显了，这个函数将op的类型赋值为OP_TYPE_REG，也就是标注为寄存器，寄存器的编号是opcode&amp;0x7，我们例子中opcode为0xb8，所以寄存器编号是0，而0号寄存器就是EAX，而load_val为false所以跳过，不过我认为这里还是先说明一下rtl函数，它们在include/isa/rtl.h文件和include/rtl目录中，目前只实现了几个，后面很多需要我们来补充。手册里面说过了，在NEMU中, 我们使用RTL（寄存器传输语言）来描述简单的操作.例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_lr</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">int</span> r, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (width) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: rtl_mv(dest, &amp;reg_l(r)); <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: rtl_host_lm(dest, &amp;reg_b(r), <span class="number">1</span>); <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: rtl_host_lm(dest, &amp;reg_w(r), <span class="number">2</span>); <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在rtl-wrapper.h里面有相关宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL_PREFIX interpret</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rtl_mv        concat(RTL_PREFIX, _rtl_mv      )</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在include/rtl/rtl.h中有具体的函数定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">interpret_rtl_mv</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1)</span> </span>&#123;</span><br><span class="line">  *dest = *src1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我想这个先暂时讲到这里，让我们回到decode_mov_I2r()函数，我们仅仅分析了它调用的一个函数，不过其实第2个也类似，这个函数从名字上也可以看出它的功能是把立即数（Imm）送入寄存器(reg)，因此它先调用了decode_op_r(pc, id_dest, false)这里id_dest也是一个宏，翻译过来其实就是&amp;decinfo.dest，也就是说这个函数作用是把目的操作数的类型确定为了寄存器，并记录了寄存器编号，为后续做好准备。那么decode_op_r(pc, id_src, true)函数的结果也显而易见了，将源操作数的类型设置为立即数，同时设置好立即数的值，从它的代码中我们可以看到instr_fetch(pc, op-&gt;width);也就是说从opcode字节后面又取了4个字节作为立即数的值。然后使用rtl_li(&amp;op-&gt;val, op-&gt;imm)将值保存进了op-&gt;val中。整个译码过程就算结束了。</p>
<p>接下来是执行过程，先找执行函数也就是exec_mov()函数，与前面类似，也就是说我们要找make_EHelper(mov)，这里看下x86/exec目录下，根据指令的类型不同分类出了arith.c存放运算类执行函数，control.c存放控制类执行函数,data-mov.c存放数据传输执行函数。所以我们来到data-mov.c文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(mov) &#123;</span><br><span class="line">  operand_write(id_dest, &amp;id_src-&gt;val);</span><br><span class="line">  print_asm_template2(mov);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是先把宏都翻译一下，包括id_dest</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec_mov</span><span class="params">(<span class="keyword">vaddr_t</span> *pc)</span></span>&#123;</span><br><span class="line">  operand_write(&amp;decinfo.dest, &amp;id_src-&gt;val);</span><br><span class="line">  print_asm(#mov <span class="string">&quot;%c %s,%s&quot;</span>, suffix_char((&amp;decinfo.dest)-&gt;width), id_src-&gt;str, id_dest-&gt;str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很显然，operand_write(&amp;decinfo.dest, &amp;id_src-&gt;val)的功能是把源操作数的值，写入目的操作数中。我们来具体看下operand_write()定义（decode.c）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operand_write</span><span class="params">(Operand *op, <span class="keyword">rtlreg_t</span>* src)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op-&gt;type == OP_TYPE_REG) &#123; rtl_sr(op-&gt;reg, src, op-&gt;width); &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (op-&gt;type == OP_TYPE_MEM) &#123; rtl_sm(&amp;op-&gt;addr, src, op-&gt;width); &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; assert(<span class="number">0</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据目的操作数的类型不同，调用rtl_sr()将源操作数的值送入寄存器(reg)或者调用rtl_sm()送入内存(mem)。</p>
<p>执行函数执行完以后不要完了exec_once最后还调用了update_pc()，让我们也看下它的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update_pc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (decinfo.is_jmp) &#123; decinfo.is_jmp = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; cpu.pc = decinfo.seq_pc; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为mov指令，自然是没有跳转的，再读完了一个字节的opcode和4个字节的立即数后decinfo.seq_pc自然已经来到了下一条指令的opcode位置，将其赋值给cpu.pc完成pc更新的工作就算真正的执行完了一条指令。</p>
<p>再以movw为例讲一下复杂指令的流程：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">100017</span>:    <span class="number">66</span> c<span class="number">7</span> <span class="number">84</span> <span class="number">99</span> <span class="number">00</span> e<span class="number">0</span> ff    movw   $<span class="number">0</span>x<span class="number">1</span>,-<span class="number">0</span>x<span class="number">2000</span>(%ecx,%ebx,<span class="number">4</span>)</span><br><span class="line"><span class="attribute">10001e</span>:    ff <span class="number">01</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>按照之前讲的流程先取到了opcode_table[0x66]的元素，会发现是一个EX(operand_size)，这个宏翻译过来译码辅助函数为NULL，只有执行函数的指针，所以我们直接看它的执行函数，在prefix.c中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(operand_size) &#123;</span><br><span class="line">  decinfo.isa.is_operand_size_16 = <span class="literal">true</span>;</span><br><span class="line">  isa_exec(pc);</span><br><span class="line">  decinfo.isa.is_operand_size_16 = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将is_operand_size_16设置为true，也就是更改宽度为16位，然后从下个字节开始执行isa_exec(pc)。这完成的就是operand-size prefix的功能。因为它的存在mov指令被识别为了movw指令。</p>
<p>接下来是真正的opcode，其值为0xc7，opcode_table[0xc7]=IDEX(mov_I2E, mov)，我们直接看译码函数(decode.c)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make_DHelper(I2E) &#123;</span><br><span class="line">  decode_op_rm(pc, id_dest, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line">  decode_op_I(pc, id_src, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decode_op_I()跟前面一样就不用说了，不同的仅限于这次是取2个字节作为立即数。</p>
<p>让我们看下decode_op_rm()的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* I386 manual does not contain this abbreviation.</span></span><br><span class="line"><span class="comment"> * We decode everything of modR/M byte by one time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* Eb, Ew, Ev</span></span><br><span class="line"><span class="comment"> * Gb, Gv</span></span><br><span class="line"><span class="comment"> * Cd,</span></span><br><span class="line"><span class="comment"> * M</span></span><br><span class="line"><span class="comment"> * Rd</span></span><br><span class="line"><span class="comment"> * Sw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decode_op_rm</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, Operand *rm, <span class="keyword">bool</span> load_rm_val, Operand *reg, <span class="keyword">bool</span> load_reg_val)</span> </span>&#123;</span><br><span class="line">  read_ModR_M(pc, rm, load_rm_val, reg, load_reg_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在src/isa/x86/decode/modrm.c中可以找到read_ModR_M()定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_ModR_M</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, Operand *rm, <span class="keyword">bool</span> load_rm_val, Operand *reg, <span class="keyword">bool</span> load_reg_val)</span> </span>&#123;</span><br><span class="line">  ModR_M m;</span><br><span class="line">  m.val = instr_fetch(pc, <span class="number">1</span>);</span><br><span class="line">  decinfo.isa.ext_opcode = m.opcode;</span><br><span class="line">  <span class="keyword">if</span> (reg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    reg-&gt;type = OP_TYPE_REG;</span><br><span class="line">    reg-&gt;reg = m.reg;</span><br><span class="line">    <span class="keyword">if</span> (load_reg_val) &#123;</span><br><span class="line">      rtl_lr(&amp;reg-&gt;val, reg-&gt;reg, reg-&gt;width);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">snprintf</span>(reg-&gt;str, OP_STR_SIZE, <span class="string">&quot;%%%s&quot;</span>, reg_name(reg-&gt;reg, reg-&gt;width));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m.mod == <span class="number">3</span>) &#123;</span><br><span class="line">    rm-&gt;type = OP_TYPE_REG;</span><br><span class="line">    rm-&gt;reg = m.R_M;</span><br><span class="line">    <span class="keyword">if</span> (load_rm_val) &#123;</span><br><span class="line">      rtl_lr(&amp;rm-&gt;val, m.R_M, rm-&gt;width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">sprintf</span>(rm-&gt;str, <span class="string">&quot;%%%s&quot;</span>, reg_name(m.R_M, rm-&gt;width));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    load_addr(pc, &amp;m, rm);</span><br><span class="line">    <span class="keyword">if</span> (load_rm_val) &#123;</span><br><span class="line">      rtl_lm(&amp;rm-&gt;val, &amp;rm-&gt;addr, rm-&gt;width);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先看一下ModR_M的联合定义(x86/include/isa/decode.h)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> R_M		:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> reg		:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> mod		:<span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> dont_care	:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> opcode		:<span class="number">3</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">uint8_t</span> val;</span><br><span class="line">&#125; ModR_M;</span><br></pre></td></tr></table></figure>

<p>我们需要结合x86指令格式的ModR/M去看</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ModR/M byte</span><br><span class="line">7    6    5    4    3    2    1    0</span><br><span class="line"><span class="code">+--------+</span>-------------<span class="code">+-------------+</span></span><br><span class="line">|  mod   | reg/opcode  |     r/m     |</span><br><span class="line"><span class="code">+--------+</span>-------------<span class="code">+-------------+</span></span><br></pre></td></tr></table></figure>

<p>m.val又读取了一个字节，也就是0x84，把这个字节按照上面进行拆分，mod部分是2，reg/opcode是0,因此read_ModR_M()函数执行最后一个else块，先load_addr(pc, &amp;m, rm)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_addr</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, ModR_M *m, Operand *rm)</span> </span>&#123;</span><br><span class="line">  assert(m-&gt;mod != <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int32_t</span> disp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> disp_size = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> base_reg = <span class="number">-1</span>, index_reg = <span class="number">-1</span>, scale = <span class="number">0</span>;</span><br><span class="line">  rtl_li(&amp;s0, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;R_M == R_ESP) &#123;</span><br><span class="line">    SIB s;</span><br><span class="line">    s.val = instr_fetch(pc, <span class="number">1</span>);</span><br><span class="line">    base_reg = s.base;</span><br><span class="line">    scale = s.ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.index != R_ESP) &#123; index_reg = s.index; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* no SIB */</span></span><br><span class="line">    base_reg = m-&gt;R_M;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;mod == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (base_reg == R_EBP) &#123; base_reg = <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; disp_size = <span class="number">0</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (m-&gt;mod == <span class="number">1</span>) &#123; disp_size = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (disp_size != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* has disp */</span></span><br><span class="line">    disp = instr_fetch(pc, disp_size);</span><br><span class="line">    <span class="keyword">if</span> (disp_size == <span class="number">1</span>) &#123; disp = (<span class="keyword">int8_t</span>)disp; &#125;</span><br><span class="line"></span><br><span class="line">    rtl_addi(&amp;s0, &amp;s0, disp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (base_reg != <span class="number">-1</span>) &#123;</span><br><span class="line">    rtl_add(&amp;s0, &amp;s0, &amp;reg_l(base_reg));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index_reg != <span class="number">-1</span>) &#123;</span><br><span class="line">    rtl_shli(&amp;s1, &amp;reg_l(index_reg), scale);</span><br><span class="line">    rtl_add(&amp;s0, &amp;s0, &amp;s1);</span><br><span class="line">  &#125;</span><br><span class="line">  rtl_mv(&amp;rm-&gt;addr, &amp;s0);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">char</span> disp_buf[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">char</span> base_buf[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">char</span> index_buf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (disp_size != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* has disp */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(disp_buf, <span class="string">&quot;%s%#x&quot;</span>, (disp &lt; <span class="number">0</span> ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>), (disp &lt; <span class="number">0</span> ? -disp : disp));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; disp_buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (base_reg == <span class="number">-1</span>) &#123; base_buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="built_in">sprintf</span>(base_buf, <span class="string">&quot;%%%s&quot;</span>, reg_name(base_reg, <span class="number">4</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index_reg == <span class="number">-1</span>) &#123; index_buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="built_in">sprintf</span>(index_buf, <span class="string">&quot;,%%%s,%d&quot;</span>, reg_name(index_reg, <span class="number">4</span>), <span class="number">1</span> &lt;&lt; scale);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (base_reg == <span class="number">-1</span> &amp;&amp; index_reg == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(rm-&gt;str, <span class="string">&quot;%s&quot;</span>, disp_buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(rm-&gt;str, <span class="string">&quot;%s(%s%s)&quot;</span>, disp_buf, base_buf, index_buf);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  rm-&gt;type = OP_TYPE_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>R_ESP是一个常量值为4，在PA1的reg.h里面有定义，本例中m-&gt;R_M也是等于4,说明之后还有一个SIB字节，这个字节指示了如何寻址：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">displacement</span><span class="params">(R[base_reg], R[index_reg], scale_factor)</span></span></span><br></pre></td></tr></table></figure>

<p>我们看下SIB联合的定义(decode.h)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> base	:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> index	:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> ss		:<span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">uint8_t</span> val;</span><br><span class="line">&#125; SIB;</span><br></pre></td></tr></table></figure>

<p>结合x86指令格式：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SIB (scale index base) byte</span><br><span class="line">7    6    5    4    3    2    1    0</span><br><span class="line"><span class="code">+--------+</span>-------------<span class="code">+-------------+</span></span><br><span class="line">|   ss   |    index    |    base     |</span><br><span class="line"><span class="code">+--------+</span>-------------<span class="code">+-------------+</span></span><br></pre></td></tr></table></figure>

<p>本例中SIB字节是0x99，因此base=1,index=3,ss=2。base_reg=1，也就是R_ECX，index_reg是3，也就是EBX，然后因为前面得到的mod的值为2，所以disp_size取默认值4，说明后面有4个字节的偏移量，disp = instr_fetch(pc, disp_size);在本例中取得0xffffe000，也就是-0x2000。ss=2，代表scale=2，向左移2位也就是乘4.</p>
<p>因此最后计算的地址是</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">addr</span> = R[ECX] + R[EBX] * <span class="number">4</span> - <span class="number">0</span>x<span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p>而从代码里面我们可以看到是用了一系列的rtl完成上面这个表达式的计算，用了2个临时寄存器s0和s1保存中间计算结果，具体看代码应该看得懂。总之计算完地址后可以把目的操作数类型填写为OP_TYPE_MEM，并将地址保存在其addr成员中。译码阶段算是完成了，执行阶段与前面mov指令类型就不再赘述了，我们直接开始完成PA2.1。</p>
<p>按照手册的提示，要运行第一个程序需要完成<code>call</code>, <code>push</code>, <code>sub</code>, <code>xor</code>, <code>ret</code>五条指令。更具体的来说，我们需要完成nexus-am/tests/cputest/build/dummy-$ISA-nemu.txt中的这5条指令。（建议配合i386手册食用)</p>
<h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>查看反汇编结果，可以看到这里有2条call指令，且它们的形式相同，都是e8 cd的形式，我们以第一条为例。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span>a:	e8 <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	call   <span class="number">100014</span> &lt;_trm_init&gt;</span><br></pre></td></tr></table></figure>

<p>e8是opcode，后面4个字节是偏移量，跳转的地址是pc+指令长度+偏移量，也就是</p>
<p>0x10000a + 0x5 + 0x5 = 0x100014</p>
<p>我们首先要去填写opcode_table[0xe8]，指示它的译码函数和执行函数，这个需要提前查看所有的译码函数选择恰当的一个，这里选择decode_J(),执行函数也是类似，选择exec_call()，位宽是4个字节，因此</p>
<p>opcode_table[0xe8]=IDEX(J, call)</p>
<p>接下来看译码函数，先明确译码函数的任务应该是再取4个字节作为偏移量，计算出跳转地址并保存在decoinfo中。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_DHelper(J)</span> &#123;</span><br><span class="line">  decode<span class="constructor">_op_SI(<span class="params">pc</span>, <span class="params">id_dest</span>, <span class="params">false</span>)</span>;</span><br><span class="line">  <span class="comment">// the target address can be computed in the decode stage</span></span><br><span class="line">  decinfo.jmp_pc = id_dest-&gt;simm + *pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个辅助函数是写好的，不用我们补充，但是decode_op_SI()函数需要我们自己填写，而且其实主要的工作还是这个函数完成，取width宽度的字节作为偏移量，然后如果width小于4的话，还要进一步进行符号位扩展，最后保存在op-&gt;simm中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* I386 manual does not contain this abbreviation, but it is different from</span></span><br><span class="line"><span class="comment"> * the one above from the view of implementation. So we use another helper</span></span><br><span class="line"><span class="comment"> * function to decode it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* sign immediate */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(SI)</span> </span>&#123;</span><br><span class="line">  assert(op-&gt;width == <span class="number">1</span> || op-&gt;width == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  op-&gt;type = OP_TYPE_IMM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Use instr_fetch() to read `op-&gt;width&#x27; bytes of memory</span></span><br><span class="line"><span class="comment">   * pointed by &#x27;pc&#x27;. Interpret the result as a signed immediate,</span></span><br><span class="line"><span class="comment">   * and assign it to op-&gt;simm.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   op-&gt;simm = ???</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  s0 = instr_fetch(pc, op-&gt;width);</span><br><span class="line">  rtl_sext(&amp;s0, &amp;s0, op -&gt; width);</span><br><span class="line">  op -&gt; simm = s0;</span><br><span class="line"></span><br><span class="line">  rtl_li(&amp;op-&gt;val, op-&gt;simm);</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">&quot;$0x%x&quot;</span>, op-&gt;simm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用rtl_sext进行符号位扩展，不过rtl_sext()也需要自己补充：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_sext</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// dest &lt;- signext(src1[(width * 8 - 1) .. 0])</span></span><br><span class="line">  <span class="keyword">int32_t</span> val = *src1;</span><br><span class="line">  *dest = (val &lt;&lt; (<span class="number">32</span> - width * <span class="number">8</span>)) &gt;&gt; (<span class="number">32</span> - width * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>译码函数算是写完了，再来看执行函数，还是先明确call执行函数的任务：先把下一条指令的地址(seq_pc)压栈，然后跳转到译码函数计算出来的地址(jmp_pc)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(call) &#123;</span><br><span class="line">  <span class="comment">// the target address is calculated at the decode stage</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl_push(&amp;decinfo.seq_pc);</span><br><span class="line">  rtl_j(decinfo.jmp_pc);</span><br><span class="line"></span><br><span class="line">  print_asm(<span class="string">&quot;call %x&quot;</span>, decinfo.jmp_pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rtl_j()已经给出，我们需要实现rtl_push()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// esp &lt;- esp - 4</span></span><br><span class="line">  <span class="comment">// M[esp] &lt;- src1</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  reg_l(R_ESP) -= <span class="number">4</span>;</span><br><span class="line">  rtl_sm(&amp;reg_l(R_ESP), src1, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用rtl_sm作为客户访存，把地址压栈。</p>
<p>整个call指令就算完成了，感觉还是蛮简单的，理解了过程以后真的做起来就感觉不难了。</p>
<h3 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h3><p>ret指令只有一个字节的opcode：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100012</span>:	<span class="keyword">c</span><span class="number">3</span>                   	<span class="keyword">ret</span>   </span><br></pre></td></tr></table></figure>

<p>opcode_table[0xc3]=EX(ret)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(ret) &#123;</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl_pop(&amp;decinfo.jmp_pc);</span><br><span class="line">  rtl_j(decinfo.jmp_pc);</span><br><span class="line"></span><br><span class="line">  print_asm(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rtl_pop()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_pop</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// dest &lt;- M[esp]</span></span><br><span class="line">  <span class="comment">// esp &lt;- esp + 4</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl_lm(dest, &amp;reg_l(R_ESP), <span class="number">4</span>);</span><br><span class="line">  reg_l(R_ESP) += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ret指令比较简单，就不用多讲了。</p>
<h3 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h3><p>push指令的opcode是0x68还有</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10001</span>a:	<span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	push   $<span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>opcode_table[0x68]=IDEX(push_SI, push)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make_DHelper(push_SI) &#123;</span><br><span class="line">  decode_op_SI(pc, id_dest, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>译码函数和call类似，不过不用计算和填写jmp_pc，只需要取到立即数。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_EHelper(<span class="params">push</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl<span class="constructor">_push(&amp;<span class="params">id_dest</span>-&gt;<span class="params">val</span>)</span>;</span><br><span class="line"></span><br><span class="line">  print<span class="constructor">_asm_template1(<span class="params">push</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rtl_push已经实现过了，这样push指令也算完成了。</p>
<p>还有一条push的opcode是0x55，不要忘了。</p>
<h3 id="xor指令"><a href="#xor指令" class="headerlink" title="xor指令"></a>xor指令</h3><p>xor指令的opcode是0x31</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100010</span>:	<span class="number">31</span> <span class="keyword">c</span><span class="number">0</span>                	<span class="keyword">xor</span>    <span class="symbol">%eax</span>,<span class="symbol">%eax</span></span><br></pre></td></tr></table></figure>

<p>opcode_table[0x31]=IDEX(G2E, xor)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make_DHelper(G2E) &#123;</span><br><span class="line">  decode_op_rm(pc, id_dest, <span class="literal">true</span>, id_src, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decode_op_rm</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, Operand *rm, <span class="keyword">bool</span> load_rm_val, Operand *reg, <span class="keyword">bool</span> load_reg_val)</span> </span>&#123;</span><br><span class="line">  read_ModR_M(pc, rm, load_rm_val, reg, load_reg_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>read_ModR_M再读取一个<code>ModR/M</code>字节,0xc0拆分后mod是3代表是reg类型，reg=0代表是EAX，r/m=0代表另一个操作数也是EAX。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(<span class="keyword">xor</span>) &#123;</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl_xor(&amp;s0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val);</span><br><span class="line">  operand_write(id_dest, &amp;s0);</span><br><span class="line">  rtl_update_ZFSF(&amp;s0, id_dest -&gt; width);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// CF = 0, OF = 0</span></span><br><span class="line">  s1 = <span class="number">0</span>;</span><br><span class="line">  rtl_set_CF(&amp;s1);</span><br><span class="line">  rtl_set_OF(&amp;s1);</span><br><span class="line">  </span><br><span class="line">  print_asm_template2(<span class="keyword">xor</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据手册提示，xor会把CF和OF设置为0，另外需要更新ZF和SF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_update_ZF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// eflags.ZF &lt;- is_zero(result[width * 8 - 1 .. 0])</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  t0 = *result &lt;&lt; (<span class="number">32</span> - width * <span class="number">8</span>);</span><br><span class="line">  t0 = (t0 == <span class="number">0</span>);</span><br><span class="line">  rtl_set_ZF(&amp;t0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_update_SF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// eflags.SF &lt;- is_sign(result[width * 8 - 1 .. 0])</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  t0 = (*result) &gt;&gt; (<span class="number">8</span>*width<span class="number">-1</span>);</span><br><span class="line">  t0 = (t0 &amp; <span class="number">1</span>);</span><br><span class="line">  rtl_set_SF(&amp;t0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在这里补充，如何设置符号位，首先需要到PA1里面的reg.h里面修改CPU_state的定义，增加符号位寄存器，并且我们只需要关心其中的CF,ZF,SF,IF,OF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">union</span>&#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> _32;</span><br><span class="line">            <span class="keyword">uint16_t</span> _16;</span><br><span class="line">            <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">        &#125; gpr[<span class="number">8</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            <span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="comment">/* Do NOT change the order of the GPRs&#x27; definitions. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In NEMU, rtlreg_t is exactly uint32_t. This makes RTL instructions</span></span><br><span class="line"><span class="comment">   * in PA2 able to directly access these registers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">vaddr_t</span> pc;</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">		  <span class="keyword">uint32_t</span> CF:<span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">uint32_t</span> :<span class="number">5</span>;</span><br><span class="line">		  <span class="keyword">uint32_t</span> ZF:<span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">uint32_t</span> SF:<span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">uint32_t</span> :<span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">uint32_t</span> IF:<span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">uint32_t</span> :<span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">uint32_t</span> OF:<span class="number">1</span>;</span><br><span class="line">	  &#125;eflags;</span><br><span class="line">	  <span class="keyword">uint32_t</span> eflags_value;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125; CPU_state;</span><br></pre></td></tr></table></figure>

<p>顺便增加一条宏方便使用：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define reg_f(<span class="name">flag</span>)	 (<span class="name">cpu</span>.eflags.flag)</span><br></pre></td></tr></table></figure>

<p>然后到rtl.h修改set/get代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_rtl_setget_eflags(f) \</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">concat</span><span class="params">(rtl_set_, f)</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span> </span>&#123; \</span><br><span class="line">    reg_f(f) = *src;  \</span><br><span class="line">  &#125; \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">concat</span><span class="params">(rtl_get_, f)</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span> </span>&#123; \</span><br><span class="line">    *dest = reg_f(f); \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="sub指令"><a href="#sub指令" class="headerlink" title="sub指令"></a>sub指令</h3><p>sub指令的opcode=0x83</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100017</span>:	<span class="number">83</span> ec <span class="number">14</span>             	sub    $<span class="number">0x14</span>,%esp</span><br></pre></td></tr></table></figure>

<p>opcode_table已经填好了这一项</p>
<p>IDEX(SI2E, gp1)</p>
<p>译码函数已经写好，直接看执行函数exec_gp1，首先我们需要看exec.c文件里面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_group(name, item0, item1, item2, item3, item4, item5, item6, item7) \</span></span><br><span class="line">  static OpcodeEntry concat(opcode_table_, name) [8] = &#123; \</span><br><span class="line">    <span class="comment">/* 0x00 */</span>	item0, item1, item2, item3, \</span><br><span class="line">    <span class="comment">/* 0x04 */</span>	item4, item5, item6, item7  \</span><br><span class="line">  &#125;; \</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">make_EHelper</span><span class="params">(name)</span> </span>&#123; \</span><br><span class="line">  idex(pc, &amp;concat(opcode_table_, name)[decinfo.isa.ext_opcode]); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0x80, 0x81, 0x83 */</span></span><br><span class="line">make_group(gp1,</span><br><span class="line">    EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">    EMPTY, EMPTY, EMPTY, EMPTY)</span><br></pre></td></tr></table></figure>

<p>ext_opcode是5，因为译码的时候读了一个<code>ModR/M</code>字节0xec，其中3-5位作为ext_opcode，上面这一段可以翻译为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exec_gp1</span><span class="params">(<span class="keyword">addr_t</span> *pc)</span></span>&#123;</span><br><span class="line">    idex(pc, &amp;opcode_table_gp1[decinfo.isa.ext_opcode]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说又进行了一次译码，执行。因为ext_opcode是5，先把sub真正的执行函数填写进make_group</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0x80, 0x81, 0x83 */</span></span><br><span class="line">make_group(gp1,</span><br><span class="line">    EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">    EMPTY, EX(sub), EMPTY, EMPTY)</span><br></pre></td></tr></table></figure>

<p>SUB指令涉及到CF,OF,SF,ZF的更新：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_EHelper(<span class="params">sub</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl<span class="constructor">_sub(&amp;<span class="params">s0</span>,&amp;<span class="params">id_dest</span>-&gt;<span class="params">val</span>,&amp;<span class="params">id_src</span>-&gt;<span class="params">val</span>)</span>;</span><br><span class="line">  operand<span class="constructor">_write(<span class="params">id_dest</span>,&amp;<span class="params">s0</span>)</span>;</span><br><span class="line">  <span class="comment">// update ZF SF</span></span><br><span class="line">  rtl<span class="constructor">_update_ZFSF(&amp;<span class="params">s0</span>,<span class="params">id_dest</span>-&gt;<span class="params">width</span>)</span>;</span><br><span class="line">  <span class="comment">// update CF</span></span><br><span class="line">  rtl<span class="constructor">_is_sub_carry(&amp;<span class="params">s1</span>,&amp;<span class="params">s0</span>,&amp;<span class="params">id_dest</span>-&gt;<span class="params">val</span>)</span>;</span><br><span class="line">  rtl<span class="constructor">_set_CF(&amp;<span class="params">s1</span>)</span>;</span><br><span class="line">  <span class="comment">// update OF</span></span><br><span class="line">  rtl<span class="constructor">_is_sub_overflow(&amp;<span class="params">s1</span>,&amp;<span class="params">s0</span>,&amp;<span class="params">id_dest</span>-&gt;<span class="params">val</span>,&amp;<span class="params">id_src</span>-&gt;<span class="params">val</span>,<span class="params">id_dest</span>-&gt;<span class="params">width</span>)</span>;</span><br><span class="line">  rtl<span class="constructor">_set_OF(&amp;<span class="params">s1</span>)</span>;</span><br><span class="line"></span><br><span class="line">  print<span class="constructor">_asm_template2(<span class="params">sub</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CF的判断比较简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_is_sub_carry</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* res, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// dest &lt;- is_carry(src1 - src2)</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  *dest = (*res &gt; *src1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OF的判断标准是x与y异号，同时(x-y)与x异号：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static inline <span class="built_in">void</span> rtl_is_sub_overflow(rtlreg_t* dest,</span><br><span class="line">    <span class="keyword">const</span> rtlreg_t* res, <span class="keyword">const</span> rtlreg_t* src1, <span class="keyword">const</span> rtlreg_t* src2, <span class="built_in">int</span> width) &#123;</span><br><span class="line">  <span class="comment">// dest &lt;- is_overflow(src1 - src2)</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  t0 =  ((*src1)&gt;&gt;(<span class="number">8</span>*width<span class="number">-1</span>)) &amp; <span class="number">1</span>;  </span><br><span class="line">  t1 =  ((*src2)&gt;&gt;(<span class="number">8</span>*width<span class="number">-1</span>)) &amp; <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">  rtl_xor(&amp;t1,&amp;t0,&amp;t1);</span><br><span class="line">  <span class="keyword">if</span>(t1==<span class="number">0</span>) *dest=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    t1=((*res)&gt;&gt;(<span class="number">8</span>*width<span class="number">-1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">    rtl_xor(&amp;t0,&amp;t0,&amp;t1);</span><br><span class="line">    *dest = t0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后不要忘记在all-instr.h里面加上你声明的函数。</p>
<p>PA2.1到此为止</p>
<h2 id="PA2-2"><a href="#PA2-2" class="headerlink" title="PA2.2"></a>PA2.2</h2><p>一上来先把tests里面的测试用例都要做了，这真没办法，一个个的实现，从add.c开始，这里我不可能再分步细说如何去做，步骤和PA2.1其实都一样，个别特殊的指令我会提一下，其他的（其实全部）都可以去看代码读明白。</p>
<h3 id="sete指令"><a href="#sete指令" class="headerlink" title="sete指令"></a>sete指令</h3><p>这是一条双字节opcode的指令，指令的格式如下</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>F  <span class="number">94</span>   SETE r/m8    <span class="number">4</span>/<span class="number">5</span>     Set byte <span class="keyword">if</span> equal (ZF=<span class="number">1</span>)</span><br><span class="line"><span class="comment">//IF condition THEN r/m8 := 1 ELSE r/m8 := 0; FI;</span></span><br></pre></td></tr></table></figure>

<p>opcode_table[0x0f]=EX(2byte_esc)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">make_EHelper</span><span class="params">(<span class="number">2b</span>yte_esc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> opcode = instr_fetch(pc, <span class="number">1</span>) | <span class="number">0x100</span>;</span><br><span class="line">  decinfo.opcode = opcode;</span><br><span class="line">  set_width(opcode_table[opcode].width);</span><br><span class="line">  idex(pc, &amp;opcode_table[opcode]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，需要再读入一个字节，然后以0x100+读入的字节作为索引重新搜索opcode_table。</p>
<p>另外根据第2个字节的低4位确定condition：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> invert = subcode &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    CC_O, CC_NO, CC_B,  CC_NB,</span><br><span class="line">    CC_E, CC_NE, CC_BE, CC_NBE,</span><br><span class="line">    CC_S, CC_NS, CC_P,  CC_NP,</span><br><span class="line">    CC_L, CC_NL, CC_LE, CC_NLE</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>需要完成cc.c文件里面的rtl_setcc()。</p>
<h3 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h3><p>按照手册提示，在这些测试文件中，string.c和hello-str.c需要实现常用的字符串库函数还有printf和sprintf，字符串库函数就不说了，大一的时候就经常做了。这里主要说下sprintf的实现。</p>
<p>在开始之前我要先说一些我在抄代码的时候发现的问题，我做实验的时候参考了2个github的代码，我抄的时候也会相互借鉴，有些地方我觉得可以改善的也会自己修改，因此会有些不同，我相信如果有人抄我代码的时候也不会无脑全抄吧。但是就是这细微的差别我发现使得我和github上面的opcode_table不一样，我来从头到尾讲一下，首先是对于sprintf的实现，其中%d的实现，我觉得其中一个人的不太好，开了个定长数组再倒叙输出数字，于是我选择了使用指针在原字符串的基础上进行倒叙，就不受长度限制了。但是我本来抄他的代码hit good trap了，也就是通过了测试，但是在我修改完sprintf的实现后，突然就告诉我有未实现的汇编指令，然后我打开反汇编一看，确实有一条我没有实现的汇编指令，然后我去看GitHub的opcode_table，发现他也没有实现，我又把代码抄回去，试了下他的代码，然后还是hit good trap了，我马上对比了一下反汇编结果，发现他的反汇编与我的反汇编是不一样的，他没有这条指令，也就是说，根据你对于sprintf的实现，你的反汇编结果是不一样的，要实现的汇编指令也不一定相同，因此如果你抄我的代码，但是又想修改，那你也有可能要加新的汇编指令。</p>
<p>接下来我们具体说下如何实现sprintf：</p>
<p>首先有必要了解下变长参数的原理，对va_list和va_start,va_end,va_arg的用法了解，可以自行上网搜索原理和用法，我看到的这篇博客感觉还可以<a href="https://www.cnblogs.com/pengdonglin137/p/3345911.html">理解可变参数va_list、va_start、va_arg、va_end原理及使用方法</a></p>
<p>刚好博客里面也有%d,%s的实现，我这里也就不用多说了，省点字:)</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/02/hello%20world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#PA1"><span class="nav-number">1.</span> <span class="nav-text">PA1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-0"><span class="nav-number">1.1.</span> <span class="nav-text">PA1.0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-1"><span class="nav-number">1.2.</span> <span class="nav-text">PA1.1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#si%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">si命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">x命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#info-r%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">info r命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-2"><span class="nav-number">1.3.</span> <span class="nav-text">PA1.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-3"><span class="nav-number">1.4.</span> <span class="nav-text">PA1.3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PA2"><span class="nav-number">2.</span> <span class="nav-text">PA2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PA2-1"><span class="nav-number">2.1.</span> <span class="nav-text">PA2.1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#call%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.1.</span> <span class="nav-text">call指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ret%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.2.</span> <span class="nav-text">ret指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#push%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.3.</span> <span class="nav-text">push指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xor%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.4.</span> <span class="nav-text">xor指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sub%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.5.</span> <span class="nav-text">sub指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA2-2"><span class="nav-number">2.2.</span> <span class="nav-text">PA2.2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sete%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.1.</span> <span class="nav-text">sete指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sprintf"><span class="nav-number">2.2.2.</span> <span class="nav-text">sprintf</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuirito</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuirito</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


  <script src='https://unpkg.com/mermaid@/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
