<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="PA1&amp;emsp;&amp;emsp;PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下    命令 格式 使用举例 说明    帮助(1) help help 打印命令的帮助信息   继续运行(1) c c 继续运行被暂停的程序   退出(1) q q 退出NEMU   单步执行 si [N] si 10 让程序单步执行N条指令后暂停执行, 当N没有给出时,">
<meta property="og:type" content="article">
<meta property="og:title" content="ics2019 pa">
<meta property="og:url" content="http://example.com/2020/11/03/ics2019%20pa/index.html">
<meta property="og:site_name" content="yuirito&#39;s blog">
<meta property="og:description" content="PA1&amp;emsp;&amp;emsp;PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下    命令 格式 使用举例 说明    帮助(1) help help 打印命令的帮助信息   继续运行(1) c c 继续运行被暂停的程序   退出(1) q q 退出NEMU   单步执行 si [N] si 10 让程序单步执行N条指令后暂停执行, 当N没有给出时,">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/11/03/ics2019%20pa/pa1.jpg">
<meta property="article:published_time" content="2020-11-03T05:21:06.000Z">
<meta property="article:modified_time" content="2020-11-11T08:12:34.223Z">
<meta property="article:author" content="yuirito">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/11/03/ics2019%20pa/pa1.jpg">

<link rel="canonical" href="http://example.com/2020/11/03/ics2019%20pa/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ics2019 pa | yuirito's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yuirito's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/03/ics2019%20pa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuirito">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yuirito's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ics2019 pa
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-03 13:21:06" itemprop="dateCreated datePublished" datetime="2020-11-03T13:21:06+08:00">2020-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-11 16:12:34" itemprop="dateModified" datetime="2020-11-11T16:12:34+08:00">2020-11-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h1><p>&emsp;&emsp;PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下</p>
<table>
<thead>
<tr>
<th>命令</th>
<th align="left">格式</th>
<th align="left">使用举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>帮助(1)</td>
<td align="left"><code>help</code></td>
<td align="left"><code>help</code></td>
<td>打印命令的帮助信息</td>
</tr>
<tr>
<td>继续运行(1)</td>
<td align="left"><code>c</code></td>
<td align="left"><code>c</code></td>
<td>继续运行被暂停的程序</td>
</tr>
<tr>
<td>退出(1)</td>
<td align="left"><code>q</code></td>
<td align="left"><code>q</code></td>
<td>退出NEMU</td>
</tr>
<tr>
<td>单步执行</td>
<td align="left"><code>si [N]</code></td>
<td align="left"><code>si 10</code></td>
<td>让程序单步执行<code>N</code>条指令后暂停执行, 当<code>N</code>没有给出时, 缺省为<code>1</code></td>
</tr>
<tr>
<td>打印程序状态</td>
<td align="left"><code>info SUBCMD</code></td>
<td align="left"><code>info r</code> <code>info w</code></td>
<td>打印寄存器状态 打印监视点信息</td>
</tr>
<tr>
<td>表达式求值</td>
<td align="left"><code>p EXPR</code></td>
<td align="left"><code>p $eax + 1</code></td>
<td>求出表达式<code>EXPR</code>的值, <code>EXPR</code>支持的 运算请见<a target="_blank" rel="noopener" href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/1.6.html">调试中的表达式求值</a>小节</td>
</tr>
<tr>
<td>扫描内存(2)</td>
<td align="left"><code>x N EXPR</code></td>
<td align="left"><code>x 10 $esp</code></td>
<td>求出表达式<code>EXPR</code>的值, 将结果作为起始内存 地址, 以十六进制形式输出连续的<code>N</code>个4字节</td>
</tr>
<tr>
<td>设置监视点</td>
<td align="left"><code>w EXPR</code></td>
<td align="left"><code>w *0x2000</code></td>
<td>当表达式<code>EXPR</code>的值发生变化时, 暂停程序执行</td>
</tr>
<tr>
<td>删除监视点</td>
<td align="left"><code>d N</code></td>
<td align="left"><code>d 2</code></td>
<td>删除序号为<code>N</code>的监视点</td>
</tr>
</tbody></table>
<p>备注:</p>
<ul>
<li><p>(1) 命令已实现</p>
</li>
<li><p>(2) 与GDB相比, 我们在这里做了简化, 更改了命令的格式</p>
</li>
</ul>
<p>之后再具体说明上述命令如何实现，先看下PA1需要修改的文件，见下图</p>
<p><img src="/2020/11/03/ics2019%20pa/pa1.jpg"></p>
<p>其中ui.c是主要的交互界面代码，进入主循环后，用户输入的命令在这个文件里面进行解析，再分类处理，PA1.1也是从这里开始，主要增加一些命令，后面PA1.1再详述，包括对reg.c文件的修改。</p>
<p>expr.c是表达式处理，主要是辅助完成p 命令，以及后面的监视点，个人认为是PA1里面最重要的部分，是PA1.2的核心内容，为了测试表达式处理是否正确，gen-expr.c是自己设计随机生成一些表达式进行检测，与主程序无关，仅仅测试使用。</p>
<p>watchpoint.h, watchpoint.c是辅助实现w和d命令，也就是建立监视点和删除监视点，另外cpu-exec.c中需要增加几行代码，实现对监视点的监视。后面PA1.3再详述。</p>
<h2 id="PA1-0"><a href="#PA1-0" class="headerlink" title="PA1.0"></a>PA1.0</h2><p>在正式开始PA1之前，如果你选择的是x86的ISA，还有一些准备工作需要做，如果不是x86，可以直接跳过此节。</p>
<p>打开nemu/src/isa/x86/include/isa/reg.h文件，可以看到对CPU_state定义的结构体如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">struct&#123;</span><br><span class="line"> uint32_t _32;</span><br><span class="line"> uint16_t _16;</span><br><span class="line"> uint8_t _8[2];</span><br><span class="line"> &#125;gpr[8];</span><br><span class="line">rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">vaddr_t pc;</span><br><span class="line">&#125;CPU_state;</span><br></pre></td></tr></table></figure>

<p>因为原先定义的是struct，gpr数组和8个寄存器并没有关联，物理上是顺序独立的排列，为了让他们相关联起来，就要使用union，改后的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    union&#123;</span><br><span class="line">        union&#123;</span><br><span class="line">            uint32_t _32;</span><br><span class="line">            uint16_t _16;</span><br><span class="line">            uint8_t _8[2];</span><br><span class="line">        &#125; gpr[8];</span><br><span class="line">        struct&#123;</span><br><span class="line">            rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  vaddr_t pc;</span><br><span class="line"></span><br><span class="line">&#125; CPU_state;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以观察reg.c中的reg_test()是如何进行测试的，生成一个随机数，然后赋值给每个32位的寄存器，然后对关联性检查。</p>
<p>修改完代码以后，在menu目录下执行make run，如果看到欢迎提示，进入(menu)等待输入命令就说明成功了。</p>
<h2 id="PA1-1"><a href="#PA1-1" class="headerlink" title="PA1.1"></a>PA1.1</h2><p>PA1.1要实现si, x, info r三条命令。</p>
<p>要增加一条新的命令先写一个对应的函数，然后在cmd_table中增加命令的名称，说明，函数即可</p>
<p>cmd_table的结构定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static struct &#123;</span><br><span class="line">  char *name;</span><br><span class="line">  char *description;</span><br><span class="line">  int (*handler) (char *);</span><br><span class="line">&#125; cmd_table []</span><br></pre></td></tr></table></figure>



<h4 id="si命令"><a href="#si命令" class="headerlink" title="si命令"></a>si命令</h4><p>我先上我写的cmd_si()，再具体说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int cmd_si(char *args) &#123;</span><br><span class="line">    &#x2F;* extract the first argument *&#x2F;</span><br><span class="line">    char *arg &#x3D; strtok(NULL, &quot; &quot;);</span><br><span class="line">    if (arg &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;* no argument given *&#x2F;</span><br><span class="line">        cpu_exec(1);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        int n &#x3D; atoi(arg);</span><br><span class="line">        if(n&gt;0)</span><br><span class="line">            cpu_exec(n);</span><br><span class="line">        else</span><br><span class="line">            cmd_err(0, &quot;si:N&lt;&#x3D;0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cmd_si是我觉得这几个命令里面相对来说最简单的一个，因为他只要读出命令中的N，转化为数字再传给cpu_exec()即可，cpu_exec(n)是执行程序，其参数n是执行n步，在这里先用strtok函数读入命令格式中的N，如果没有的话就默认执行1步，即cpu_exec(1)，否则的话用atoi转化为数字后再调用。另外这里cmd_err是一个通用的报错函数，定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void cmd_err(int err_type,const char *command)&#123;</span><br><span class="line">    switch(err_type)&#123;</span><br><span class="line">        case 0:</span><br><span class="line">            printf(&quot;Invalid arguments for command &#39;%s&#39;\n&quot;,command);</span><br><span class="line">            break;</span><br><span class="line">        case 1:</span><br><span class="line">            printf(&quot;Lack arguments for command &#39;%s&#39;\n&quot;,command);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;Unknown error\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="x命令"><a href="#x命令" class="headerlink" title="x命令"></a>x命令</h4><p>x命令需要用到vaddr_read(addr,n)函数，其中参数addr是内存地址，n是读出的字节数，思路和刚刚一样，先用strtok函数读出命令的2个参数N和exp，这里暂时不考虑复杂的表达式，仅限于16进制数字，所以可以直接使用sscanf(arg2,”%x”,&amp;addr);将第2个参数地址得到，然后再用vaddr_read(addr,4)每次读出4个字节的内存，循环N次即可。</p>
<h4 id="info-r命令"><a href="#info-r命令" class="headerlink" title="info r命令"></a>info r命令</h4><p>因为监视点是PA1.3建立，相关内容都要在PA1.3实现，所以目前info命令仅限于实现info r查看所有寄存器的值，让我们先到x86下面的reg.c文件，在这里实现一个显示所有寄存器的接口void isa_reg_display()，其实也很简单，就只是printf所有寄存器的值而已，打印的格式可以参考如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void isa_reg_display() &#123;</span><br><span class="line">    &#x2F;* PA1.1 *&#x2F;</span><br><span class="line">    printf(&quot;eax\t0x%-8x\t%u\n&quot;,cpu.eax,cpu.eax);</span><br><span class="line">    printf(&quot;ecx\t0x%-8x\t%u\n&quot;,cpu.ecx,cpu.ecx);</span><br><span class="line">    printf(&quot;edx\t0x%-8x\t%u\n&quot;,cpu.edx,cpu.edx);</span><br><span class="line">    printf(&quot;ebx\t0x%-8x\t%u\n&quot;,cpu.ebx,cpu.ebx);</span><br><span class="line">    printf(&quot;esp\t0x%-8x\t%u\n&quot;,cpu.esp,cpu.esp);</span><br><span class="line">    printf(&quot;ebp\t0x%-8x\t%u\n&quot;,cpu.ebp,cpu.ebp);</span><br><span class="line">    printf(&quot;esi\t0x%-8x\t%u\n&quot;,cpu.esi,cpu.esi);</span><br><span class="line">    printf(&quot;edi\t0x%-8x\t%u\n&quot;,cpu.edi,cpu.edi);</span><br><span class="line">    printf(&quot;pc\t0x%-8x\t%u\n&quot;,cpu.pc,cpu.pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个接口实现info r就很简单了，只需要判断参数==’r’，然后直接调用reg.c里面的isa_reg_display()即可</p>
<p>至此PA1.1就完成了，PA1.1本身不难，不过要先理解整个代码框架的结构</p>
<h2 id="PA1-2"><a href="#PA1-2" class="headerlink" title="PA1.2"></a>PA1.2</h2><p>如果你做过编译原理实验，这部分其实也不会太难，就是编译原理实验的一小部分。</p>
<p>我们一步一步来，首先对于一个表达式，我们要识别其中的符号token，例如对于表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;4 +3*(2- 1)&quot;</span><br></pre></td></tr></table></figure>

<p>的token表达式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+-----+-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">| NUM | &#39;+&#39; | NUM | &#39;*&#39; | &#39;(&#39; | NUM | &#39;-&#39; | NUM | &#39;)&#39; |</span><br><span class="line">| &quot;4&quot; |     | &quot;3&quot; |     |     | &quot;2&quot; |     | &quot;1&quot; |     |</span><br><span class="line">+-----+-----+-----+-----+-----+-----+-----+-----+-----+</span><br></pre></td></tr></table></figure>

<p>在expr.c中首先在enum中添加你想定义的token。我推荐一步到位，PA1.2就把全部的表达式做好。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>意义</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>TK_NOTYPE</td>
<td>空格</td>
<td>0</td>
</tr>
<tr>
<td>TK_NUM</td>
<td>十进制数字</td>
<td>0</td>
</tr>
<tr>
<td>TK_HEX</td>
<td>十六进制数字</td>
<td>0</td>
</tr>
<tr>
<td>TK_REG</td>
<td>寄存器</td>
<td>0</td>
</tr>
<tr>
<td>TK_OR</td>
<td>||</td>
<td>1</td>
</tr>
<tr>
<td>TK_AND</td>
<td>&amp;&amp;</td>
<td>2</td>
</tr>
<tr>
<td>TK_EQ</td>
<td>==</td>
<td>3</td>
</tr>
<tr>
<td>TK_PLUS</td>
<td>+</td>
<td>4</td>
</tr>
<tr>
<td>TK_SUB</td>
<td>-</td>
<td>4</td>
</tr>
<tr>
<td>TK_MUL</td>
<td>*</td>
<td>5</td>
</tr>
<tr>
<td>TK_DIV</td>
<td>/</td>
<td>5</td>
</tr>
<tr>
<td>TK_NEGTIVE</td>
<td>负数</td>
<td>6</td>
</tr>
<tr>
<td>TK_DEREF</td>
<td>引用(例:*$eax)</td>
<td>6</td>
</tr>
<tr>
<td>TK_LBR</td>
<td>(</td>
<td>7</td>
</tr>
<tr>
<td>TK_RBR</td>
<td>）</td>
<td>7</td>
</tr>
</tbody></table>
<p>TK_NEGTIVE和TK_DEREF比较特殊，因为他们的符号分别和TK_SUB和TK_MUL是一样的，需要特殊处理，将他们区分开来，这个是在识别完所有token之后做的，暂时先忽略这2个，之后会讲。</p>
<p>还有一点是这里建议引入优先级，便于后续操作，所以你也需要把原先代码里面对于rule结构体增加一项优先级的成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static struct rule &#123;</span><br><span class="line">  char *regex;</span><br><span class="line">  int token_type;</span><br><span class="line">  int priority; &#x2F;&#x2F; add priority</span><br><span class="line">&#125; rules[]</span><br></pre></td></tr></table></figure>

<p>当然Token结构体也不要忘了加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct token &#123;</span><br><span class="line">  int type;</span><br><span class="line">  char str[32];</span><br><span class="line">  int priority; &#x2F;&#x2F;add priority</span><br><span class="line">&#125; Token</span><br></pre></td></tr></table></figure>

<p>填写好rules，正则表达式，符号，优先级。在make_token中会对表达式挨个字符进行分析，从第一条规则开始遍历rules，匹配成功以后，首先对匹配字符串的长度检测，判断是否大于32，如果大于32个字符assert(0)，否则的话，根据匹配的规则，进行进一步操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (rules[i].token_type) &#123;</span><br><span class="line">            case TK_NOTYPE: break;</span><br><span class="line">            case TK_NUM:</span><br><span class="line">            case TK_HEX:</span><br><span class="line">            case TK_REG:</span><br><span class="line">                strncpy(tokens[nr_token].str, substr_start, substr_len);</span><br><span class="line">				        tokens[nr_token].str[substr_len] &#x3D; &#39;\0&#39;;</span><br><span class="line">          default: </span><br><span class="line">                tokens[nr_token].type &#x3D; rules[i].token_type;</span><br><span class="line">                tokens[nr_token].priority &#x3D; rules[i].priority;</span><br><span class="line">				        nr_token++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>对每个规则都要做的是，将其类型和优先级存入tokens数组，而对于数字，额外需要的操作是将其字符串也要保存，为了之后得到具体数值。对于空格就跳过即可。</p>
<p>另外值得一提的是这里可以把tokens数字开大一点，后面测试的时候需要修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Token tokens[65536] __attribute__((used)) &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>到这里第一步算是完成了，第一步的工作是利用正则表达式识别给定表达式的token，然后将其顺序的存入tokens数组，保存其类型，优先级，和数字的字符串（相当于是数值）。</p>
<p>接下来在完成手册中提示的eval()函数之前，我们还需要写2个辅助函数——check_parentheses()和get_main_op()。</p>
<p>int check_parentheses(int p, int q)，这里建议将返回类型由bool改为int，因为需要返回3种不同情况。参数p和q分别是tokens数组的起始和结束位置。函数的功能是根据tokens数组从p到q这部分所代表的表达式返回以下3种：</p>
<ul>
<li>返回1    如果表达式是一个由一对左右括号完整包裹的一个有效表达式。</li>
<li>返回0    如果表达式是一个有效的表达式，但是并没有被一对左右括号包裹。</li>
<li>返回-1   如果表达式不是一个有效的表达式。  </li>
</ul>
<p>另外值得一提的是这里需要考虑一种特殊情况，就是虽然是一个有效的表达式，同时左右分别是左括号和号，但是这两个括号并不是一对，例如<br>$$<br>(4+3)*(4+4)<br>$$<br>对于这样的表达式，应该返回0而不是1。这里是对括号的匹配性进行检测，其他方面的细节可以不用管。从p位置开始到q位置，用n进行记录，如果遇到左括号n+1如果遇到右括号n-1,在循环过程中，只要n变为负数可以理解退出返回-1，如果循环结束n不为0也返回-1。剩下的就不用多说了，反正直接看代码也就懂了。</p>
<p>int get_main_op(int p, int q)，参数的意义同上，函数的作用是从p位置开始扫描到q位置，找到一个优先级最低的运算符号且该运算符号不能在括号包裹的表达式里面，同优先级的情况下取最右边的运算符号作为主符号，最后将主符号的位置返回。因为tokens里面有存各个符号的优先级，所以这里就可以非常简单的实现。判断括号内的方法可以参考上面的用n记录的方法，只有当n等于0的时候说明不在括号内，这时候再进行对运算符号优先级的比较。</p>
<p>两个辅助函数写完的情况下，对于PA1.2来说可以去实现关键的eval()函数了，但是我一开始就说过了要一步到位，所以先不急着去写eval()函数，我们需要先到expr()函数里面完成一些前置工作。</p>
<p>uint32_t expr(char <em>e, bool <em>success)，对字符串e进行表达式求值，如果求值成功\</em>success==true，失败\</em>success==false，返回求值的结果。expr()函数首先调用make_token完成我前面说的第一步，将表达式进行符号解析存入tokens数组中，之后就是我们需要添加的代码，在已经完成第一步解析的基础上，需要对*和-进行进一步的分析，识别出TK_DEREF和TK_NEGTIVE。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0; i&lt;nr_token; i++)&#123;</span><br><span class="line">    if(tokens[i].type &#x3D;&#x3D; TK_MUL &amp;&amp; (i&#x3D;&#x3D;0 || (tokens[i-1].priority!&#x3D;0 &amp;&amp; tokens[i-1].type!&#x3D;TK_RBR)))&#123;</span><br><span class="line">       tokens[i].type &#x3D; TK_DEREF;</span><br><span class="line">       tokens[i].priority &#x3D; 6;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (tokens[i].type &#x3D;&#x3D; TK_SUB &amp;&amp; (i&#x3D;&#x3D;0 || (tokens[i-1].priority!&#x3D;0 &amp;&amp; tokens[i-1].type!&#x3D;TK_RBR)))&#123;</span><br><span class="line">       tokens[i].type &#x3D; TK_NEGTIVE;</span><br><span class="line">       tokens[i].priority &#x3D; 6;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>对tokens数组扫描，对于其中的*也就是type是TK_MUL，如果位置在第一个，或者他的前一个符号不是数字(可以用优先级简单的判断，因为数字的优先级是0)，且不是右括号，那么将这个TK_MUL重新解释为TK_DEREF，优先级为6。同理对TK_NEGTIVE也进行类似的判断识别。现在所有符号都正确的识别了，可以使用eval对其进行求值了。</p>
<p>uint32_t eval(int p, int q, bool <em>success)，求出tokens数组从p到q所代表的表达式的值，如果求值成功\</em>success==true，失败*success==false，返回求值的结果。eval的大致框架和思路在手册里面有写，这里就不赘述了。eval流程图如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A(开始) --&gt; B&#123;p与q的关系&#125;</span><br><span class="line">    B --&gt; |p &gt; q| err[*success&#x3D;false&lt;br &#x2F;&gt;return -1]</span><br><span class="line">    B --&gt; |p &#x3D;&#x3D; q| E[&quot;根据tokens[p].type&lt;br &#x2F;&gt;(10进制,16进制或寄存器)求值&quot;]</span><br><span class="line">    B --&gt; |p &lt; q| F[&quot;ret&#x3D;check_parenthese(p,q)&quot;]</span><br><span class="line">    F --&gt; G&#123;ret返回值&#125;</span><br><span class="line">    G --&gt; |ret &#x3D;&#x3D; -1| err</span><br><span class="line">    G --&gt; |ret &#x3D;&#x3D; 1| ret1[&quot;return eval(p+1,q-1,success)&quot;]</span><br><span class="line">    G --&gt; |ret &#x3D;&#x3D; 0| ret0[&quot;pos&#x3D;get_main_op(p,q)&quot;]</span><br><span class="line">    ret0 --&gt; |pos &#x3D;&#x3D; -1| err</span><br><span class="line">    ret0 --&gt; |pos !&#x3D; -1| eval[&quot;val1 &#x3D; eval(p, pos - 1, success);&lt;br &#x2F;&gt;</span><br><span class="line">    val2 &#x3D; eval(pos + 1, q, success);&lt;br &#x2F;&gt;</span><br><span class="line">    根据tokens[pos].type进行运算&quot;]</span><br></pre></td></tr></table></figure>

<p>有了流程图，大致的代码思路应该已经有了，再来说下其中的细节。</p>
<p>首先是p==q的时候，这时候说明这个表达式没有运算符号，其本身是一个数值或者寄存器，如果是TK_NUM或者TK_HEX，那么直接strtoul(tokens[p].str, NULL, 0)就可以把字符串转化为数值，如果是TK_REG，那么需要使用isa_reg_str2val(tokens[p].str + 1, success)获取寄存器的值。这个isa_reg_str2val()函数在之前的reg.c中，需要你去实现它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint32_t isa_reg_str2val(const char *s, bool *success) &#123;</span><br><span class="line">  &#x2F;* PA1.2 *&#x2F;</span><br><span class="line">  *success &#x3D; true;</span><br><span class="line">	if(strcmp(s, &quot;pc&quot;) &#x3D;&#x3D; 0 || strcmp(s, &quot;eip&quot;) &#x3D;&#x3D; 0)  return cpu.pc;</span><br><span class="line">	int i;</span><br><span class="line">	for(i &#x3D; R_EAX; i &lt;&#x3D; R_EDI; ++ i) &#123;</span><br><span class="line">		if(strcmp(s, regsl[i]) &#x3D;&#x3D; 0) return reg_l(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for(i &#x3D; R_AX; i &lt;&#x3D; R_DI; ++ i)&#123;</span><br><span class="line">		if(strcmp(s, regsw[i]) &#x3D;&#x3D; 0) return reg_w(i);</span><br><span class="line">	&#125;</span><br><span class="line">	for(i &#x3D; R_AL; i &lt;&#x3D; R_BH; ++ i)&#123;</span><br><span class="line">		if(strcmp(s, regsb[i]) &#x3D;&#x3D; 0) return reg_b(i);</span><br><span class="line">	&#125;</span><br><span class="line">	*success &#x3D; false;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有的寄存器，比对传入参数s和寄存器的名字，找到s对应的寄存器然后返回寄存器中的值。</p>
<p>第2个细节是根据tokens[pos].type进行运算，pos的位置指向主运算符，如果这个主运算符是除法，那么应该注意一下对于除以0行为的处理，也就是判断val2==0?，简单一点直接assert(0)也可以，也可以输出一段提示后，*success=false。其他的运算符都比较简单，注意TK_DEREF是val=vaddr_read(val2,4)以及TK_NEGTIVE是val=-val2即可。(这两个运算符并没有用到val1)</p>
<p>其实到这里PA1.2已经完成了，但是手册里面要求你还需要对你的表达式写一个程序随机测验，所以你还需要完成gen-expr.c。测试原理在手册里面已经讲了，而我们在这个文件中需要自己补充的仅仅是随机生成一个表达式的部分，我直接贴上我的代码再讲比较方便，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* PA1.2 *&#x2F;</span><br><span class="line">#define N_TOKEN 10</span><br><span class="line">static char buf[5000];</span><br><span class="line"></span><br><span class="line">static uint32_t choose(uint32_t n)&#123;</span><br><span class="line">	return rand() % n;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void gen_rand_expr(int l,int r) &#123;</span><br><span class="line">  int op;</span><br><span class="line">  if(l&#x3D;&#x3D;r)buf[l]&#x3D;choose(10)+48;</span><br><span class="line">  else if(r&#x3D;&#x3D;l+1)&#123;</span><br><span class="line">	  buf[l]&#x3D;choose(9)+1+48;</span><br><span class="line">	  buf[r]&#x3D;choose(10)+48;</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">	  switch(choose(1))&#123;</span><br><span class="line">		  case 0:</span><br><span class="line">              op&#x3D;l+1+choose(r-l-1);</span><br><span class="line">			  gen_rand_expr(l,op-1);</span><br><span class="line">              static char ops[] &#x3D; &quot;+-*&#x2F;&quot;;</span><br><span class="line">			  buf[op]&#x3D;ops[choose(4)];</span><br><span class="line">			  gen_rand_expr(op+1,r);</span><br><span class="line">			  break;</span><br><span class="line">		  default:</span><br><span class="line">			  buf[l]&#x3D;&#39;(&#39;;</span><br><span class="line">			  buf[r]&#x3D;&#39;)&#39;;</span><br><span class="line">			  gen_rand_expr(l+1,r-1);</span><br><span class="line">			  break;</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>N_TOKEN是最后表达式中token的数目，uint32_t choose(uint32_t n)随机生成一个0~n-1的数。</p>
<p>void gen_rand_expr(int l,int r)在字符串位置l和r之间随机生成表达式的token，如果r==l生成一个1位数字，如果r==l+1生成一个两位数，此外，从下面2种情况中生成一种：</p>
<ul>
<li>在l+1到r-1中随机选取一个位置作为主符号的位置op，并从加减乘除当中随机选择一个符号。递归调用gen_rand_expr(l,op-1)和gen_rand_expr(op+1,r)生成两边的表达式。</li>
<li>在l和r的位置生成一对括号，递归调用gen_rand_expr(l+1,r-1)，生成被一对括号包裹的表达式。  </li>
</ul>
<p>最后修改下面的main函数中对gen_rand_expr()的调用，加上参数，就完成了。别忘了修改buf和code_buf数组的大小，至少保证buf的长度小于code_buf。</p>
<p>完成了以后记得去ui.c中加入p命令，方式同PA1.1。这里只要调用expr即可，我附上我的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int cmd_p(char *args) &#123;</span><br><span class="line">    &#x2F;* extract the first argument *&#x2F;</span><br><span class="line">    if (args &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;* no argument given *&#x2F;</span><br><span class="line">        cmd_err(0, &quot;p: no argument given\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        bool success &#x3D; true;</span><br><span class="line">        uint32_t result &#x3D; expr(args,&amp;success);</span><br><span class="line">        if(success) printf(&quot;0x%x(%d)\n&quot;,result,result);</span><br><span class="line">        else printf(&quot;Invalid expr\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="PA1-3"><a href="#PA1-3" class="headerlink" title="PA1.3"></a>PA1.3</h2><p>PA1.3要求实现监视点的创建和删除。首先我们先到watchpoint.h查看WP结构体，可以看到原始定义只有表示WP的序号NO以及作为链表结点必须的next指针，这显然是不够的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct watchpoint &#123;</span><br><span class="line">  int NO;</span><br><span class="line">  struct watchpoint *next;</span><br><span class="line">  &#x2F;* TODO: Add more members if necessary *&#x2F;</span><br><span class="line">  &#x2F;* PA1.3*&#x2F;</span><br><span class="line">  char expr[128];</span><br><span class="line">  uint32_t value;</span><br><span class="line">  int hit;</span><br><span class="line">&#125; WP;</span><br></pre></td></tr></table></figure>

<p>需要添加的成员有3个：</p>
<ul>
<li>char expr[128]：用于记录创建的监视点的表达式，例如$eax</li>
<li>uint32_t value：求出当前的表达式的值，表达式是不变的，但是其值会变，因为寄存器值会变，当表达式值改变的时候就要暂停程序，算是命中。</li>
<li>int hit：记录该监视点的命中次数。</li>
</ul>
<p>监视点采用链表池的结构管理，所有监视点保存在wp_pool数组中，而正在使用的监视点由head指针串起的一个链表，空闲的监视点链表由free_指向。</p>
<p>剩下的其实都是基本的链表操作，例如创建一个监视点，就是将free_指向的首结点从空闲链表摘除，加进head指向的链表。并设置其expr,hit,计算expr。而删除一个监视点，就是遍历head指向的链表，找到一个结点其序号NO与给定的相符，将其从head链表中删除，移到free_链表。</p>
<p>除了添加和删除，还需要展示监视点的内容，这里是继续了PA1.1的info w命令，函数自己命名，展示格式可以参考如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void display_wp()</span><br><span class="line">&#123;</span><br><span class="line">	if(head &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		printf(&quot;There is no watchpoint!\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Num     What     Value\n&quot;);</span><br><span class="line">	WP *p &#x3D; head;</span><br><span class="line">	while(p !&#x3D; NULL) &#123;</span><br><span class="line">		printf(&quot;%-8d%-9s%u(%#x)\n&quot;, p -&gt; NO, p -&gt; expr, p-&gt;value, p-&gt;value);</span><br><span class="line">		if(p -&gt; hit &gt; 0) printf(&quot;\tbreakpoint already hit %d time\n&quot;, p-&gt;hit);</span><br><span class="line">		p &#x3D; p -&gt; next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，你还需要一个功能，监视点的作用是当监视的表达式的值变化时，暂停程序。我们先实现bool check_wp()，它的功能是检查所有监视点，看是否有监视点的表达式值发生了变化。方法很简单，遍历head指向的所有正在使用的监视点，然后重新计算其expr的值，与之前保存在value当中的值比对，如果不同的话，说明表达式的值发生了变化。然后需要暂停程序，这里手册给了提示，只要把nemu_state.state赋值为NEMU_STOP即可。在cpu_exec.c的cpu_exec()函数，我们会亲切的发现已经有注释写好了你需要添加的位置，而你只需要在这行注释下面添加这么几行代码即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* TODO: check watchpoints here. *&#x2F;</span><br><span class="line">    &#x2F;* PA1.3*&#x2F;</span><br><span class="line">  bool changed &#x3D; check_wp();</span><br><span class="line">	if(changed)&#123;</span><br><span class="line">		nemu_state.state &#x3D; NEMU_STOP;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后别忘了回到ui.c完善你所有的命令，整个PA1就算完成了，其实还算简单，真正痛苦的地狱PA2才正要开始。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/02/hello%20world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#PA1"><span class="nav-number">1.</span> <span class="nav-text">PA1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-0"><span class="nav-number">1.1.</span> <span class="nav-text">PA1.0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-1"><span class="nav-number">1.2.</span> <span class="nav-text">PA1.1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#si%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">si命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">x命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#info-r%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">info r命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-2"><span class="nav-number">1.3.</span> <span class="nav-text">PA1.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-3"><span class="nav-number">1.4.</span> <span class="nav-text">PA1.3</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuirito</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuirito</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
