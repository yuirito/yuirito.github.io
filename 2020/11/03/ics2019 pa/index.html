<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="PA1PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下    命令 格式 使用举例 说明    帮助(1) help help 打印命令的帮助信息   继续运行(1) c c 继续运行被暂停的程序   退出(1) q q 退出NEMU   单步执行 si [N] si 10 让程序单步执行N条指令后暂停执行, 当N没有给出时, 缺省为1   打印程序">
<meta property="og:type" content="article">
<meta property="og:title" content="ics2019 pa">
<meta property="og:url" content="http://example.com/2020/11/03/ics2019%20pa/index.html">
<meta property="og:site_name" content="yuirito&#39;s blog">
<meta property="og:description" content="PA1PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下    命令 格式 使用举例 说明    帮助(1) help help 打印命令的帮助信息   继续运行(1) c c 继续运行被暂停的程序   退出(1) q q 退出NEMU   单步执行 si [N] si 10 让程序单步执行N条指令后暂停执行, 当N没有给出时, 缺省为1   打印程序">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2020/11/03/ics2019%20pa/pa1.jpg">
<meta property="article:published_time" content="2020-11-03T05:21:06.000Z">
<meta property="article:modified_time" content="2020-11-13T14:09:19.380Z">
<meta property="article:author" content="yuirito">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2020/11/03/ics2019%20pa/pa1.jpg">

<link rel="canonical" href="http://example.com/2020/11/03/ics2019%20pa/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ics2019 pa | yuirito's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yuirito's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/03/ics2019%20pa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yuirito">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yuirito's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ics2019 pa
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-03 13:21:06" itemprop="dateCreated datePublished" datetime="2020-11-03T13:21:06+08:00">2020-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-13 22:09:19" itemprop="dateModified" datetime="2020-11-13T22:09:19+08:00">2020-11-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h1><p>PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下</p>
<table>
<thead>
<tr>
<th>命令</th>
<th align="left">格式</th>
<th align="left">使用举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>帮助(1)</td>
<td align="left"><code>help</code></td>
<td align="left"><code>help</code></td>
<td>打印命令的帮助信息</td>
</tr>
<tr>
<td>继续运行(1)</td>
<td align="left"><code>c</code></td>
<td align="left"><code>c</code></td>
<td>继续运行被暂停的程序</td>
</tr>
<tr>
<td>退出(1)</td>
<td align="left"><code>q</code></td>
<td align="left"><code>q</code></td>
<td>退出NEMU</td>
</tr>
<tr>
<td>单步执行</td>
<td align="left"><code>si [N]</code></td>
<td align="left"><code>si 10</code></td>
<td>让程序单步执行<code>N</code>条指令后暂停执行, 当<code>N</code>没有给出时, 缺省为<code>1</code></td>
</tr>
<tr>
<td>打印程序状态</td>
<td align="left"><code>info SUBCMD</code></td>
<td align="left"><code>info r</code> <code>info w</code></td>
<td>打印寄存器状态 打印监视点信息</td>
</tr>
<tr>
<td>表达式求值</td>
<td align="left"><code>p EXPR</code></td>
<td align="left"><code>p $eax + 1</code></td>
<td>求出表达式<code>EXPR</code>的值, <code>EXPR</code>支持的 运算请见<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/1.6.html">调试中的表达式求值</a>小节</td>
</tr>
<tr>
<td>扫描内存(2)</td>
<td align="left"><code>x N EXPR</code></td>
<td align="left"><code>x 10 $esp</code></td>
<td>求出表达式<code>EXPR</code>的值, 将结果作为起始内存 地址, 以十六进制形式输出连续的<code>N</code>个4字节</td>
</tr>
<tr>
<td>设置监视点</td>
<td align="left"><code>w EXPR</code></td>
<td align="left"><code>w *0x2000</code></td>
<td>当表达式<code>EXPR</code>的值发生变化时, 暂停程序执行</td>
</tr>
<tr>
<td>删除监视点</td>
<td align="left"><code>d N</code></td>
<td align="left"><code>d 2</code></td>
<td>删除序号为<code>N</code>的监视点</td>
</tr>
</tbody></table>
<p>备注:</p>
<ul>
<li><p>(1) 命令已实现</p>
</li>
<li><p>(2) 与GDB相比, 我们在这里做了简化, 更改了命令的格式</p>
</li>
</ul>
<p>之后再具体说明上述命令如何实现，先看下PA1需要修改的文件，见下图</p>
<p><img src="/2020/11/03/ics2019%20pa/pa1.jpg"></p>
<p>其中ui.c是主要的交互界面代码，进入主循环后，用户输入的命令在这个文件里面进行解析，再分类处理，PA1.1也是从这里开始，主要增加一些命令，后面PA1.1再详述，包括对reg.c文件的修改。</p>
<p>expr.c是表达式处理，主要是辅助完成p 命令，以及后面的监视点，个人认为是PA1里面最重要的部分，是PA1.2的核心内容，为了测试表达式处理是否正确，gen-expr.c是自己设计随机生成一些表达式进行检测，与主程序无关，仅仅测试使用。</p>
<p>watchpoint.h, watchpoint.c是辅助实现w和d命令，也就是建立监视点和删除监视点，另外cpu-exec.c中需要增加几行代码，实现对监视点的监视。后面PA1.3再详述。</p>
<h2 id="PA1-0"><a href="#PA1-0" class="headerlink" title="PA1.0"></a>PA1.0</h2><p>在正式开始PA1之前，如果你选择的是x86的ISA，还有一些准备工作需要做，如果不是x86，可以直接跳过此节。</p>
<p>打开nemu/src/isa/x86/include/isa/reg.h文件，可以看到对CPU_state定义的结构体如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="keyword">uint32_t</span> _32;</span><br><span class="line"> <span class="keyword">uint16_t</span> _16;</span><br><span class="line"> <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line"> &#125;gpr[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line"><span class="keyword">vaddr_t</span> pc;</span><br><span class="line">&#125;CPU_state;</span><br></pre></td></tr></table></figure>

<p>因为原先定义的是struct，gpr数组和8个寄存器并没有关联，物理上是顺序独立的排列，为了让他们相关联起来，就要使用union，改后的代码如下</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">            uint32_t _32;</span><br><span class="line">            uint16_t _16;</span><br><span class="line">            uint8_t _8[<span class="number">2</span>];</span><br><span class="line">        &#125; gpr[<span class="number">8</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">            rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  vaddr_t pc;</span><br><span class="line"></span><br><span class="line">&#125; CPU_state;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以观察reg.c中的reg_test()是如何进行测试的，生成一个随机数，然后赋值给每个32位的寄存器，然后对关联性检查。</p>
<p>修改完代码以后，在menu目录下执行make run，如果看到欢迎提示，进入(menu)等待输入命令就说明成功了。</p>
<h2 id="PA1-1"><a href="#PA1-1" class="headerlink" title="PA1.1"></a>PA1.1</h2><p>PA1.1要实现si, x, info r三条命令。</p>
<p>要增加一条新的命令先写一个对应的函数，然后在cmd_table中增加命令的名称，说明，函数即可</p>
<p>cmd_table的结构定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">char</span> *description;</span><br><span class="line">  <span class="keyword">int</span> (*handler) (<span class="keyword">char</span> *);</span><br><span class="line">&#125; cmd_table []</span><br></pre></td></tr></table></figure>



<h4 id="si命令"><a href="#si命令" class="headerlink" title="si命令"></a>si命令</h4><p>我先上我写的cmd_si()，再具体说明</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">int</span> cmd<span class="constructor">_si(<span class="params">char</span> <span class="operator">*</span><span class="params">args</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* extract the first argument */</span></span><br><span class="line">    <span class="built_in">char</span> *arg = strtok(NULL, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (arg<span class="operator"> == </span>NULL) &#123;</span><br><span class="line">        <span class="comment">/* no argument given */</span></span><br><span class="line">        cpu<span class="constructor">_exec(1)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> n = atoi(arg);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">            cpu<span class="constructor">_exec(<span class="params">n</span>)</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cmd<span class="constructor">_err(0, <span class="string">&quot;si:N&lt;=0&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cmd_si是我觉得这几个命令里面相对来说最简单的一个，因为他只要读出命令中的N，转化为数字再传给cpu_exec()即可，cpu_exec(n)是执行程序，其参数n是执行n步，在这里先用strtok函数读入命令格式中的N，如果没有的话就默认执行1步，即cpu_exec(1)，否则的话用atoi转化为数字后再调用。另外这里cmd_err是一个通用的报错函数，定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_err</span><span class="params">(<span class="keyword">int</span> err_type,<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(err_type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Invalid arguments for command &#x27;%s&#x27;\n&quot;</span>,command);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Lack arguments for command &#x27;%s&#x27;\n&quot;</span>,command);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Unknown error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="x命令"><a href="#x命令" class="headerlink" title="x命令"></a>x命令</h4><p>x命令需要用到vaddr_read(addr,n)函数，其中参数addr是内存地址，n是读出的字节数，思路和刚刚一样，先用strtok函数读出命令的2个参数N和exp，这里暂时不考虑复杂的表达式，仅限于16进制数字，所以可以直接使用sscanf(arg2,”%x”,&amp;addr);将第2个参数地址得到，然后再用vaddr_read(addr,4)每次读出4个字节的内存，循环N次即可。</p>
<h4 id="info-r命令"><a href="#info-r命令" class="headerlink" title="info r命令"></a>info r命令</h4><p>因为监视点是PA1.3建立，相关内容都要在PA1.3实现，所以目前info命令仅限于实现info r查看所有寄存器的值，让我们先到x86下面的reg.c文件，在这里实现一个显示所有寄存器的接口void isa_reg_display()，其实也很简单，就只是printf所有寄存器的值而已，打印的格式可以参考如下</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void isa_reg_display() &#123;</span><br><span class="line">    /* PA1<span class="number">.1</span> */</span><br><span class="line">    printf(<span class="string">&quot;eax\t0x%-8x\t%u\n&quot;</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">eax</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">eax</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">&quot;ecx\t0x%-8x\t%u\n&quot;</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">ecx</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">ecx</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">&quot;edx\t0x%-8x\t%u\n&quot;</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">edx</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">edx</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">&quot;ebx\t0x%-8x\t%u\n&quot;</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">ebx</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">ebx</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">&quot;esp\t0x%-8x\t%u\n&quot;</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">esp</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">esp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">&quot;ebp\t0x%-8x\t%u\n&quot;</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">ebp</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">ebp</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">&quot;esi\t0x%-8x\t%u\n&quot;</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">esi</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">esi</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">&quot;edi\t0x%-8x\t%u\n&quot;</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">edi</span>,<span class="meta">cpu</span><span class="number">.</span><span class="built_in">edi</span>)<span class="comment">;</span></span><br><span class="line">    printf(<span class="string">&quot;pc\t0x%-8x\t%u\n&quot;</span>,<span class="meta">cpu</span><span class="number">.</span>pc,<span class="meta">cpu</span><span class="number">.</span>pc)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个接口实现info r就很简单了，只需要判断参数==’r’，然后直接调用reg.c里面的isa_reg_display()即可</p>
<p>至此PA1.1就完成了，PA1.1本身不难，不过要先理解整个代码框架的结构</p>
<h2 id="PA1-2"><a href="#PA1-2" class="headerlink" title="PA1.2"></a>PA1.2</h2><p>如果你做过编译原理实验，这部分其实也不会太难，就是编译原理实验的一小部分。</p>
<p>我们一步一步来，首先对于一个表达式，我们要识别其中的符号token，例如对于表达式</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;4 +3*(2- 1)&quot;</span></span><br></pre></td></tr></table></figure>

<p>的token表达式为</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+</span><br><span class="line">| NUM | &#x27;+&#x27; | NUM | &#x27;*&#x27; | &#x27;<span class="params">(&#x27; | NUM | &#x27;-&#x27; | NUM | &#x27;)</span>&#x27; |</span><br><span class="line">| <span class="string">&quot;4&quot;</span> |     | <span class="string">&quot;3&quot;</span> |     |     | <span class="string">&quot;2&quot;</span> |     | <span class="string">&quot;1&quot;</span> |     |</span><br><span class="line">+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+</span><br></pre></td></tr></table></figure>

<p>在expr.c中首先在enum中添加你想定义的token。我推荐一步到位，PA1.2就把全部的表达式做好。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>意义</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>TK_NOTYPE</td>
<td>空格</td>
<td>0</td>
</tr>
<tr>
<td>TK_NUM</td>
<td>十进制数字</td>
<td>0</td>
</tr>
<tr>
<td>TK_HEX</td>
<td>十六进制数字</td>
<td>0</td>
</tr>
<tr>
<td>TK_REG</td>
<td>寄存器</td>
<td>0</td>
</tr>
<tr>
<td>TK_OR</td>
<td>||</td>
<td>1</td>
</tr>
<tr>
<td>TK_AND</td>
<td>&amp;&amp;</td>
<td>2</td>
</tr>
<tr>
<td>TK_EQ</td>
<td>==</td>
<td>3</td>
</tr>
<tr>
<td>TK_PLUS</td>
<td>+</td>
<td>4</td>
</tr>
<tr>
<td>TK_SUB</td>
<td>-</td>
<td>4</td>
</tr>
<tr>
<td>TK_MUL</td>
<td>*</td>
<td>5</td>
</tr>
<tr>
<td>TK_DIV</td>
<td>/</td>
<td>5</td>
</tr>
<tr>
<td>TK_NEGTIVE</td>
<td>负数</td>
<td>6</td>
</tr>
<tr>
<td>TK_DEREF</td>
<td>引用(例:*$eax)</td>
<td>6</td>
</tr>
<tr>
<td>TK_LBR</td>
<td>(</td>
<td>7</td>
</tr>
<tr>
<td>TK_RBR</td>
<td>）</td>
<td>7</td>
</tr>
</tbody></table>
<p>TK_NEGTIVE和TK_DEREF比较特殊，因为他们的符号分别和TK_SUB和TK_MUL是一样的，需要特殊处理，将他们区分开来，这个是在识别完所有token之后做的，暂时先忽略这2个，之后会讲。</p>
<p>还有一点是这里建议引入优先级，便于后续操作，所以你也需要把原先代码里面对于rule结构体增加一项优先级的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *regex;</span><br><span class="line">  <span class="keyword">int</span> token_type;</span><br><span class="line">  <span class="keyword">int</span> priority; <span class="comment">// add priority</span></span><br><span class="line">&#125; rules[]</span><br></pre></td></tr></table></figure>

<p>当然Token结构体也不要忘了加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">token</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">32</span>];</span><br><span class="line">  <span class="keyword">int</span> priority; <span class="comment">//add priority</span></span><br><span class="line">&#125; Token</span><br></pre></td></tr></table></figure>

<p>填写好rules，正则表达式，符号，优先级。在make_token中会对表达式挨个字符进行分析，从第一条规则开始遍历rules，匹配成功以后，首先对匹配字符串的长度检测，判断是否大于32，如果大于32个字符assert(0)，否则的话，根据匹配的规则，进行进一步操作。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (rules[i].token_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> TK_NOTYPE: break;</span><br><span class="line">            <span class="keyword">case</span> TK_NUM:</span><br><span class="line">            <span class="keyword">case</span> TK_HEX:</span><br><span class="line">            <span class="keyword">case</span> TK_REG:</span><br><span class="line">                strncpy(tokens[nr_token].<span class="built_in">str</span>, substr_start, substr_len);</span><br><span class="line">				        tokens[nr_token].<span class="built_in">str</span>[substr_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">          <span class="keyword">default</span>: </span><br><span class="line">                tokens[nr_token].<span class="built_in">type</span> = rules[i].token_type;</span><br><span class="line">                tokens[nr_token].<span class="built_in">priority</span> = rules[i].<span class="built_in">priority</span>;</span><br><span class="line">				        nr_token++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>对每个规则都要做的是，将其类型和优先级存入tokens数组，而对于数字，额外需要的操作是将其字符串也要保存，为了之后得到具体数值。对于空格就跳过即可。</p>
<p>另外值得一提的是这里可以把tokens数字开大一点，后面测试的时候需要修改。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Token tokens<span class="literal">[<span class="number">65536</span>]</span> <span class="constructor">__attribute__((<span class="params">used</span>)</span>) = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>到这里第一步算是完成了，第一步的工作是利用正则表达式识别给定表达式的token，然后将其顺序的存入tokens数组，保存其类型，优先级，和数字的字符串（相当于是数值）。</p>
<p>接下来在完成手册中提示的eval()函数之前，我们还需要写2个辅助函数——check_parentheses()和get_main_op()。</p>
<p>int check_parentheses(int p, int q)，这里建议将返回类型由bool改为int，因为需要返回3种不同情况。参数p和q分别是tokens数组的起始和结束位置。函数的功能是根据tokens数组从p到q这部分所代表的表达式返回以下3种：</p>
<ul>
<li>返回1    如果表达式是一个由一对左右括号完整包裹的一个有效表达式。</li>
<li>返回0    如果表达式是一个有效的表达式，但是并没有被一对左右括号包裹。</li>
<li>返回-1   如果表达式不是一个有效的表达式。  </li>
</ul>
<p>另外值得一提的是这里需要考虑一种特殊情况，就是虽然是一个有效的表达式，同时左右分别是左括号和号，但是这两个括号并不是一对，例如<br>$$<br>(4+3)*(4+4)<br>$$<br>对于这样的表达式，应该返回0而不是1。这里是对括号的匹配性进行检测，其他方面的细节可以不用管。从p位置开始到q位置，用n进行记录，如果遇到左括号n+1如果遇到右括号n-1,在循环过程中，只要n变为负数可以理解退出返回-1，如果循环结束n不为0也返回-1。剩下的就不用多说了，反正直接看代码也就懂了。</p>
<p>int get_main_op(int p, int q)，参数的意义同上，函数的作用是从p位置开始扫描到q位置，找到一个优先级最低的运算符号且该运算符号不能在括号包裹的表达式里面，同优先级的情况下取最右边的运算符号作为主符号，最后将主符号的位置返回。因为tokens里面有存各个符号的优先级，所以这里就可以非常简单的实现。判断括号内的方法可以参考上面的用n记录的方法，只有当n等于0的时候说明不在括号内，这时候再进行对运算符号优先级的比较。</p>
<p>两个辅助函数写完的情况下，对于PA1.2来说可以去实现关键的eval()函数了，但是我一开始就说过了要一步到位，所以先不急着去写eval()函数，我们需要先到expr()函数里面完成一些前置工作。</p>
<p>uint32_t expr(char <em>e, bool <em>success)，对字符串e进行表达式求值，如果求值成功\</em>success==true，失败\</em>success==false，返回求值的结果。expr()函数首先调用make_token完成我前面说的第一步，将表达式进行符号解析存入tokens数组中，之后就是我们需要添加的代码，在已经完成第一步解析的基础上，需要对*和-进行进一步的分析，识别出TK_DEREF和TK_NEGTIVE。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;nr_token; <span class="built_in">i</span>++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokens[<span class="built_in">i</span>].<span class="built_in">type</span> == TK_MUL &amp;&amp; (<span class="built_in">i</span>==<span class="number">0</span> || (tokens[<span class="built_in">i</span><span class="number">-1</span>].priority!=<span class="number">0</span> &amp;&amp; tokens[<span class="built_in">i</span><span class="number">-1</span>].<span class="built_in">type</span>!=TK_RBR)))&#123;</span><br><span class="line">       tokens[<span class="built_in">i</span>].<span class="built_in">type</span> = TK_DEREF;</span><br><span class="line">       tokens[<span class="built_in">i</span>].priority = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tokens[<span class="built_in">i</span>].<span class="built_in">type</span> == TK_SUB &amp;&amp; (<span class="built_in">i</span>==<span class="number">0</span> || (tokens[<span class="built_in">i</span><span class="number">-1</span>].priority!=<span class="number">0</span> &amp;&amp; tokens[<span class="built_in">i</span><span class="number">-1</span>].<span class="built_in">type</span>!=TK_RBR)))&#123;</span><br><span class="line">       tokens[<span class="built_in">i</span>].<span class="built_in">type</span> = TK_NEGTIVE;</span><br><span class="line">       tokens[<span class="built_in">i</span>].priority = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>对tokens数组扫描，对于其中的*也就是type是TK_MUL，如果位置在第一个，或者他的前一个符号不是数字(可以用优先级简单的判断，因为数字的优先级是0)，且不是右括号，那么将这个TK_MUL重新解释为TK_DEREF，优先级为6。同理对TK_NEGTIVE也进行类似的判断识别。现在所有符号都正确的识别了，可以使用eval对其进行求值了。</p>
<p>uint32_t eval(int p, int q, bool *success)，求出tokens数组从p到q所代表的表达式的值，如果求值成功*success==true，失败*success==false，返回求值的结果。eval的大致框架和思路在手册里面有写，这里就不赘述了。eval流程图如下：</p>
<pre class="mermaid">graph TD
A(开始) --> B{p与q的关系}
    B --> |p > q| err[*success=false<br>return -1]
    B --> |p == q| E["根据tokens[p].type<br>(10进制,16进制或寄存器)求值"]
    B --> |p < q| F["ret=check_parenthese(p,q)"]
    F --> G{ret返回值}
    G --> |ret == -1| err
    G --> |ret == 1| ret1["return eval(p+1,q-1,success)"]
    G --> |ret == 0| ret0["pos=get_main_op(p,q)"]
    ret0 --> |pos == -1| err
    ret0 --> |pos != -1| eval["val1 = eval(p, pos - 1, success);<br>
    val2 = eval(pos + 1, q, success);<br>
    根据tokens[pos].type进行运算"]</pre>

<p>有了流程图，大致的代码思路应该已经有了，再来说下其中的细节。</p>
<p>首先是p==q的时候，这时候说明这个表达式没有运算符号，其本身是一个数值或者寄存器，如果是TK_NUM或者TK_HEX，那么直接strtoul(tokens[p].str, NULL, 0)就可以把字符串转化为数值，如果是TK_REG，那么需要使用isa_reg_str2val(tokens[p].str + 1, success)获取寄存器的值。这个isa_reg_str2val()函数在之前的reg.c中，需要你去实现它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">isa_reg_str2val</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">bool</span> *success)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* PA1.2 */</span></span><br><span class="line">  *success = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, <span class="string">&quot;pc&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(s, <span class="string">&quot;eip&quot;</span>) == <span class="number">0</span>)  <span class="keyword">return</span> cpu.pc;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = R_EAX; i &lt;= R_EDI; ++ i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, regsl[i]) == <span class="number">0</span>) <span class="keyword">return</span> reg_l(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = R_AX; i &lt;= R_DI; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, regsw[i]) == <span class="number">0</span>) <span class="keyword">return</span> reg_w(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = R_AL; i &lt;= R_BH; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, regsb[i]) == <span class="number">0</span>) <span class="keyword">return</span> reg_b(i);</span><br><span class="line">	&#125;</span><br><span class="line">	*success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有的寄存器，比对传入参数s和寄存器的名字，找到s对应的寄存器然后返回寄存器中的值。</p>
<p>第2个细节是根据tokens[pos].type进行运算，pos的位置指向主运算符，如果这个主运算符是除法，那么应该注意一下对于除以0行为的处理，也就是判断val2==0?，简单一点直接assert(0)也可以，也可以输出一段提示后，*success=false。其他的运算符都比较简单，注意TK_DEREF是val=vaddr_read(val2,4)以及TK_NEGTIVE是val=-val2即可。(这两个运算符并没有用到val1)</p>
<p>其实到这里PA1.2已经完成了，但是手册里面要求你还需要对你的表达式写一个程序随机测验，所以你还需要完成gen-expr.c。测试原理在手册里面已经讲了，而我们在这个文件中需要自己补充的仅仅是随机生成一个表达式的部分，我直接贴上我的代码再讲比较方便，如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PA1.2 */</span></span><br><span class="line">#define N_TOKEN <span class="number">10</span></span><br><span class="line">static char buf[<span class="number">5000</span>];</span><br><span class="line"></span><br><span class="line">static <span class="built_in">uint</span>32_t choose(<span class="built_in">uint</span>32_t n)&#123;</span><br><span class="line">	<span class="keyword">return</span> rand() % n;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline <span class="built_in">void</span> gen_rand_expr(<span class="built_in">int</span> l,<span class="built_in">int</span> r) &#123;</span><br><span class="line">  <span class="built_in">int</span> op;</span><br><span class="line">  <span class="keyword">if</span>(l==r)buf[l]=choose(<span class="number">10</span>)+<span class="number">48</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(r==l+<span class="number">1</span>)&#123;</span><br><span class="line">	  buf[l]=choose(<span class="number">9</span>)+<span class="number">1</span>+<span class="number">48</span>;</span><br><span class="line">	  buf[r]=choose(<span class="number">10</span>)+<span class="number">48</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">	  <span class="keyword">switch</span>(choose(<span class="number">1</span>))&#123;</span><br><span class="line">		  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              op=l+<span class="number">1</span>+choose(r-l<span class="number">-1</span>);</span><br><span class="line">			  gen_rand_expr(l,op<span class="number">-1</span>);</span><br><span class="line">              static char ops[] = <span class="string">&quot;+-*/&quot;</span>;</span><br><span class="line">			  buf[op]=ops[choose(<span class="number">4</span>)];</span><br><span class="line">			  gen_rand_expr(op+<span class="number">1</span>,r);</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">		  <span class="keyword">default</span>:</span><br><span class="line">			  buf[l]=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">			  buf[r]=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">			  gen_rand_expr(l+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line">			  <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>N_TOKEN是最后表达式中token的数目，uint32_t choose(uint32_t n)随机生成一个0~n-1的数。</p>
<p>void gen_rand_expr(int l,int r)在字符串位置l和r之间随机生成表达式的token，如果r==l生成一个1位数字，如果r==l+1生成一个两位数，此外，从下面2种情况中生成一种：</p>
<ul>
<li>在l+1到r-1中随机选取一个位置作为主符号的位置op，并从加减乘除当中随机选择一个符号。递归调用gen_rand_expr(l,op-1)和gen_rand_expr(op+1,r)生成两边的表达式。</li>
<li>在l和r的位置生成一对括号，递归调用gen_rand_expr(l+1,r-1)，生成被一对括号包裹的表达式。  </li>
</ul>
<p>最后修改下面的main函数中对gen_rand_expr()的调用，加上参数，就完成了。别忘了修改buf和code_buf数组的大小，至少保证buf的长度小于code_buf。</p>
<p>完成了以后记得去ui.c中加入p命令，方式同PA1.1。这里只要调用expr即可，我附上我的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_p</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* extract the first argument */</span></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* no argument given */</span></span><br><span class="line">        cmd_err(<span class="number">0</span>, <span class="string">&quot;p: no argument given\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> result = expr(args,&amp;success);</span><br><span class="line">        <span class="keyword">if</span>(success) <span class="built_in">printf</span>(<span class="string">&quot;0x%x(%d)\n&quot;</span>,result,result);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Invalid expr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="PA1-3"><a href="#PA1-3" class="headerlink" title="PA1.3"></a>PA1.3</h2><p>PA1.3要求实现监视点的创建和删除。首先我们先到watchpoint.h查看WP结构体，可以看到原始定义只有表示WP的序号NO以及作为链表结点必须的next指针，这显然是不够的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> NO;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more members if necessary */</span></span><br><span class="line">  <span class="comment">/* PA1.3*/</span></span><br><span class="line">  <span class="keyword">char</span> expr[<span class="number">128</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> value;</span><br><span class="line">  <span class="keyword">int</span> hit;</span><br><span class="line">&#125; WP;</span><br></pre></td></tr></table></figure>

<p>需要添加的成员有3个：</p>
<ul>
<li>char expr[128]：用于记录创建的监视点的表达式，例如$eax</li>
<li>uint32_t value：求出当前的表达式的值，表达式是不变的，但是其值会变，因为寄存器值会变，当表达式值改变的时候就要暂停程序，算是命中。</li>
<li>int hit：记录该监视点的命中次数。</li>
</ul>
<p>监视点采用链表池的结构管理，所有监视点保存在wp_pool数组中，而正在使用的监视点由head指针串起的一个链表，空闲的监视点链表由free_指向。</p>
<p>剩下的其实都是基本的链表操作，例如创建一个监视点，就是将free_指向的首结点从空闲链表摘除，加进head指向的链表。并设置其expr,hit,计算expr。而删除一个监视点，就是遍历head指向的链表，找到一个结点其序号NO与给定的相符，将其从head链表中删除，移到free_链表。</p>
<p>除了添加和删除，还需要展示监视点的内容，这里是继续了PA1.1的info w命令，函数自己命名，展示格式可以参考如下代码：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void display_wp()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == NULL) &#123;</span><br><span class="line">		printf(<span class="string">&quot;There is no watchpoint!\n&quot;</span>);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(<span class="string">&quot;Num     What     Value\n&quot;</span>);</span><br><span class="line">	WP *p = head;</span><br><span class="line">	<span class="keyword">while</span>(p != NULL) &#123;</span><br><span class="line">		<span class="function"><span class="title">printf</span>(&quot;%-8d%-9s%u(%#x)\n&quot;, p -&gt;</span> NO, <span class="function"><span class="title">p</span> -&gt;</span> <span class="function"><span class="title">expr</span>, p-&gt;</span><span class="function"><span class="title">value</span>, p-&gt;</span>value);</span><br><span class="line">		<span class="function"><span class="title">if</span>(p -&gt;</span> <span class="function"><span class="title">hit</span> &gt; 0) printf(&quot;\tbreakpoint already hit %d <span class="built_in">time</span>\n&quot;, p-&gt;</span>hit);</span><br><span class="line">		<span class="function"><span class="title">p</span> = p -&gt;</span> next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，你还需要一个功能，监视点的作用是当监视的表达式的值变化时，暂停程序。我们先实现bool check_wp()，它的功能是检查所有监视点，看是否有监视点的表达式值发生了变化。方法很简单，遍历head指向的所有正在使用的监视点，然后重新计算其expr的值，与之前保存在value当中的值比对，如果不同的话，说明表达式的值发生了变化。然后需要暂停程序，这里手册给了提示，只要把nemu_state.state赋值为NEMU_STOP即可。在cpu_exec.c的cpu_exec()函数，我们会亲切的发现已经有注释写好了你需要添加的位置，而你只需要在这行注释下面添加这么几行代码即可。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* TODO:<span class="built_in"> check </span>watchpoints here. */</span><br><span class="line">    /* PA1.3*/</span><br><span class="line">  bool changed = check_wp();</span><br><span class="line">	if(changed)&#123;</span><br><span class="line">		nemu_state.state = NEMU_STOP;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>最后别忘了回到ui.c完善你所有的命令，整个PA1就算完成了，其实还算简单，真正痛苦的地狱PA2才正要开始。</p>
<h1 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h1><p>该说不愧是1星难度吗，确实挺难的。</p>
<h2 id="PA2-1"><a href="#PA2-1" class="headerlink" title="PA2.1"></a>PA2.1</h2><p>我觉得有必要先整理一下结构体定义（不过你可以先暂时跳过这部分，直接看完追踪mov指令执行过程会更加清晰）：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *pc)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_EHelper(name) void concat(exec_, name) (vaddr_t *pc)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*EHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  DHelper decode;</span><br><span class="line">  EHelper execute;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">&#125; OpcodeEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> reg;</span><br><span class="line">    <span class="keyword">rtlreg_t</span> addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> imm;</span><br><span class="line">    <span class="keyword">int32_t</span> simm;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">rtlreg_t</span> val;</span><br><span class="line">  <span class="keyword">char</span> str[OP_STR_SIZE];</span><br><span class="line">&#125; Operand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> opcode;</span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="built_in">width</span>;</span><br><span class="line">  <span class="keyword">vaddr_t</span> seq_pc;  <span class="comment">// sequential pc</span></span><br><span class="line">  <span class="keyword">bool</span> is_jmp;</span><br><span class="line">  <span class="keyword">vaddr_t</span> jmp_pc;</span><br><span class="line">  Operand src, dest, src2;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ISADecodeInfo</span> <span class="title">isa</span>;</span></span><br><span class="line">&#125; DecodeInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span>  simm   : <span class="number">16</span>;</span><br><span class="line"><span class="comment">//  uint32_t rt     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t rs     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t opcode :  6;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> imm    : <span class="number">16</span>;</span><br><span class="line"><span class="comment">//  uint32_t rt     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t rs     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t opcode :  6;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> jmp_target : <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> opcode     :  <span class="number">6</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> func   : <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> sa     : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> rd     : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> rt     : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> rs     : <span class="number">5</span>;</span><br><span class="line"><span class="comment">//  uint32_t opcode : 6;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">uint32_t</span> val;</span><br><span class="line">&#125; Instr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ISADecodeInfo</span> &#123;</span></span><br><span class="line">  Instr instr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">static inline uint32_t instr_fetch(vaddr_t *pc, int len) &#123;</span><br><span class="line">  uint32_t instr = vaddr_read(*pc, len);</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">  uint8_t *p_instr = (void *)&amp;instr;</span><br><span class="line">  int i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    extern char log_bytebuf[];</span><br><span class="line">    strcatf(log_bytebuf, <span class="string">&quot;%02x &quot;</span>, p_instr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line">  (*pc) += len;</span><br><span class="line">  return instr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Instruction Decode and EXecute */</span></span><br><span class="line">static inline void idex(vaddr_t *pc, OpcodeEntry *e) &#123;</span><br><span class="line">  <span class="function"><span class="title">if</span> (e-&gt;</span>decode)</span><br><span class="line">    <span class="function"><span class="title">e</span>-&gt;</span>decode(pc);</span><br><span class="line">  <span class="function"><span class="title">e</span>-&gt;</span>execute(pc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make_DHelper(mov_I2r) &#123;</span><br><span class="line">  decode_op_r(pc, id_dest, <span class="literal">false</span>);</span><br><span class="line">  decode_op_I(pc, id_src, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This helper function is use to decode register encoded in the opcode. */</span></span><br><span class="line"><span class="comment">/* XX: AL, AH, BL, BH, CL, CH, DL, DH</span></span><br><span class="line"><span class="comment"> * eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static inline make_DopHelper(r) &#123;</span><br><span class="line">  <span class="function"><span class="title">op</span>-&gt;</span>type = OP_TYPE_REG;</span><br><span class="line">  <span class="function"><span class="title">op</span>-&gt;</span>reg = decinfo.opcode &amp; <span class="number">0</span>x7;</span><br><span class="line">  <span class="keyword">if</span> (load_val) &#123;</span><br><span class="line">    <span class="function"><span class="title">rtl_lr</span>(&amp;op-&gt;</span><span class="function"><span class="title">val</span>, op-&gt;</span><span class="function"><span class="title">reg</span>, op-&gt;</span>width);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print_Dop</span>(op-&gt;</span><span class="function"><span class="title">str</span>, OP_STR_SIZE, &quot;%%%s&quot;, reg_name(op-&gt;</span><span class="function"><span class="title">reg</span>, op-&gt;</span>width));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Refer to Appendix A in i386 manual for the explanations of these abbreviations */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ib, Iv */</span></span><br><span class="line">static inline make_DopHelper(I) &#123;</span><br><span class="line">  <span class="comment">/* pc here is pointing to the immediate */</span></span><br><span class="line">  <span class="function"><span class="title">op</span>-&gt;</span>type = OP_TYPE_IMM;</span><br><span class="line">  <span class="function"><span class="title">op</span>-&gt;</span><span class="function"><span class="title">imm</span> = instr_fetch(pc, op-&gt;</span>width);</span><br><span class="line">  <span class="function"><span class="title">rtl_li</span>(&amp;op-&gt;</span><span class="function"><span class="title">val</span>, op-&gt;</span>imm);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print_Dop</span>(op-&gt;</span><span class="function"><span class="title">str</span>, OP_STR_SIZE, &quot;$0x%x&quot;, op-&gt;</span>imm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们以追踪mov指令执行过程为例讲解整个流程。</p>
<p>从cpu.c开始首先执行exec_once()函数</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vaddr_t exec<span class="constructor">_once(<span class="params">void</span>)</span> &#123;</span><br><span class="line">  decinfo.seq_pc = cpu.pc;</span><br><span class="line">  isa<span class="constructor">_exec(&amp;<span class="params">decinfo</span>.<span class="params">seq_pc</span>)</span>;</span><br><span class="line">  update<span class="constructor">_pc()</span>;</span><br><span class="line"></span><br><span class="line">  return decinfo.seq_pc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将cpu.pc的值保存在了decinfo.seq_pc中，然后将该值的索引传进isa_exec()中，最后调用update_pc()更新pc值。关键的译码和执行显然在isa_exec()中，这个函数也有屏蔽isa差别的功能，来到isa/x86/exec/exec.c中，这里有isa_exec()定义：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void isa<span class="constructor">_exec(<span class="params">vaddr_t</span> <span class="operator">*</span><span class="params">pc</span>)</span> &#123;</span><br><span class="line">  uint32_t opcode = instr<span class="constructor">_fetch(<span class="params">pc</span>, 1)</span>;</span><br><span class="line">  decinfo.opcode = opcode;</span><br><span class="line">  set<span class="constructor">_width(<span class="params">opcode_table</span>[<span class="params">opcode</span>].<span class="params">width</span>)</span>;</span><br><span class="line">  idex(pc, &amp;opcode_table<span class="literal">[<span class="identifier">opcode</span>]</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>instr_fetch()的定义在include/cpu/exec.h中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> instr = vaddr_read(*pc, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *p_instr = (<span class="keyword">void</span> *)&amp;instr;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> log_bytebuf[];</span><br><span class="line">    strcatf(log_bytebuf, <span class="string">&quot;%02x &quot;</span>, p_instr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  (*pc) += len;</span><br><span class="line">  <span class="keyword">return</span> instr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能很简单，就是读取pc所指内存len个字节返回，然后pc的值增加len长度。</p>
<p>回到isa_exec()，很明显先是从pc所指地方读取一个字节作为opcode并且保存在decinfo.opcode中，如果是mov指令，以下面这条mov指令为例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">100000</span>:    b<span class="number">8</span> <span class="number">34</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span>        mov    $<span class="number">0</span>x<span class="number">1234</span>,%eax</span><br></pre></td></tr></table></figure>

<p>那么这个opcode一定是0xb8，接着我们用opcode作为索引查表opcode_table</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0xb8 */</span>	<span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>, <span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>, <span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>, <span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>,</span><br></pre></td></tr></table></figure>

<p>也就是IDEX(mov_I2r,mov)，我们先来看看opcode_table的定义。他是一个OpcodeEntry类型的数组，那么OpcodeEntry又是什么呢，他的结构体定义在include/cpu/exec.h中，如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  DHelper decode;</span><br><span class="line">  EHelper execute;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">&#125; OpcodeEntry;</span><br></pre></td></tr></table></figure>

<p>在这个文件的上面可以找到EHelper的定义：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void <span class="comment">(*EHelper) (vaddr_t *)</span>;</span><br></pre></td></tr></table></figure>

<p>DHelper的定义在decode.h中可以找到，是类似的。总之就是说这个结构体有2个函数指针和一个int类型变量记录宽度，这两个函数指针分别执行译码函数和执行函数的入口。</p>
<p>在exec.h中，我们还可以看到IDEX宏的定义：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="constructor">IDEXW(<span class="params">id</span>, <span class="params">ex</span>, <span class="params">w</span>)</span>   &#123;concat(decode_, id), concat(exec_, ex), w&#125;</span><br><span class="line">#define <span class="constructor">IDEX(<span class="params">id</span>, <span class="params">ex</span>)</span>       <span class="constructor">IDEXW(<span class="params">id</span>, <span class="params">ex</span>, 0)</span></span><br><span class="line">#define <span class="constructor">EXW(<span class="params">ex</span>, <span class="params">w</span>)</span>         &#123;NULL, concat(exec_, ex), w&#125;</span><br><span class="line">#define <span class="constructor">EX(<span class="params">ex</span>)</span>             <span class="constructor">EXW(<span class="params">ex</span>, 0)</span></span><br><span class="line">#define EMPTY              <span class="constructor">EX(<span class="params">inv</span>)</span></span><br></pre></td></tr></table></figure>

<p>IDEX是宽度为0的IDEXW，而IDEXW里面这个concat同样是个宏，这里就不再去找了，直接解释他的作用，就是将后面2个字符串拼接起来，我们回到IDEX(mov_I2r, mov)这个具体实例，通过这层层宏，最终应该被翻译成</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="built_in">  decode_mov_I2r,</span></span><br><span class="line"><span class="built_in">  exec_mov,</span></span><br><span class="line">  <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再回到isa_exec()，现在该执行set_width(opcode_table[opcode].width);这行了，不过根据上面分析，这里宽度的值为0，也就是set_width(0);那么set_width会怎么处理，我们需要看下set_width()函数的定义（exec.c文件）：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_width</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">width</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">width</span> = decinfo.isa.is_operand_size_16 ? <span class="number">2</span> : <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  decinfo.src.<span class="built_in">width</span> = decinfo.dest.<span class="built_in">width</span> = decinfo.src2.<span class="built_in">width</span> = <span class="built_in">width</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为width==0，而decinfo.isa.is_operand_size_16默认值是false，所以操作数的位宽都被设置为了4。</p>
<p>继续执行下一行idex(pc, &amp;opcode_table[opcode]);我们需要看一下idex()函数的定义(exec.h)：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Instruction Decode and EXecute */</span></span><br><span class="line">static inline void idex(vaddr_t *pc, OpcodeEntry *e) &#123;</span><br><span class="line">  <span class="function"><span class="title">if</span> (e-&gt;</span>decode)</span><br><span class="line">    <span class="function"><span class="title">e</span>-&gt;</span>decode(pc);</span><br><span class="line">  <span class="function"><span class="title">e</span>-&gt;</span>execute(pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面也说了OpcodeEntry里面有译码函数指针和执行函数指针，这里检测译码函数指针是否为NULL，如果为NULL，就直接进入执行函数，否则以pc作为参数进入译码函数，作为例子的译码函数是decode_mov_I2r()，不过这个函数也是宏定义的，我们先得找到。</p>
<p>我们来到isa/x86/decode.c文件，这里有很多用宏定义构成的译码函数，我们来看看是怎么构成的。</p>
<p>从结果说起吧，第157行make_DHelper(mov_I2r)就是我们要找的decode_mov_I2r().</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_DHelper(<span class="params">mov_I2r</span>)</span> &#123;</span><br><span class="line">  decode<span class="constructor">_op_r(<span class="params">pc</span>, <span class="params">id_dest</span>, <span class="params">false</span>)</span>;</span><br><span class="line">  decode<span class="constructor">_op_I(<span class="params">pc</span>, <span class="params">id_src</span>, <span class="params">true</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先去include/cpu/decode.h里面可以看到make_DHelper(name)宏定义：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define make_DHelper(<span class="name">name</span>) void concat(<span class="name">decode_</span>, name) (<span class="name">vaddr_t</span> *pc)</span><br></pre></td></tr></table></figure>

<p>因此按照这个宏定义，将make_DHelper(mov_I2r)翻译过来就是</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void decode<span class="constructor">_mov_I2r(<span class="params">vaddr_t</span> <span class="operator">*</span><span class="params">pc</span>)</span></span><br></pre></td></tr></table></figure>

<p>没错，正是我们所要找的函数，这个函数里面调用了2个decode_op_前缀的函数，在decode.c中我们可以在开头第4行看到这样一行宏定义：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define make_DopHelper(<span class="name">name</span>) void concat(<span class="name">decode_op_</span>, name) (<span class="name">vaddr_t</span> *pc, Operand *op, bool load_val)</span><br></pre></td></tr></table></figure>

<p>所以，类似的，我们要找make_DopHelper(r)和make_DopHelper(I)，分别在59行和第9行：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static inline make<span class="constructor">_DopHelper(<span class="params">r</span>)</span> &#123;</span><br><span class="line">  op-&gt;<span class="keyword">type</span> = OP_TYPE_REG;</span><br><span class="line">  op-&gt;reg = decinfo.opcode &amp; <span class="number">0x7</span>;</span><br><span class="line">  <span class="keyword">if</span> (load_val) &#123;</span><br><span class="line">    rtl<span class="constructor">_lr(&amp;<span class="params">op</span>-&gt;<span class="params">val</span>, <span class="params">op</span>-&gt;<span class="params">reg</span>, <span class="params">op</span>-&gt;<span class="params">width</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print<span class="constructor">_Dop(<span class="params">op</span>-&gt;<span class="params">str</span>, OP_STR_SIZE, <span class="string">&quot;%%%s&quot;</span>, <span class="params">reg_name</span>(<span class="params">op</span>-&gt;<span class="params">reg</span>, <span class="params">op</span>-&gt;<span class="params">width</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Refer to Appendix A in i386 manual for the explanations of these abbreviations */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ib, Iv */</span></span><br><span class="line">static inline make<span class="constructor">_DopHelper(I)</span> &#123;</span><br><span class="line">  <span class="comment">/* pc here is pointing to the immediate */</span></span><br><span class="line">  op-&gt;<span class="keyword">type</span> = OP_TYPE_IMM;</span><br><span class="line">  op-&gt;imm = instr<span class="constructor">_fetch(<span class="params">pc</span>, <span class="params">op</span>-&gt;<span class="params">width</span>)</span>;</span><br><span class="line">  rtl<span class="constructor">_li(&amp;<span class="params">op</span>-&gt;<span class="params">val</span>, <span class="params">op</span>-&gt;<span class="params">imm</span>)</span>;</span><br><span class="line"></span><br><span class="line">  print<span class="constructor">_Dop(<span class="params">op</span>-&gt;<span class="params">str</span>, OP_STR_SIZE, <span class="string">&quot;$0x%x&quot;</span>, <span class="params">op</span>-&gt;<span class="params">imm</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先将make_DopHelper(r)翻译一下：</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline decode_op_r (vaddr_t *pc, <span class="type">Operand</span> *<span class="keyword">op</span>, <span class="built_in">bool</span> load_val) &#123;</span><br><span class="line">  <span class="keyword">op</span>-&gt;<span class="keyword">type</span> = <span class="type">OP_TYPE_REG</span>;</span><br><span class="line">  <span class="keyword">op</span>-&gt;reg = decinfo.opcode &amp; <span class="number">0x7</span>;</span><br><span class="line">  <span class="keyword">if</span> (load_val) &#123;</span><br><span class="line">    rtl_lr(&amp;<span class="keyword">op</span>-&gt;<span class="keyword">val</span>, <span class="keyword">op</span>-&gt;reg, <span class="keyword">op</span>-&gt;width);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print_Dop(<span class="keyword">op</span>-&gt;str, <span class="type">OP_STR_SIZE</span>, <span class="string">&quot;%%%s&quot;</span>, reg_name(<span class="keyword">op</span>-&gt;reg, <span class="keyword">op</span>-&gt;width));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就很明显了，这个函数将op的类型赋值为OP_TYPE_REG，也就是标注为寄存器，寄存器的编号是opcode&amp;0x7，我们例子中opcode为0xb8，所以寄存器编号是0，而0号寄存器就是EAX，而load_val为false所以跳过，不过我认为这里还是先说明一下rtl函数，它们在include/isa/rtl.h文件和include/rtl目录中，目前只实现了几个，后面很多需要我们来补充。手册里面说过了，在NEMU中, 我们使用RTL（寄存器传输语言）来描述简单的操作.例如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline void rtl<span class="constructor">_lr(<span class="params">rtlreg_t</span><span class="operator">*</span> <span class="params">dest</span>, <span class="params">int</span> <span class="params">r</span>, <span class="params">int</span> <span class="params">width</span>)</span> &#123;</span><br><span class="line">  switch (width) &#123;</span><br><span class="line">    case <span class="number">4</span>: rtl<span class="constructor">_mv(<span class="params">dest</span>, &amp;<span class="params">reg_l</span>(<span class="params">r</span>)</span>); return;</span><br><span class="line">    case <span class="number">1</span>: rtl<span class="constructor">_host_lm(<span class="params">dest</span>, &amp;<span class="params">reg_b</span>(<span class="params">r</span>)</span>, <span class="number">1</span>); return;</span><br><span class="line">    case <span class="number">2</span>: rtl<span class="constructor">_host_lm(<span class="params">dest</span>, &amp;<span class="params">reg_w</span>(<span class="params">r</span>)</span>, <span class="number">2</span>); return;</span><br><span class="line">    default: <span class="keyword">assert</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在rtl-wrapper.h里面有相关宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL_PREFIX interpret</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rtl_mv        concat(RTL_PREFIX, _rtl_mv      )</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在include/rtl/rtl.h中有具体的函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">interpret_rtl_mv</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1)</span> </span>&#123;</span><br><span class="line">  *dest = *src1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我想这个先暂时讲到这里，让我们回到decode_mov_I2r()函数，我们仅仅分析了它调用的一个函数，不过其实第2个也类似，这个函数从名字上也可以看出它的功能是把立即数（Imm）送入寄存器(reg)，因此它先调用了decode_op_r(pc, id_dest, false)这里id_dest也是一个宏，翻译过来其实就是&amp;decinfo.dest，也就是说这个函数作用是把目的操作数的类型确定为了寄存器，并记录了寄存器编号，为后续做好准备。那么decode_op_r(pc, id_src, true)函数的结果也显而易见了，将源操作数的类型设置为立即数，同时设置好立即数的值，从它的代码中我们可以看到instr_fetch(pc, op-&gt;width);也就是说从opcode字节后面又取了4个字节作为立即数的值。然后使用rtl_li(&amp;op-&gt;val, op-&gt;imm)将值保存进了op-&gt;val中。整个译码过程就算结束了。</p>
<p>接下来是执行过程，先找执行函数也就是exec_mov()函数，与前面类似，也就是说我们要找make_EHelper(mov)，这里看下x86/exec目录下，根据指令的类型不同分类出了arith.c存放运算类执行函数，control.c存放控制类执行函数,data-mov.c存放数据传输执行函数。所以我们来到data-mov.c文件中。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_EHelper(<span class="params">mov</span>)</span> &#123;</span><br><span class="line">  operand<span class="constructor">_write(<span class="params">id_dest</span>, &amp;<span class="params">id_src</span>-&gt;<span class="params">val</span>)</span>;</span><br><span class="line">  print<span class="constructor">_asm_template2(<span class="params">mov</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是先把宏都翻译一下，包括id_dest</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void exec<span class="constructor">_mov(<span class="params">vaddr_t</span> <span class="operator">*</span><span class="params">pc</span>)</span>&#123;</span><br><span class="line">  operand<span class="constructor">_write(&amp;<span class="params">decinfo</span>.<span class="params">dest</span>, &amp;<span class="params">id_src</span>-&gt;<span class="params">val</span>)</span>;</span><br><span class="line">  print<span class="constructor">_asm(#<span class="params">mov</span> <span class="string">&quot;%c %s,%s&quot;</span>, <span class="params">suffix_char</span>((&amp;<span class="params">decinfo</span>.<span class="params">dest</span>)</span>-&gt;width), id_src-&gt;str, id_dest-&gt;str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很显然，operand_write(&amp;decinfo.dest, &amp;id_src-&gt;val)的功能是把源操作数的值，写入目的操作数中。我们来具体看下operand_write()定义（decode.c）：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void operand<span class="constructor">_write(Operand <span class="operator">*</span><span class="params">op</span>, <span class="params">rtlreg_t</span><span class="operator">*</span> <span class="params">src</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (op-&gt;<span class="keyword">type</span><span class="operator"> == </span>OP_TYPE_REG) &#123; rtl<span class="constructor">_sr(<span class="params">op</span>-&gt;<span class="params">reg</span>, <span class="params">src</span>, <span class="params">op</span>-&gt;<span class="params">width</span>)</span>; &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (op-&gt;<span class="keyword">type</span><span class="operator"> == </span>OP_TYPE_MEM) &#123; rtl<span class="constructor">_sm(&amp;<span class="params">op</span>-&gt;<span class="params">addr</span>, <span class="params">src</span>, <span class="params">op</span>-&gt;<span class="params">width</span>)</span>; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="keyword">assert</span>(<span class="number">0</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据目的操作数的类型不同，调用rtl_sr()将源操作数的值送入寄存器(reg)或者调用rtl_sm()送入内存(mem)。</p>
<p>执行函数执行完以后不要完了exec_once最后还调用了update_pc()，让我们也看下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update_pc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (decinfo.is_jmp) &#123; decinfo.is_jmp = <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; cpu.pc = decinfo.seq_pc; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为mov指令，自然是没有跳转的，再读完了一个字节的opcode和4个字节的立即数后decinfo.seq_pc自然已经来到了下一条指令的opcode位置，将其赋值给cpu.pc完成pc更新的工作就算真正的执行完了一条指令。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/02/hello%20world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#PA1"><span class="nav-number">1.</span> <span class="nav-text">PA1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-0"><span class="nav-number">1.1.</span> <span class="nav-text">PA1.0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-1"><span class="nav-number">1.2.</span> <span class="nav-text">PA1.1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#si%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">si命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">x命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#info-r%E5%91%BD%E4%BB%A4"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">info r命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-2"><span class="nav-number">1.3.</span> <span class="nav-text">PA1.2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PA1-3"><span class="nav-number">1.4.</span> <span class="nav-text">PA1.3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PA2"><span class="nav-number">2.</span> <span class="nav-text">PA2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PA2-1"><span class="nav-number">2.1.</span> <span class="nav-text">PA2.1</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuirito</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuirito</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>


  <script src='https://unpkg.com/mermaid@/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
