{"meta":{"title":"yuirito's blog","subtitle":"","description":"","author":"yuirito","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-12-24T01:39:08.000Z","updated":"2021-12-24T01:46:06.658Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-12-24T01:39:46.000Z","updated":"2021-12-24T01:46:26.811Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-12-24T01:39:51.000Z","updated":"2021-12-24T01:42:51.834Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"论文阅读笔记-Domain Generalization using Causal Matching","slug":"论文阅读笔记-Domain-Generalization-using-Causal-Matching","date":"2021-12-24T06:39:38.000Z","updated":"2022-01-20T09:15:58.486Z","comments":true,"path":"2021/12/24/论文阅读笔记-Domain-Generalization-using-Causal-Matching/","link":"","permalink":"http://example.com/2021/12/24/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-Domain-Generalization-using-Causal-Matching/","excerpt":"","text":"1 动机 领域泛化是指在对多个数据分布进行训练后，学习到一个泛化模型，该模型可以应用到不可见数据上的分布。例如在一个区域的医院上训练的模型可以应用到另一个区域，图像分类器可以应用到稍微旋转的图像上等。传统的目标是学习到不同领域上的稳定特征(\"stable\" features)，流行的方法是学习独立于领域的表示，称为类别条件(conditional on class)。但是这篇文章的作者指出这样是不够的，当待学习的稳定特征在不同领域的分布不同时，类别条件目标不足以学习稳定特征（只有当稳定特征在不同领域的分布相同时，它们才是最优的）。为此，作者在之前的单域工作上使用因果结果模型进行推广表示稳定特征的类内变化。该模型假设每个输入都是由稳定(因果)和领域相关(非因果) 混合构成的，其中只有稳定的特征会影响输出，作者认为域是一种特殊的干预，它改变了输入的非因果特征，并假定理想的分类器应该只基于因果特征。 作者指出正确的目标是建立一个对每个对象具有不变条件的表示，这里对象被定义为共享相同因果的一组输入，例如照片中不同视角下的同一个人。除了对象已知外，作者针对对象未知的情况下，基于同一类别的输入比不同类别的输入具有更相似的因果特征的假设，提出了MatchDG算法，进一步在增强数据集上扩展为MDGHybrid。 主要贡献： 提出域泛化的对象不变条件 针对对象信息未知的情况下，提出一种两阶段迭代算法，用于近似基于对象的匹配。 2 方法 想办法找到与领域无关的不变特征\\(X_c\\)， \\[ o :=y_o(y_{true},\\epsilon _o,\\epsilon _{od}) \\; \\; \\;x_c=g_{xc}(o) \\] \\[ x_a := g_{xa}(d,o,\\epsilon _{xa}) \\; \\; \\; x:=g_x(x_c,x_a,\\epsilon _x) \\;\\;\\; y:=h(x_c,\\epsilon _y) \\] 假设$ X_C$已知，理想的损失函数： \\[ arg\\;\\mathop{min}_f \\; \\mathbb{E}_{d,x,y}l(y,f(x))=arg \\; \\mathop{min}_h \\; \\mathbb{E}[l(y,h(x_c))] \\tag{1} \\] 然而实际上$ X_C\\(未知，因此要先学习表示函数\\): $ \\(X_c\\)满足两个条件 \\(X_C\\)条件独立于D|O，即 \\(X_c \\perp \\! \\! \\! \\perp D|O\\) \\(X_C \\not \\! \\perp \\!\\!\\! \\perp O\\) 为满足第一个条件，规定同一对象O的跨域输入之间的平均成对距离为0： \\[ \\sum_{\\Omega(j,k)=1;d \\not= d'}dist(\\Phi(x_{j}^{d}),\\Phi(x_{k}^{d'}))=0 \\] \\(\\Omega: \\mathcal{X} \\times \\mathcal{X} \\to \\{0,1\\}\\)是匹配函数，输入对为同一个物体为1，否则为0. 第二个条件说明\\(X_C\\)包含O的信息，因此也包括Y的 \\[ f_{perfectmatch}= arg\\; min_{h,\\Phi}\\sum_{d=1}^mL_d(h(\\Phi(X)),Y) \\\\s.t. \\;\\sum_{\\Omega(j,k)=1;d \\not= d'}dist(\\Phi(x_{j}^{d}),\\Phi(x_{k}^{d'}))=0 \\tag{2} \\] \\(L_d(h(\\Phi(X)),Y) = \\sum_{i=1}^{n_d}l(h(\\Phi(x_i^{d}))\\cdot y_i^d)\\) 如果对象信息可用，那么损失函数如下 \\[ f_{perfectmatch}= arg\\; min_{h,\\Phi}\\sum_{d=1}^mL_d(h(\\Phi(X)),Y) +\\lambda \\sum_{\\Omega(j,k)=1;d \\not= d'}dist(\\Phi(x_{j}^{d}),\\Phi(x_{k}^{d'}))=0 \\tag{3} \\] 但对象信息并不总是可用的，因此作者提出两阶段迭代对比学习方法来近似对象匹配。 为了找到匹配项，作者优化了对比表征学习损失，与来自不同领域的不同类别的输入相比，该损失最小化了来自不同领域的相同类别输入之间的距离。正匹配是具有相同类但不同域的两个输入，并且负匹配是不同类别的对。对每个正匹配对\\((x_j,x_k)\\): \\[ l(x_j,x_k) = -log \\frac{e^{sim(j,k)/\\tau}}{e^{sim(j,k)/\\tau}+\\sum_{i=0,y_i\\not=y_j}^Be^{sim(j,i)/\\tau}} \\tag{4} \\] B是batch size，\\(\\tau\\)是超参数，\\(sim(a,b) = \\frac{\\Phi(x_a)^T\\Phi(x_b)}{\\|\\Phi(x_a)\\|\\|\\Phi(x_b)\\|}\\)是余弦相似度。 MatchDG算法如下：","categories":[{"name":"-论文阅读笔记","slug":"论文阅读笔记","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"-阅读笔记 -因果 -领域泛化","slug":"阅读笔记-因果-领域泛化","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%9B%A0%E6%9E%9C-%E9%A2%86%E5%9F%9F%E6%B3%9B%E5%8C%96/"}]},{"title":"动态知识图谱补全","slug":"动态知识图谱补全","date":"2021-11-03T08:33:32.000Z","updated":"2022-01-19T01:46:08.113Z","comments":true,"path":"2021/11/03/动态知识图谱补全/","link":"","permalink":"http://example.com/2021/11/03/%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8/","excerpt":"","text":"由于今天本来准备上课讲的，结果因为时间原因没讲成，很难受，和lyyy聊了以后，决定重新开始写博客做一些成长记录，刚好今天这个报告就可以作为一个新的开始。 动态知识图谱补全 虽然标题叫做动态知识图谱补全，但是我今天的报告本来只打算做最近看的4篇论文，不过不知道未来会不会继续看，到时候可以继续加进这个博客里面。 动态知识图谱的概念和定义 动态知识图谱是相对静态知识图谱而言的，传统的基于三元组\\((s,r,o)\\)的知识图谱被称为静态知识图谱，但是由于事实会随着时间发生改变，所以引入了时间维度描述该事实成立的一个时间范围，有的动态知识图谱会给每个事实增加一个开始和结束时间戳，这样变成了五元组，但是我看到的大多数动态知识推理方法还是基于增加一个时间戳t形成四元组\\((s,r,o,t)\\)。通常情况下这个时间戳t代表了一段时间，比如RE-NET论文中ICEWS14数据集，每个样本的t持续范围是24小时。然后还有一个值得一提的地方就是动态知识图谱(Dynamic Knowledge Graph)也可以称为时序知识图谱(Temporal Knowledge Graph, TKG)。这里从DEEMB的论文中给出一个TKG的形式化定义： \\(\\textbf{时序知识图谱（补全）：}\\)用\\(\\mathcal{V}\\)表示实体的一个有限集合，\\(\\mathcal{R}\\)表示关系类型的一个有限集合，并且用\\(\\mathcal{T}\\)表示时间戳的一个有限集合。$ $ 表示事实四元组\\((s,r,o,t)\\)的一个有限集合，其中$s,o , r , t \\(。 一个时序知识图谱\\)$是 \\(\\mathcal{W}\\)的子集，即$ \\(。时序知识图谱补全问题可以描述为从\\)\\(中推理\\)$。 其实简单来说还是从已有的事实推理潜在的事实，只不过现在加上了时间维度罢了。 TAE-ILP模型","categories":[{"name":"知识图谱","slug":"知识图谱","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"}],"tags":[]},{"title":"ics2019 pa","slug":"ics2019 pa","date":"2020-11-03T05:21:06.000Z","updated":"2021-12-24T01:51:22.116Z","comments":true,"path":"2020/11/03/ics2019 pa/","link":"","permalink":"http://example.com/2020/11/03/ics2019%20pa/","excerpt":"","text":"PA1 PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下 命令 格式 使用举例 说明 帮助(1) help help 打印命令的帮助信息 继续运行(1) c c 继续运行被暂停的程序 退出(1) q q 退出NEMU 单步执行 si [N] si 10 让程序单步执行N条指令后暂停执行, 当N没有给出时, 缺省为1 打印程序状态 info SUBCMD info r info w 打印寄存器状态 打印监视点信息 表达式求值 p EXPR p $eax + 1 求出表达式EXPR的值, EXPR支持的 运算请见调试中的表达式求值小节 扫描内存(2) x N EXPR x 10 $esp 求出表达式EXPR的值, 将结果作为起始内存 地址, 以十六进制形式输出连续的N个4字节 设置监视点 w EXPR w *0x2000 当表达式EXPR的值发生变化时, 暂停程序执行 删除监视点 d N d 2 删除序号为N的监视点 备注: 命令已实现 与GDB相比, 我们在这里做了简化, 更改了命令的格式 之后再具体说明上述命令如何实现，先看下PA1需要修改的文件，见下图 其中ui.c是主要的交互界面代码，进入主循环后，用户输入的命令在这个文件里面进行解析，再分类处理，PA1.1也是从这里开始，主要增加一些命令，后面PA1.1再详述，包括对reg.c文件的修改。 expr.c是表达式处理，主要是辅助完成p 命令，以及后面的监视点，个人认为是PA1里面最重要的部分，是PA1.2的核心内容，为了测试表达式处理是否正确，gen-expr.c是自己设计随机生成一些表达式进行检测，与主程序无关，仅仅测试使用。 watchpoint.h, watchpoint.c是辅助实现w和d命令，也就是建立监视点和删除监视点，另外cpu-exec.c中需要增加几行代码，实现对监视点的监视。后面PA1.3再详述。 PA1.0 在正式开始PA1之前，如果你选择的是x86的ISA，还有一些准备工作需要做，如果不是x86，可以直接跳过此节。 打开nemu/src/isa/x86/include/isa/reg.h文件，可以看到对CPU_state定义的结构体如下 123456789typedef struct{struct{ uint32_t _32; uint16_t _16; uint8_t _8[2]; }gpr[8];rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi;vaddr_t pc;}CPU_state; 因为原先定义的是struct，gpr数组和8个寄存器并没有关联，物理上是顺序独立的排列，为了让他们相关联起来，就要使用union，改后的代码如下 1234567891011121314typedef struct { union{ union{ uint32_t _32; uint16_t _16; uint8_t _8[2]; } gpr[8]; struct{ rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi; }; }; vaddr_t pc;} CPU_state; 可以观察reg.c中的reg_test()是如何进行测试的，生成一个随机数，然后赋值给每个32位的寄存器，然后对关联性检查。 修改完代码以后，在menu目录下执行make run，如果看到欢迎提示，进入(menu)等待输入命令就说明成功了。 PA1.1 PA1.1要实现si, x, info r三条命令。 要增加一条新的命令先写一个对应的函数，然后在cmd_table中增加命令的名称，说明，函数即可 cmd_table的结构定义如下 12345static struct { char *name; char *description; int (*handler) (char *);} cmd_table [] si命令 我先上我写的cmd_si()，再具体说明 12345678910111213141516static int cmd_si(char *args) { /* extract the first argument */ char *arg = strtok(NULL, \" \"); if (arg == NULL) { /* no argument given */ cpu_exec(1); } else { int n = atoi(arg); if(n&gt;0) cpu_exec(n); else cmd_err(0, \"si:N&lt;=0\"); } return 0;} cmd_si是我觉得这几个命令里面相对来说最简单的一个，因为他只要读出命令中的N，转化为数字再传给cpu_exec()即可，cpu_exec(n)是执行程序，其参数n是执行n步，在这里先用strtok函数读入命令格式中的N，如果没有的话就默认执行1步，即cpu_exec(1)，否则的话用atoi转化为数字后再调用。另外这里cmd_err是一个通用的报错函数，定义如下 12345678910111213static void cmd_err(int err_type,const char *command){ switch(err_type){ case 0: printf(\"Invalid arguments for command '%s'\\n\",command); break; case 1: printf(\"Lack arguments for command '%s'\\n\",command); break; default: printf(\"Unknown error\\n\"); break; }} x命令 x命令需要用到vaddr_read(addr,n)函数，其中参数addr是内存地址，n是读出的字节数，思路和刚刚一样，先用strtok函数读出命令的2个参数N和exp，这里暂时不考虑复杂的表达式，仅限于16进制数字，所以可以直接使用sscanf(arg2,\"%x\",&amp;addr);将第2个参数地址得到，然后再用vaddr_read(addr,4)每次读出4个字节的内存，循环N次即可。 info r命令 因为监视点是PA1.3建立，相关内容都要在PA1.3实现，所以目前info命令仅限于实现info r查看所有寄存器的值，让我们先到x86下面的reg.c文件，在这里实现一个显示所有寄存器的接口void isa_reg_display()，其实也很简单，就只是printf所有寄存器的值而已，打印的格式可以参考如下 123456789101112void isa_reg_display() { /* PA1.1 */ printf(\"eax\\t0x%-8x\\t%u\\n\",cpu.eax,cpu.eax); printf(\"ecx\\t0x%-8x\\t%u\\n\",cpu.ecx,cpu.ecx); printf(\"edx\\t0x%-8x\\t%u\\n\",cpu.edx,cpu.edx); printf(\"ebx\\t0x%-8x\\t%u\\n\",cpu.ebx,cpu.ebx); printf(\"esp\\t0x%-8x\\t%u\\n\",cpu.esp,cpu.esp); printf(\"ebp\\t0x%-8x\\t%u\\n\",cpu.ebp,cpu.ebp); printf(\"esi\\t0x%-8x\\t%u\\n\",cpu.esi,cpu.esi); printf(\"edi\\t0x%-8x\\t%u\\n\",cpu.edi,cpu.edi); printf(\"pc\\t0x%-8x\\t%u\\n\",cpu.pc,cpu.pc);} 有了这个接口实现info r就很简单了，只需要判断参数=='r'，然后直接调用reg.c里面的isa_reg_display()即可 至此PA1.1就完成了，PA1.1本身不难，不过要先理解整个代码框架的结构 PA1.2 如果你做过编译原理实验，这部分其实也不会太难，就是编译原理实验的一小部分。 我们一步一步来，首先对于一个表达式，我们要识别其中的符号token，例如对于表达式 1\"4 +3*(2- 1)\" 的token表达式为 1234+-----+-----+-----+-----+-----+-----+-----+-----+-----+| NUM | '+' | NUM | '*' | '(' | NUM | '-' | NUM | ')' || \"4\" | | \"3\" | | | \"2\" | | \"1\" | |+-----+-----+-----+-----+-----+-----+-----+-----+-----+ 在expr.c中首先在enum中添加你想定义的token。我推荐一步到位，PA1.2就把全部的表达式做好。 名称 意义 优先级 TK_NOTYPE 空格 0 TK_NUM 十进制数字 0 TK_HEX 十六进制数字 0 TK_REG 寄存器 0 TK_OR || 1 TK_AND &amp;&amp; 2 TK_EQ == 3 TK_PLUS + 4 TK_SUB - 4 TK_MUL * 5 TK_DIV / 5 TK_NEGTIVE 负数 6 TK_DEREF 引用(例:*$eax) 6 TK_LBR ( 7 TK_RBR ） 7 TK_NEGTIVE和TK_DEREF比较特殊，因为他们的符号分别和TK_SUB和TK_MUL是一样的，需要特殊处理，将他们区分开来，这个是在识别完所有token之后做的，暂时先忽略这2个，之后会讲。 还有一点是这里建议引入优先级，便于后续操作，所以你也需要把原先代码里面对于rule结构体增加一项优先级的成员。 12345static struct rule { char *regex; int token_type; int priority; // add priority} rules[] 当然Token结构体也不要忘了加。 12345typedef struct token { int type; char str[32]; int priority; //add priority} Token 填写好rules，正则表达式，符号，优先级。在make_token中会对表达式挨个字符进行分析，从第一条规则开始遍历rules，匹配成功以后，首先对匹配字符串的长度检测，判断是否大于32，如果大于32个字符assert(0)，否则的话，根据匹配的规则，进行进一步操作。 123456789101112switch (rules[i].token_type) { case TK_NOTYPE: break; case TK_NUM: case TK_HEX: case TK_REG: strncpy(tokens[nr_token].str, substr_start, substr_len); tokens[nr_token].str[substr_len] = '\\0'; default: tokens[nr_token].type = rules[i].token_type; tokens[nr_token].priority = rules[i].priority; nr_token++; } 对每个规则都要做的是，将其类型和优先级存入tokens数组，而对于数字，额外需要的操作是将其字符串也要保存，为了之后得到具体数值。对于空格就跳过即可。 另外值得一提的是这里可以把tokens数字开大一点，后面测试的时候需要修改。 1static Token tokens[65536] __attribute__((used)) = {}; 到这里第一步算是完成了，第一步的工作是利用正则表达式识别给定表达式的token，然后将其顺序的存入tokens数组，保存其类型，优先级，和数字的字符串（相当于是数值）。 接下来在完成手册中提示的eval()函数之前，我们还需要写2个辅助函数——check_parentheses()和get_main_op()。 int check_parentheses(int p, int q)，这里建议将返回类型由bool改为int，因为需要返回3种不同情况。参数p和q分别是tokens数组的起始和结束位置。函数的功能是根据tokens数组从p到q这部分所代表的表达式返回以下3种： 返回1 如果表达式是一个由一对左右括号完整包裹的一个有效表达式。 返回0 如果表达式是一个有效的表达式，但是并没有被一对左右括号包裹。 返回-1 如果表达式不是一个有效的表达式。 另外值得一提的是这里需要考虑一种特殊情况，就是虽然是一个有效的表达式，同时左右分别是左括号和号，但是这两个括号并不是一对，例如 \\[ (4+3)*(4+4) \\] 对于这样的表达式，应该返回0而不是1。这里是对括号的匹配性进行检测，其他方面的细节可以不用管。从p位置开始到q位置，用n进行记录，如果遇到左括号n+1如果遇到右括号n-1,在循环过程中，只要n变为负数可以理解退出返回-1，如果循环结束n不为0也返回-1。剩下的就不用多说了，反正直接看代码也就懂了。 int get_main_op(int p, int q)，参数的意义同上，函数的作用是从p位置开始扫描到q位置，找到一个优先级最低的运算符号且该运算符号不能在括号包裹的表达式里面，同优先级的情况下取最右边的运算符号作为主符号，最后将主符号的位置返回。因为tokens里面有存各个符号的优先级，所以这里就可以非常简单的实现。判断括号内的方法可以参考上面的用n记录的方法，只有当n等于0的时候说明不在括号内，这时候再进行对运算符号优先级的比较。 两个辅助函数写完的情况下，对于PA1.2来说可以去实现关键的eval()函数了，但是我一开始就说过了要一步到位，所以先不急着去写eval()函数，我们需要先到expr()函数里面完成一些前置工作。 uint32_t expr(char e, bool success)，对字符串e进行表达式求值，如果求值成功*success==true，失败*success==false，返回求值的结果。expr()函数首先调用make_token完成我前面说的第一步，将表达式进行符号解析存入tokens数组中，之后就是我们需要添加的代码，在已经完成第一步解析的基础上，需要对*和-进行进一步的分析，识别出TK_DEREF和TK_NEGTIVE。 12345678910for(int i=0; i&lt;nr_token; i++){ if(tokens[i].type == TK_MUL &amp;&amp; (i==0 || (tokens[i-1].priority!=0 &amp;&amp; tokens[i-1].type!=TK_RBR))){ tokens[i].type = TK_DEREF; tokens[i].priority = 6; } else if (tokens[i].type == TK_SUB &amp;&amp; (i==0 || (tokens[i-1].priority!=0 &amp;&amp; tokens[i-1].type!=TK_RBR))){ tokens[i].type = TK_NEGTIVE; tokens[i].priority = 6; } } 对tokens数组扫描，对于其中的*也就是type是TK_MUL，如果位置在第一个，或者他的前一个符号不是数字(可以用优先级简单的判断，因为数字的优先级是0)，且不是右括号，那么将这个TK_MUL重新解释为TK_DEREF，优先级为6。同理对TK_NEGTIVE也进行类似的判断识别。现在所有符号都正确的识别了，可以使用eval对其进行求值了。 uint32_t eval(int p, int q, bool *success)，求出tokens数组从p到q所代表的表达式的值，如果求值成功*success==true，失败*success==false，返回求值的结果。eval的大致框架和思路在手册里面有写，这里就不赘述了。eval流程图如下： graph TD A(开始) --&gt; B{p与q的关系} B --&gt; |p &gt; q| err[*success=falsereturn -1] B --&gt; |p == q| E[\"根据tokens[p].type(10进制,16进制或寄存器)求值\"] B --&gt; |p &lt; q| F[\"ret=check_parenthese(p,q)\"] F --&gt; G{ret返回值} G --&gt; |ret == -1| err G --&gt; |ret == 1| ret1[\"return eval(p+1,q-1,success)\"] G --&gt; |ret == 0| ret0[\"pos=get_main_op(p,q)\"] ret0 --&gt; |pos == -1| err ret0 --&gt; |pos != -1| eval[\"val1 = eval(p, pos - 1, success); val2 = eval(pos + 1, q, success); 根据tokens[pos].type进行运算\"] 有了流程图，大致的代码思路应该已经有了，再来说下其中的细节。 首先是p==q的时候，这时候说明这个表达式没有运算符号，其本身是一个数值或者寄存器，如果是TK_NUM或者TK_HEX，那么直接strtoul(tokens[p].str, NULL, 0)就可以把字符串转化为数值，如果是TK_REG，那么需要使用isa_reg_str2val(tokens[p].str + 1, success)获取寄存器的值。这个isa_reg_str2val()函数在之前的reg.c中，需要你去实现它。 1234567891011121314151617uint32_t isa_reg_str2val(const char *s, bool *success) { /* PA1.2 */ *success = true; if(strcmp(s, \"pc\") == 0 || strcmp(s, \"eip\") == 0) return cpu.pc; int i; for(i = R_EAX; i &lt;= R_EDI; ++ i) { if(strcmp(s, regsl[i]) == 0) return reg_l(i); } for(i = R_AX; i &lt;= R_DI; ++ i){ if(strcmp(s, regsw[i]) == 0) return reg_w(i); } for(i = R_AL; i &lt;= R_BH; ++ i){ if(strcmp(s, regsb[i]) == 0) return reg_b(i); } *success = false; return 0;} 遍历所有的寄存器，比对传入参数s和寄存器的名字，找到s对应的寄存器然后返回寄存器中的值。 第2个细节是根据tokens[pos].type进行运算，pos的位置指向主运算符，如果这个主运算符是除法，那么应该注意一下对于除以0行为的处理，也就是判断val2==0?，简单一点直接assert(0)也可以，也可以输出一段提示后，*success=false。其他的运算符都比较简单，注意TK_DEREF是val=vaddr_read(val2,4)以及TK_NEGTIVE是val=-val2即可。(这两个运算符并没有用到val1) 其实到这里PA1.2已经完成了，但是手册里面要求你还需要对你的表达式写一个程序随机测验，所以你还需要完成gen-expr.c。测试原理在手册里面已经讲了，而我们在这个文件中需要自己补充的仅仅是随机生成一个表达式的部分，我直接贴上我的代码再讲比较方便，如下： 1234567891011121314151617181920212223242526272829303132/* PA1.2 */#define N_TOKEN 10static char buf[5000];static uint32_t choose(uint32_t n){ return rand() % n; }static inline void gen_rand_expr(int l,int r) { int op; if(l==r)buf[l]=choose(10)+48; else if(r==l+1){ buf[l]=choose(9)+1+48; buf[r]=choose(10)+48; } else{ switch(choose(1)){ case 0: op=l+1+choose(r-l-1); gen_rand_expr(l,op-1); static char ops[] = \"+-*/\"; buf[op]=ops[choose(4)]; gen_rand_expr(op+1,r); break; default: buf[l]='('; buf[r]=')'; gen_rand_expr(l+1,r-1); break; } }} N_TOKEN是最后表达式中token的数目，uint32_t choose(uint32_t n)随机生成一个0~n-1的数。 void gen_rand_expr(int l,int r)在字符串位置l和r之间随机生成表达式的token，如果r==l生成一个1位数字，如果r==l+1生成一个两位数，此外，从下面2种情况中生成一种： 在l+1到r-1中随机选取一个位置作为主符号的位置op，并从加减乘除当中随机选择一个符号。递归调用gen_rand_expr(l,op-1)和gen_rand_expr(op+1,r)生成两边的表达式。 在l和r的位置生成一对括号，递归调用gen_rand_expr(l+1,r-1)，生成被一对括号包裹的表达式。 最后修改下面的main函数中对gen_rand_expr()的调用，加上参数，就完成了。别忘了修改buf和code_buf数组的大小，至少保证buf的长度小于code_buf。 完成了以后记得去ui.c中加入p命令，方式同PA1.1。这里只要调用expr即可，我附上我的代码如下： 12345678910111213141516static int cmd_p(char *args) { /* extract the first argument */ if (args == NULL) { /* no argument given */ cmd_err(0, \"p: no argument given\\n\"); } else{ bool success = true; uint32_t result = expr(args,&amp;success); if(success) printf(\"0x%x(%d)\\n\",result,result); else printf(\"Invalid expr\\n\"); } return 0;} PA1.3 PA1.3要求实现监视点的创建和删除。首先我们先到watchpoint.h查看WP结构体，可以看到原始定义只有表示WP的序号NO以及作为链表结点必须的next指针，这显然是不够的。 123456789typedef struct watchpoint { int NO; struct watchpoint *next; /* TODO: Add more members if necessary */ /* PA1.3*/ char expr[128]; uint32_t value; int hit;} WP; 需要添加的成员有3个： char expr[128]：用于记录创建的监视点的表达式，例如$eax uint32_t value：求出当前的表达式的值，表达式是不变的，但是其值会变，因为寄存器值会变，当表达式值改变的时候就要暂停程序，算是命中。 int hit：记录该监视点的命中次数。 监视点采用链表池的结构管理，所有监视点保存在wp_pool数组中，而正在使用的监视点由head指针串起的一个链表，空闲的监视点链表由free_指向。 剩下的其实都是基本的链表操作，例如创建一个监视点，就是将free_指向的首结点从空闲链表摘除，加进head指向的链表。并设置其expr,hit,计算expr。而删除一个监视点，就是遍历head指向的链表，找到一个结点其序号NO与给定的相符，将其从head链表中删除，移到free_链表。 除了添加和删除，还需要展示监视点的内容，这里是继续了PA1.1的info w命令，函数自己命名，展示格式可以参考如下代码： 1234567891011121314void display_wp(){ if(head == NULL) { printf(\"There is no watchpoint!\\n\"); return; } printf(\"Num What Value\\n\"); WP *p = head; while(p != NULL) { printf(\"%-8d%-9s%u(%#x)\\n\", p -&gt; NO, p -&gt; expr, p-&gt;value, p-&gt;value); if(p -&gt; hit &gt; 0) printf(\"\\tbreakpoint already hit %d time\\n\", p-&gt;hit); p = p -&gt; next; }} 除此之外，你还需要一个功能，监视点的作用是当监视的表达式的值变化时，暂停程序。我们先实现bool check_wp()，它的功能是检查所有监视点，看是否有监视点的表达式值发生了变化。方法很简单，遍历head指向的所有正在使用的监视点，然后重新计算其expr的值，与之前保存在value当中的值比对，如果不同的话，说明表达式的值发生了变化。然后需要暂停程序，这里手册给了提示，只要把nemu_state.state赋值为NEMU_STOP即可。在cpu_exec.c的cpu_exec()函数，我们会亲切的发现已经有注释写好了你需要添加的位置，而你只需要在这行注释下面添加这么几行代码即可。 123456/* TODO: check watchpoints here. */ /* PA1.3*/ bool changed = check_wp(); if(changed){ nemu_state.state = NEMU_STOP; } 最后别忘了回到ui.c完善你所有的命令，整个PA1就算完成了，其实还算简单，真正痛苦的地狱PA2才正要开始。 PA2 该说不愧是1星难度吗，确实挺难的。 PA2.1 我觉得有必要先整理一下结构体定义（不过你可以先暂时跳过这部分，直接看完追踪mov指令执行过程会更加清晰）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#define make_DHelper(name) void concat(decode_, name) (vaddr_t *pc)typedef void (*DHelper) (vaddr_t *);#define make_EHelper(name) void concat(exec_, name) (vaddr_t *pc)typedef void (*EHelper) (vaddr_t *);typedef struct { DHelper decode; EHelper execute; int width;} OpcodeEntry;typedef struct { uint32_t type; int width; union { uint32_t reg; rtlreg_t addr; uint32_t imm; int32_t simm; }; rtlreg_t val; char str[OP_STR_SIZE];} Operand;typedef struct { uint32_t opcode; uint32_t width; vaddr_t seq_pc; // sequential pc bool is_jmp; vaddr_t jmp_pc; Operand src, dest, src2; struct ISADecodeInfo isa;} DecodeInfo;typedef union { struct { int32_t simm : 16;// uint32_t rt : 5;// uint32_t rs : 5;// uint32_t opcode : 6; }; struct { uint32_t imm : 16;// uint32_t rt : 5;// uint32_t rs : 5;// uint32_t opcode : 6; }; struct { uint32_t jmp_target : 26; uint32_t opcode : 6; }; struct { uint32_t func : 6; uint32_t sa : 5; uint32_t rd : 5; uint32_t rt : 5; uint32_t rs : 5;// uint32_t opcode : 6; }; uint32_t val;} Instr;struct ISADecodeInfo { Instr instr;};typedef union { struct { uint8_t R_M :3; uint8_t reg :3; uint8_t mod :2; }; struct { uint8_t dont_care :3; uint8_t opcode :3; }; uint8_t val;} ModR_M;typedef union { struct { uint8_t base :3; uint8_t index :3; uint8_t ss :2; }; uint8_t val;} SIB; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static inline uint32_t instr_fetch(vaddr_t *pc, int len) { uint32_t instr = vaddr_read(*pc, len);#ifdef DEBUG uint8_t *p_instr = (void *)&amp;instr; int i; for (i = 0; i &lt; len; i ++) { extern char log_bytebuf[]; strcatf(log_bytebuf, \"%02x \", p_instr[i]); }#endif (*pc) += len; return instr;}/* Instruction Decode and EXecute */static inline void idex(vaddr_t *pc, OpcodeEntry *e) { if (e-&gt;decode) e-&gt;decode(pc); e-&gt;execute(pc);}make_DHelper(mov_I2r) { decode_op_r(pc, id_dest, false); decode_op_I(pc, id_src, true);}/* This helper function is use to decode register encoded in the opcode. *//* XX: AL, AH, BL, BH, CL, CH, DL, DH * eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */static inline make_DopHelper(r) { op-&gt;type = OP_TYPE_REG; op-&gt;reg = decinfo.opcode &amp; 0x7; if (load_val) { rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;width); } print_Dop(op-&gt;str, OP_STR_SIZE, \"%%%s\", reg_name(op-&gt;reg, op-&gt;width));}/* Refer to Appendix A in i386 manual for the explanations of these abbreviations *//* Ib, Iv */static inline make_DopHelper(I) { /* pc here is pointing to the immediate */ op-&gt;type = OP_TYPE_IMM; op-&gt;imm = instr_fetch(pc, op-&gt;width); rtl_li(&amp;op-&gt;val, op-&gt;imm); print_Dop(op-&gt;str, OP_STR_SIZE, \"$0x%x\", op-&gt;imm);} 我们以追踪mov指令执行过程为例讲解整个流程。 从cpu.c开始首先执行exec_once()函数 1234567vaddr_t exec_once(void) { decinfo.seq_pc = cpu.pc; isa_exec(&amp;decinfo.seq_pc); update_pc(); return decinfo.seq_pc;} 将cpu.pc的值保存在了decinfo.seq_pc中，然后将该值的索引传进isa_exec()中，最后调用update_pc()更新pc值。关键的译码和执行显然在isa_exec()中，这个函数也有屏蔽isa差别的功能，来到isa/x86/exec/exec.c中，这里有isa_exec()定义： 123456void isa_exec(vaddr_t *pc) { uint32_t opcode = instr_fetch(pc, 1); decinfo.opcode = opcode; set_width(opcode_table[opcode].width); idex(pc, &amp;opcode_table[opcode]);} instr_fetch()的定义在include/cpu/exec.h中 12345678910111213static inline uint32_t instr_fetch(vaddr_t *pc, int len) { uint32_t instr = vaddr_read(*pc, len);#ifdef DEBUG uint8_t *p_instr = (void *)&amp;instr; int i; for (i = 0; i &lt; len; i ++) { extern char log_bytebuf[]; strcatf(log_bytebuf, \"%02x \", p_instr[i]); }#endif (*pc) += len; return instr;} 功能很简单，就是读取pc所指内存len个字节返回，然后pc的值增加len长度。 回到isa_exec()，很明显先是从pc所指地方读取一个字节作为opcode并且保存在decinfo.opcode中，如果是mov指令，以下面这条mov指令为例： 1100000: b8 34 12 00 00 mov $0x1234,%eax 那么这个opcode一定是0xb8，接着我们用opcode作为索引查表opcode_table 1/* 0xb8 */ IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), IDEX(mov_I2r, mov), 也就是IDEX(mov_I2r,mov)，我们先来看看opcode_table的定义。他是一个OpcodeEntry类型的数组，那么OpcodeEntry又是什么呢，他的结构体定义在include/cpu/exec.h中，如下： 12345typedef struct { DHelper decode; EHelper execute; int width;} OpcodeEntry; 在这个文件的上面可以找到EHelper的定义： 1typedef void (*EHelper) (vaddr_t *); DHelper的定义在decode.h中可以找到，是类似的。总之就是说这个结构体有2个函数指针和一个int类型变量记录宽度，这两个函数指针分别执行译码函数和执行函数的入口。 在exec.h中，我们还可以看到IDEX宏的定义： 12345#define IDEXW(id, ex, w) {concat(decode_, id), concat(exec_, ex), w}#define IDEX(id, ex) IDEXW(id, ex, 0)#define EXW(ex, w) {NULL, concat(exec_, ex), w}#define EX(ex) EXW(ex, 0)#define EMPTY EX(inv) IDEX是宽度为0的IDEXW，而IDEXW里面这个concat同样是个宏，这里就不再去找了，直接解释他的作用，就是将后面2个字符串拼接起来，我们回到IDEX(mov_I2r, mov)这个具体实例，通过这层层宏，最终应该被翻译成 12345{ decode_mov_I2r, exec_mov, 0} 我们再回到isa_exec()，现在该执行set_width(opcode_table[opcode].width);这行了，不过根据上面分析，这里宽度的值为0，也就是set_width(0);那么set_width会怎么处理，我们需要看下set_width()函数的定义（exec.c文件）： 123456static inline void set_width(int width) { if (width == 0) { width = decinfo.isa.is_operand_size_16 ? 2 : 4; } decinfo.src.width = decinfo.dest.width = decinfo.src2.width = width;} 因为width==0，而decinfo.isa.is_operand_size_16默认值是false，所以操作数的位宽都被设置为了4。 继续执行下一行idex(pc, &amp;opcode_table[opcode]);我们需要看一下idex()函数的定义(exec.h)： 123456/* Instruction Decode and EXecute */static inline void idex(vaddr_t *pc, OpcodeEntry *e) { if (e-&gt;decode) e-&gt;decode(pc); e-&gt;execute(pc);} 前面也说了OpcodeEntry里面有译码函数指针和执行函数指针，这里检测译码函数指针是否为NULL，如果为NULL，就直接进入执行函数，否则以pc作为参数进入译码函数，作为例子的译码函数是decode_mov_I2r()，不过这个函数也是宏定义的，我们先得找到。 我们来到isa/x86/decode.c文件，这里有很多用宏定义构成的译码函数，我们来看看是怎么构成的。 从结果说起吧，第157行make_DHelper(mov_I2r)就是我们要找的decode_mov_I2r(). 1234make_DHelper(mov_I2r) { decode_op_r(pc, id_dest, false); decode_op_I(pc, id_src, true);} 先去include/cpu/decode.h里面可以看到make_DHelper(name)宏定义： 1#define make_DHelper(name) void concat(decode_, name) (vaddr_t *pc) 因此按照这个宏定义，将make_DHelper(mov_I2r)翻译过来就是 1void decode_mov_I2r(vaddr_t *pc) 没错，正是我们所要找的函数，这个函数里面调用了2个decode_op_前缀的函数，在decode.c中我们可以在开头第4行看到这样一行宏定义： 1#define make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *pc, Operand *op, bool load_val) 所以，类似的，我们要找make_DopHelper(r)和make_DopHelper(I)，分别在59行和第9行： 123456789101112131415161718192021static inline make_DopHelper(r) { op-&gt;type = OP_TYPE_REG; op-&gt;reg = decinfo.opcode &amp; 0x7; if (load_val) { rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;width); } print_Dop(op-&gt;str, OP_STR_SIZE, \"%%%s\", reg_name(op-&gt;reg, op-&gt;width));}/* Refer to Appendix A in i386 manual for the explanations of these abbreviations *//* Ib, Iv */static inline make_DopHelper(I) { /* pc here is pointing to the immediate */ op-&gt;type = OP_TYPE_IMM; op-&gt;imm = instr_fetch(pc, op-&gt;width); rtl_li(&amp;op-&gt;val, op-&gt;imm); print_Dop(op-&gt;str, OP_STR_SIZE, \"$0x%x\", op-&gt;imm);} 我们先将make_DopHelper(r)翻译一下： 123456789static inline decode_op_r (vaddr_t *pc, Operand *op, bool load_val) { op-&gt;type = OP_TYPE_REG; op-&gt;reg = decinfo.opcode &amp; 0x7; if (load_val) { rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;width); } print_Dop(op-&gt;str, OP_STR_SIZE, \"%%%s\", reg_name(op-&gt;reg, op-&gt;width));} 这里就很明显了，这个函数将op的类型赋值为OP_TYPE_REG，也就是标注为寄存器，寄存器的编号是opcode&amp;0x7，我们例子中opcode为0xb8，所以寄存器编号是0，而0号寄存器就是EAX，而load_val为false所以跳过，不过我认为这里还是先说明一下rtl函数，它们在include/isa/rtl.h文件和include/rtl目录中，目前只实现了几个，后面很多需要我们来补充。手册里面说过了，在NEMU中, 我们使用RTL（寄存器传输语言）来描述简单的操作.例如： 12345678static inline void rtl_lr(rtlreg_t* dest, int r, int width) { switch (width) { case 4: rtl_mv(dest, &amp;reg_l(r)); return; case 1: rtl_host_lm(dest, &amp;reg_b(r), 1); return; case 2: rtl_host_lm(dest, &amp;reg_w(r), 2); return; default: assert(0); }} 在rtl-wrapper.h里面有相关宏定义： 12#define RTL_PREFIX interpret#define rtl_mv concat(RTL_PREFIX, _rtl_mv ) 而在include/rtl/rtl.h中有具体的函数定义： 123static inline void interpret_rtl_mv(rtlreg_t* dest, const rtlreg_t *src1) { *dest = *src1;} 我想这个先暂时讲到这里，让我们回到decode_mov_I2r()函数，我们仅仅分析了它调用的一个函数，不过其实第2个也类似，这个函数从名字上也可以看出它的功能是把立即数（Imm）送入寄存器(reg)，因此它先调用了decode_op_r(pc, id_dest, false)这里id_dest也是一个宏，翻译过来其实就是&amp;decinfo.dest，也就是说这个函数作用是把目的操作数的类型确定为了寄存器，并记录了寄存器编号，为后续做好准备。那么decode_op_r(pc, id_src, true)函数的结果也显而易见了，将源操作数的类型设置为立即数，同时设置好立即数的值，从它的代码中我们可以看到instr_fetch(pc, op-&gt;width);也就是说从opcode字节后面又取了4个字节作为立即数的值。然后使用rtl_li(&amp;op-&gt;val, op-&gt;imm)将值保存进了op-&gt;val中。整个译码过程就算结束了。 接下来是执行过程，先找执行函数也就是exec_mov()函数，与前面类似，也就是说我们要找make_EHelper(mov)，这里看下x86/exec目录下，根据指令的类型不同分类出了arith.c存放运算类执行函数，control.c存放控制类执行函数,data-mov.c存放数据传输执行函数。所以我们来到data-mov.c文件中。 1234make_EHelper(mov) { operand_write(id_dest, &amp;id_src-&gt;val); print_asm_template2(mov);} 还是先把宏都翻译一下，包括id_dest 1234void exec_mov(vaddr_t *pc){ operand_write(&amp;decinfo.dest, &amp;id_src-&gt;val); print_asm(#mov \"%c %s,%s\", suffix_char((&amp;decinfo.dest)-&gt;width), id_src-&gt;str, id_dest-&gt;str)} 很显然，operand_write(&amp;decinfo.dest, &amp;id_src-&gt;val)的功能是把源操作数的值，写入目的操作数中。我们来具体看下operand_write()定义（decode.c）： 12345void operand_write(Operand *op, rtlreg_t* src) { if (op-&gt;type == OP_TYPE_REG) { rtl_sr(op-&gt;reg, src, op-&gt;width); } else if (op-&gt;type == OP_TYPE_MEM) { rtl_sm(&amp;op-&gt;addr, src, op-&gt;width); } else { assert(0); }} 根据目的操作数的类型不同，调用rtl_sr()将源操作数的值送入寄存器(reg)或者调用rtl_sm()送入内存(mem)。 执行函数执行完以后不要完了exec_once最后还调用了update_pc()，让我们也看下它的定义： 1234static inline void update_pc(void) { if (decinfo.is_jmp) { decinfo.is_jmp = 0; } else { cpu.pc = decinfo.seq_pc; }} 作为mov指令，自然是没有跳转的，再读完了一个字节的opcode和4个字节的立即数后decinfo.seq_pc自然已经来到了下一条指令的opcode位置，将其赋值给cpu.pc完成pc更新的工作就算真正的执行完了一条指令。 再以movw为例讲一下复杂指令的流程： 12100017: 66 c7 84 99 00 e0 ff movw $0x1,-0x2000(%ecx,%ebx,4)10001e: ff 01 00 按照之前讲的流程先取到了opcode_table[0x66]的元素，会发现是一个EX(operand_size)，这个宏翻译过来译码辅助函数为NULL，只有执行函数的指针，所以我们直接看它的执行函数，在prefix.c中 12345make_EHelper(operand_size) { decinfo.isa.is_operand_size_16 = true; isa_exec(pc); decinfo.isa.is_operand_size_16 = false;} 将is_operand_size_16设置为true，也就是更改宽度为16位，然后从下个字节开始执行isa_exec(pc)。这完成的就是operand-size prefix的功能。因为它的存在mov指令被识别为了movw指令。 接下来是真正的opcode，其值为0xc7，opcode_table[0xc7]=IDEX(mov_I2E, mov)，我们直接看译码函数(decode.c)： 1234make_DHelper(I2E) { decode_op_rm(pc, id_dest, true, NULL, false); decode_op_I(pc, id_src, true);} decode_op_I()跟前面一样就不用说了，不同的仅限于这次是取2个字节作为立即数。 让我们看下decode_op_rm()的定义： 12345678910111213/* I386 manual does not contain this abbreviation. * We decode everything of modR/M byte by one time. *//* Eb, Ew, Ev * Gb, Gv * Cd, * M * Rd * Sw */static inline void decode_op_rm(vaddr_t *pc, Operand *rm, bool load_rm_val, Operand *reg, bool load_reg_val) { read_ModR_M(pc, rm, load_rm_val, reg, load_reg_val);} 在src/isa/x86/decode/modrm.c中可以找到read_ModR_M()定义： 123456789101112131415161718192021222324252627282930313233void read_ModR_M(vaddr_t *pc, Operand *rm, bool load_rm_val, Operand *reg, bool load_reg_val) { ModR_M m; m.val = instr_fetch(pc, 1); decinfo.isa.ext_opcode = m.opcode; if (reg != NULL) { reg-&gt;type = OP_TYPE_REG; reg-&gt;reg = m.reg; if (load_reg_val) { rtl_lr(&amp;reg-&gt;val, reg-&gt;reg, reg-&gt;width); }#ifdef DEBUG snprintf(reg-&gt;str, OP_STR_SIZE, \"%%%s\", reg_name(reg-&gt;reg, reg-&gt;width));#endif } if (m.mod == 3) { rm-&gt;type = OP_TYPE_REG; rm-&gt;reg = m.R_M; if (load_rm_val) { rtl_lr(&amp;rm-&gt;val, m.R_M, rm-&gt;width); }#ifdef DEBUG sprintf(rm-&gt;str, \"%%%s\", reg_name(m.R_M, rm-&gt;width));#endif } else { load_addr(pc, &amp;m, rm); if (load_rm_val) { rtl_lm(&amp;rm-&gt;val, &amp;rm-&gt;addr, rm-&gt;width); } }} 先看一下ModR_M的联合定义(x86/include/isa/decode.h)： 123456789101112typedef union { struct { uint8_t R_M :3; uint8_t reg :3; uint8_t mod :2; }; struct { uint8_t dont_care :3; uint8_t opcode :3; }; uint8_t val;} ModR_M; 我们需要结合x86指令格式的ModR/M去看 12345ModR/M byte7 6 5 4 3 2 1 0+--------+-------------+-------------+| mod | reg/opcode | r/m |+--------+-------------+-------------+ m.val又读取了一个字节，也就是0x84，把这个字节按照上面进行拆分，mod部分是2，reg/opcode是0,因此read_ModR_M()函数执行最后一个else块，先load_addr(pc, &amp;m, rm) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void load_addr(vaddr_t *pc, ModR_M *m, Operand *rm) { assert(m-&gt;mod != 3); int32_t disp = 0; int disp_size = 4; int base_reg = -1, index_reg = -1, scale = 0; rtl_li(&amp;s0, 0); if (m-&gt;R_M == R_ESP) { SIB s; s.val = instr_fetch(pc, 1); base_reg = s.base; scale = s.ss; if (s.index != R_ESP) { index_reg = s.index; } } else { /* no SIB */ base_reg = m-&gt;R_M; } if (m-&gt;mod == 0) { if (base_reg == R_EBP) { base_reg = -1; } else { disp_size = 0; } } else if (m-&gt;mod == 1) { disp_size = 1; } if (disp_size != 0) { /* has disp */ disp = instr_fetch(pc, disp_size); if (disp_size == 1) { disp = (int8_t)disp; } rtl_addi(&amp;s0, &amp;s0, disp); } if (base_reg != -1) { rtl_add(&amp;s0, &amp;s0, &amp;reg_l(base_reg)); } if (index_reg != -1) { rtl_shli(&amp;s1, &amp;reg_l(index_reg), scale); rtl_add(&amp;s0, &amp;s0, &amp;s1); } rtl_mv(&amp;rm-&gt;addr, &amp;s0);#ifdef DEBUG char disp_buf[16]; char base_buf[8]; char index_buf[8]; if (disp_size != 0) { /* has disp */ sprintf(disp_buf, \"%s%#x\", (disp &lt; 0 ? \"-\" : \"\"), (disp &lt; 0 ? -disp : disp)); } else { disp_buf[0] = '\\0'; } if (base_reg == -1) { base_buf[0] = '\\0'; } else { sprintf(base_buf, \"%%%s\", reg_name(base_reg, 4)); } if (index_reg == -1) { index_buf[0] = '\\0'; } else { sprintf(index_buf, \",%%%s,%d\", reg_name(index_reg, 4), 1 &lt;&lt; scale); } if (base_reg == -1 &amp;&amp; index_reg == -1) { sprintf(rm-&gt;str, \"%s\", disp_buf); } else { sprintf(rm-&gt;str, \"%s(%s%s)\", disp_buf, base_buf, index_buf); }#endif rm-&gt;type = OP_TYPE_MEM;} R_ESP是一个常量值为4，在PA1的reg.h里面有定义，本例中m-&gt;R_M也是等于4,说明之后还有一个SIB字节，这个字节指示了如何寻址： 1displacement(R[base_reg], R[index_reg], scale_factor) 我们看下SIB联合的定义(decode.h)： 12345678typedef union { struct { uint8_t base :3; uint8_t index :3; uint8_t ss :2; }; uint8_t val;} SIB; 结合x86指令格式： 12345SIB (scale index base) byte7 6 5 4 3 2 1 0+--------+-------------+-------------+| ss | index | base |+--------+-------------+-------------+ 本例中SIB字节是0x99，因此base=1,index=3,ss=2。base_reg=1，也就是R_ECX，index_reg是3，也就是EBX，然后因为前面得到的mod的值为2，所以disp_size取默认值4，说明后面有4个字节的偏移量，disp = instr_fetch(pc, disp_size);在本例中取得0xffffe000，也就是-0x2000。ss=2，代表scale=2，向左移2位也就是乘4. 因此最后计算的地址是 1addr = R[ECX] + R[EBX] * 4 - 0x2000 而从代码里面我们可以看到是用了一系列的rtl完成上面这个表达式的计算，用了2个临时寄存器s0和s1保存中间计算结果，具体看代码应该看得懂。总之计算完地址后可以把目的操作数类型填写为OP_TYPE_MEM，并将地址保存在其addr成员中。译码阶段算是完成了，执行阶段与前面mov指令类型就不再赘述了，我们直接开始完成PA2.1。 按照手册的提示，要运行第一个程序需要完成call, push, sub, xor, ret五条指令。更具体的来说，我们需要完成nexus-am/tests/cputest/build/dummy-$ISA-nemu.txt中的这5条指令。（建议配合i386手册食用) call指令 查看反汇编结果，可以看到这里有2条call指令，且它们的形式相同，都是e8 cd的形式，我们以第一条为例。 110000a: e8 05 00 00 00 call 100014 &lt;_trm_init&gt; e8是opcode，后面4个字节是偏移量，跳转的地址是pc+指令长度+偏移量，也就是 0x10000a + 0x5 + 0x5 = 0x100014 我们首先要去填写opcode_table[0xe8]，指示它的译码函数和执行函数，这个需要提前查看所有的译码函数选择恰当的一个，这里选择decode_J(),执行函数也是类似，选择exec_call()，位宽是4个字节，因此 opcode_table[0xe8]=IDEX(J, call) 接下来看译码函数，先明确译码函数的任务应该是再取4个字节作为偏移量，计算出跳转地址并保存在decoinfo中。 12345make_DHelper(J) { decode_op_SI(pc, id_dest, false); // the target address can be computed in the decode stage decinfo.jmp_pc = id_dest-&gt;simm + *pc;} 这个辅助函数是写好的，不用我们补充，但是decode_op_SI()函数需要我们自己填写，而且其实主要的工作还是这个函数完成，取width宽度的字节作为偏移量，然后如果width小于4的话，还要进一步进行符号位扩展，最后保存在op-&gt;simm中： 12345678910111213141516171819202122232425/* I386 manual does not contain this abbreviation, but it is different from * the one above from the view of implementation. So we use another helper * function to decode it. *//* sign immediate */static inline make_DopHelper(SI) { assert(op-&gt;width == 1 || op-&gt;width == 4); op-&gt;type = OP_TYPE_IMM; /* TODO: Use instr_fetch() to read `op-&gt;width' bytes of memory * pointed by 'pc'. Interpret the result as a signed immediate, * and assign it to op-&gt;simm. * op-&gt;simm = ??? */ /* PA2.1 */ s0 = instr_fetch(pc, op-&gt;width); rtl_sext(&amp;s0, &amp;s0, op -&gt; width); op -&gt; simm = s0; rtl_li(&amp;op-&gt;val, op-&gt;simm); print_Dop(op-&gt;str, OP_STR_SIZE, \"$0x%x\", op-&gt;simm);} 这里使用rtl_sext进行符号位扩展，不过rtl_sext()也需要自己补充： 12345static inline void rtl_sext(rtlreg_t* dest, const rtlreg_t* src1, int width) { // dest &lt;- signext(src1[(width * 8 - 1) .. 0]) int32_t val = *src1; *dest = (val &lt;&lt; (32 - width * 8)) &gt;&gt; (32 - width * 8);} 译码函数算是写完了，再来看执行函数，还是先明确call执行函数的任务：先把下一条指令的地址(seq_pc)压栈，然后跳转到译码函数计算出来的地址(jmp_pc)。 12345678make_EHelper(call) { // the target address is calculated at the decode stage /* PA2.1 */ rtl_push(&amp;decinfo.seq_pc); rtl_j(decinfo.jmp_pc); print_asm(\"call %x\", decinfo.jmp_pc);} rtl_j()已经给出，我们需要实现rtl_push()： 1234567static inline void rtl_push(const rtlreg_t* src1) { // esp &lt;- esp - 4 // M[esp] &lt;- src1 /* PA2.1 */ reg_l(R_ESP) -= 4; rtl_sm(&amp;reg_l(R_ESP), src1, 4);} 使用rtl_sm作为客户访存，把地址压栈。 整个call指令就算完成了，感觉还是蛮简单的，理解了过程以后真的做起来就感觉不难了。 ret指令 ret指令只有一个字节的opcode： 1100012: c3 ret opcode_table[0xc3]=EX(ret) 1234567make_EHelper(ret) { /* PA2.1 */ rtl_pop(&amp;decinfo.jmp_pc); rtl_j(decinfo.jmp_pc); print_asm(\"ret\");} rtl_pop() 1234567static inline void rtl_pop(rtlreg_t* dest) { // dest &lt;- M[esp] // esp &lt;- esp + 4 /* PA2.1 */ rtl_lm(dest, &amp;reg_l(R_ESP), 4); reg_l(R_ESP) += 4;} ret指令比较简单，就不用多讲了。 push指令 push指令的opcode是0x68还有 110001a: 68 00 00 00 00 push $0x0 opcode_table[0x68]=IDEX(push_SI, push) 123make_DHelper(push_SI) { decode_op_SI(pc, id_dest, true);} 译码函数和call类似，不过不用计算和填写jmp_pc，只需要取到立即数。 123456make_EHelper(push) { /* PA2.1 */ rtl_push(&amp;id_dest-&gt;val); print_asm_template1(push);} rtl_push已经实现过了，这样push指令也算完成了。 还有一条push的opcode是0x55，不要忘了。 xor指令 xor指令的opcode是0x31 1100010: 31 c0 xor %eax,%eax opcode_table[0x31]=IDEX(G2E, xor) 123make_DHelper(G2E) { decode_op_rm(pc, id_dest, true, id_src, true);} 123static inline void decode_op_rm(vaddr_t *pc, Operand *rm, bool load_rm_val, Operand *reg, bool load_reg_val) { read_ModR_M(pc, rm, load_rm_val, reg, load_reg_val);} read_ModR_M再读取一个ModR/M字节,0xc0拆分后mod是3代表是reg类型，reg=0代表是EAX，r/m=0代表另一个操作数也是EAX。 12345678910111213make_EHelper(xor) { /* PA2.1 */ rtl_xor(&amp;s0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val); operand_write(id_dest, &amp;s0); rtl_update_ZFSF(&amp;s0, id_dest -&gt; width); // CF = 0, OF = 0 s1 = 0; rtl_set_CF(&amp;s1); rtl_set_OF(&amp;s1); print_asm_template2(xor);} 根据手册提示，xor会把CF和OF设置为0，另外需要更新ZF和SF。 12345678910111213141516static inline void rtl_update_ZF(const rtlreg_t* result, int width) { // eflags.ZF &lt;- is_zero(result[width * 8 - 1 .. 0]) /* PA2.1 */ t0 = *result &lt;&lt; (32 - width * 8); t0 = (t0 == 0); rtl_set_ZF(&amp;t0);}static inline void rtl_update_SF(const rtlreg_t* result, int width) { // eflags.SF &lt;- is_sign(result[width * 8 - 1 .. 0]) /* PA2.1 */ t0 = (*result) &gt;&gt; (8*width-1); t0 = (t0 &amp; 1); rtl_set_SF(&amp;t0);} 需要在这里补充，如何设置符号位，首先需要到PA1里面的reg.h里面修改CPU_state的定义，增加符号位寄存器，并且我们只需要关心其中的CF,ZF,SF,IF,OF。 123456789101112131415161718192021222324252627282930313233typedef struct { union{ union{ uint32_t _32; uint16_t _16; uint8_t _8[2]; } gpr[8]; struct{ rtlreg_t eax, ecx, edx, ebx, esp, ebp, esi, edi; }; }; /* Do NOT change the order of the GPRs' definitions. */ /* In NEMU, rtlreg_t is exactly uint32_t. This makes RTL instructions * in PA2 able to directly access these registers. */ vaddr_t pc; /* PA2.1 */ union{ struct{ uint32_t CF:1; uint32_t :5; uint32_t ZF:1; uint32_t SF:1; uint32_t :1; uint32_t IF:1; uint32_t :1; uint32_t OF:1; }eflags; uint32_t eflags_value; };} CPU_state; 这里要提醒一句，这里的结构体定义中，寄存器的顺序是不能随意改变的，要保证和qemu一致，否则后面的diff-test过不了： 顺便增加一条宏方便使用： 1#define reg_f(flag) (cpu.eflags.flag) 然后到rtl.h修改set/get代码 1234567#define make_rtl_setget_eflags(f) \\ static inline void concat(rtl_set_, f) (const rtlreg_t* src) { \\ reg_f(f) = *src; \\ } \\ static inline void concat(rtl_get_, f) (rtlreg_t* dest) { \\ *dest = reg_f(f); \\ } sub指令 sub指令的opcode=0x83 1100017: 83 ec 14 sub $0x14,%esp opcode_table已经填好了这一项 IDEX(SI2E, gp1) 译码函数已经写好，直接看执行函数exec_gp1，首先我们需要看exec.c文件里面 12345678910111213#define make_group(name, item0, item1, item2, item3, item4, item5, item6, item7) \\ static OpcodeEntry concat(opcode_table_, name) [8] = { \\ /* 0x00 */ item0, item1, item2, item3, \\ /* 0x04 */ item4, item5, item6, item7 \\ }; \\static make_EHelper(name) { \\ idex(pc, &amp;concat(opcode_table_, name)[decinfo.isa.ext_opcode]); \\}/* 0x80, 0x81, 0x83 */make_group(gp1, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY) ext_opcode是5，因为译码的时候读了一个ModR/M字节0xec，其中3-5位作为ext_opcode，上面这一段可以翻译为 123static void exec_gp1(addr_t *pc){ idex(pc, &amp;opcode_table_gp1[decinfo.isa.ext_opcode]);} 也就是说又进行了一次译码，执行。因为ext_opcode是5，先把sub真正的执行函数填写进make_group 1234/* 0x80, 0x81, 0x83 */make_group(gp1, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EX(sub), EMPTY, EMPTY) SUB指令涉及到CF,OF,SF,ZF的更新： 123456789101112131415make_EHelper(sub) { /* PA2.1 */ rtl_sub(&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val); operand_write(id_dest,&amp;s0); // update ZF SF rtl_update_ZFSF(&amp;s0,id_dest-&gt;width); // update CF rtl_is_sub_carry(&amp;s1,&amp;s0,&amp;id_dest-&gt;val); rtl_set_CF(&amp;s1); // update OF rtl_is_sub_overflow(&amp;s1,&amp;s0,&amp;id_dest-&gt;val,&amp;id_src-&gt;val,id_dest-&gt;width); rtl_set_OF(&amp;s1); print_asm_template2(sub);} CF的判断比较简单： 123456static inline void rtl_is_sub_carry(rtlreg_t* dest, const rtlreg_t* res, const rtlreg_t* src1) { // dest &lt;- is_carry(src1 - src2) /* PA2.1 */ *dest = (*res &gt; *src1);} OF的判断标准是x与y异号，同时(x-y)与x异号： 123456789101112131415static inline void rtl_is_sub_overflow(rtlreg_t* dest, const rtlreg_t* res, const rtlreg_t* src1, const rtlreg_t* src2, int width) { // dest &lt;- is_overflow(src1 - src2) /* PA2.1 */ t0 = ((*src1)&gt;&gt;(8*width-1)) &amp; 1; t1 = ((*src2)&gt;&gt;(8*width-1)) &amp; 1; rtl_xor(&amp;t1,&amp;t0,&amp;t1); if(t1==0) *dest=0; else{ t1=((*res)&gt;&gt;(8*width-1)) &amp; 1; rtl_xor(&amp;t0,&amp;t0,&amp;t1); *dest = t0; }} 最后不要忘记在all-instr.h里面加上你声明的函数。 PA2.1到此为止 PA2.2 一上来先把tests里面的测试用例都要做了，这真没办法，一个个的实现，从add.c开始，这里我不可能再分步细说如何去做，步骤和PA2.1其实都一样，个别特殊的指令我会提一下，其他的（其实全部）都可以去看代码读明白。 sete指令 这是一条双字节opcode的指令，指令的格式如下 120F 94 SETE r/m8 4/5 Set byte if equal (ZF=1)//IF condition THEN r/m8 := 1 ELSE r/m8 := 0; FI; opcode_table[0x0f]=EX(2byte_esc) 123456static make_EHelper(2byte_esc) { uint32_t opcode = instr_fetch(pc, 1) | 0x100; decinfo.opcode = opcode; set_width(opcode_table[opcode].width); idex(pc, &amp;opcode_table[opcode]);} 可见，需要再读入一个字节，然后以0x100+读入的字节作为索引重新搜索opcode_table。 另外根据第2个字节的低4位确定condition： 1234567bool invert = subcode &amp; 0x1; enum { CC_O, CC_NO, CC_B, CC_NB, CC_E, CC_NE, CC_BE, CC_NBE, CC_S, CC_NS, CC_P, CC_NP, CC_L, CC_NL, CC_LE, CC_NLE }; 需要完成cc.c文件里面的rtl_setcc()。 sprintf 按照手册提示，在这些测试文件中，string.c和hello-str.c需要实现常用的字符串库函数还有printf和sprintf，字符串库函数就不说了，大一的时候就经常做了。这里主要说下sprintf的实现。 在开始之前我要先说一些我在抄代码的时候发现的问题，我做实验的时候参考了2个github的代码，我抄的时候也会相互借鉴，有些地方我觉得可以改善的也会自己修改，因此会有些不同，我相信如果有人抄我代码的时候也不会无脑全抄吧。但是就是这细微的差别我发现使得我和github上面的opcode_table不一样，我来从头到尾讲一下，首先是对于sprintf的实现，其中%d的实现，我觉得其中一个人的不太好，开了个定长数组再倒叙输出数字，于是我选择了使用指针在原字符串的基础上进行倒叙，就不受长度限制了。但是我本来抄他的代码hit good trap了，也就是通过了测试，但是在我修改完sprintf的实现后，突然就告诉我有未实现的汇编指令，然后我打开反汇编一看，确实有一条我没有实现的汇编指令，然后我去看GitHub的opcode_table，发现他也没有实现，我又把代码抄回去，试了下他的代码，然后还是hit good trap了，我马上对比了一下反汇编结果，发现他的反汇编与我的反汇编是不一样的，他没有这条指令，也就是说，根据你对于sprintf的实现，你的反汇编结果是不一样的，要实现的汇编指令也不一定相同，因此如果你抄我的代码，但是又想修改，那你也有可能要加新的汇编指令。 接下来我们具体说下如何实现sprintf： 首先有必要了解下变长参数的原理，对va_list和va_start,va_end,va_arg的用法了解，可以自行上网搜索原理和用法，我看到的这篇博客感觉还可以理解可变参数va_list、va_start、va_arg、va_end原理及使用方法 刚好博客里面也有%d,%s的实现，我这里也就不用多说了，省点字:) diff-test 很烦，这里我犯了一个蠢，所以我要先写在前面，不过我觉得应该没有多少人会和我一样:(，因为我觉得PA0不重要，就直接从PA1开始，结果我在这里diff-test就突然报错，好像是什么东西没装，我就感觉是自己环境配置有问题，然后反思了好久，最后想起来自己PA0没做，不会 PA0里面有什么关键的东西我没有装吧，然后一看果然diff-test最关键的qemu我没装:( 当然如果你是用的老师给的镜像装的话就不用管了，我现在也明白了，老师给的就是已经做好了PA0，把里面的工具环境都配置好的结果，谁让我不知道为啥非要从0开始。 回到正题，从手册可以知道，diff-test的方法是将自己的nemu作为ref，然后与qemu的执行一条一条比对从而及时发现错误，整个diff-test的代码大部分已经实现，唯一留给我们实现的只有x86/diff-test.c里面的isa_difftest_checkregs()，也就是对寄存器的状态进行比对，如果有一个寄存器的值不一致就返回false，否则返回true。代码倒是很简单，（而且手册说的顺序问题，反正抄就完事了）： 12345678910bool isa_difftest_checkregs(CPU_state *ref_r, vaddr_t pc) { /* PA2.2 */ if (ref_r-&gt;eax != reg_l(R_EAX) || ref_r-&gt;ebx != reg_l(R_EBX) || ref_r-&gt;ecx != reg_l(R_ECX) || ref_r-&gt;edx != reg_l(R_EDX) || ref_r-&gt;ebp != reg_l(R_EBP) || ref_r-&gt;esi != reg_l(R_ESI) || ref_r-&gt;edi != reg_l(R_EDI) || ref_r-&gt;pc != cpu.pc ) { return false; } return true;} 在common.h里面将#define DIFF_TEST注释关掉，然后再nemu目录下执行bash runall.sh ISA=x86，反正我一次就全过了。 PA2.3 串口 做法与PA2.2是差不多的，不过这里要实现IO的辅助函数，先去common.h中把HAS_IOE宏打开，然后按照手册的提示进行测试，会发现要求实现out指令。out的执行辅助函数实现如下： 1234567891011make_EHelper(out) { //TODO(); switch(id_src-&gt;width){ case 1:pio_write_b(id_dest-&gt;val,id_src-&gt;val);break; case 2:pio_write_w(id_dest-&gt;val,id_src-&gt;val);break; case 4:pio_write_l(id_dest-&gt;val,id_src-&gt;val);break; default:break; } print_asm_template2(out);} in的也类似，这里也一起给出吧 123456789101112make_EHelper(in) { //TODO(); switch(id_src-&gt;width){ case 1:s0=pio_read_b(id_src-&gt;val);break; case 2:s0=pio_read_w(id_src-&gt;val);break; case 4:s0=pio_read_l(id_src-&gt;val);break; default:break; } operand_write(id_dest,&amp;s0); print_asm_template2(in);} asm volatile 在进行下个阶段前，我觉得有必要先了解内嵌汇编语法，详细的请自行搜索了解，我给出一篇我觉得讲的不错的asm volatile GCC的内嵌汇编语法 AT&amp;T汇编语言语法 然后我总结一下 基本内联汇编的格式是 1__asm__ __volatile__(\"Instruction List\"); Instruction List是汇编指令序列，可以为空。 而在PA里面我们见到的更多的是带有C/C++表达式的内联汇编格式： 1__asm__ __volatile__(\"Instruction List\" : Output : Input : Clobber/Modify); 两种格式对寄存器语法的要求不同：基本格式要求寄存器前只能使用一个百分号(%)，这一点和非内联汇编相同；而带有C/C++表达式格式则要求寄存器前必须使用两个百分号(%%)。 output Output用来指定当前内联汇编语句的输出。来看一个例子： 1__asm__(\"movl %%cr0, %0\": \"=a\" (cr0)); 这个输出操作由两部分组成：括号括住的部分(cr0)和引号引住的部分\"=a\"。括号括住的部分是一个C/C++表达式，用来保存内联汇编的一个输出值，其操作就等于C/C++的相等赋值cr0 = output_value，因此，括号中的输出表达式只能是C/C++的左值表达式。 引号中的内容，被称作“操作约束”（Operation Constraint），在这个例子中操作约束为\"=a\"，它包含两个约束：等号(=)和字母a，其中等号(=)说明括号中左值表达式cr0是一个 Write-Only的，只能够被作为当前内联汇编的输入，而不能作为输入。而字母a是寄存器EAX / AX / AL的简写，说明cr0的值要从eax寄存器中获取，也就是说cr0 = eax，最终这一点被转化成汇编指令就是movl %eax, address_of_cr0。 GCC的文档中声明等号(=)约束说明当前的表达式是一个 Write-Only的，加号(+)用来说明当前表达式是一个Read-Write的，如果一个操作约束中没有给出这两个符号中的任何一个，则说明当前表达式是Read-Only的。 input input域的内容用来指定当前内联汇编语句的输入。还是举个例子： 1__asm__(\"movl %0, %%db7\" : : \"a\" (cpu-&gt;db7)); 像输出表达式一样，一个输入表达式也分为两部分：带括号的部分(cpu-&gt;db7)和带引号的部分\"a\"。括号中的表达式cpu-&gt;db7是一个C/C++语言的表达式，它不必是一个左值表达式，也就是说它不仅可以是放在C/C++赋值操作左边的表达式，还可以是放在C/C++赋值操作右边的表达式。 引号号中的部分是约束部分，和输出表达式约束不同的是，它不允许指定加号(+)约束和等号(=)约束，也就是说它只能是默认的Read-Only的。约束中必须指定一个寄存器约束，例中的字母a表示当前输入变量cpu-&gt;db7要通过寄存器eax输入到当前内联汇编中。 占位符 一个带有C/C++表达式的内联汇编，其操作表达式被按照被列出的顺序编号，第一个是0，第2个是1，依次类推，GCC最多允许有10个操作表达式。举个例子： 123__asm__ (\"addl %1, %0/n/t\": \"=a\"(__out): \"m\" (__in1), \"a\" (__in2)); 这个例子中的%0和%1就是占位符。每一个占位符对应一个Input/Output操作表达式。我们在之前已经提到，GCC规定一个内联汇编语句最多可以有 10个Input/Output操作表达式，然后按照它们被列出的顺序依次赋予编号0到9。对于占位符中的数字而言，和这些编号是对应的。 由于占位符前面使用一个百分号(%)，为了区别占位符和寄存器，GCC规定在带有C/C++表达式的内联汇编中，\"Instruction List\"中直接写出的寄存器前必须使用两个百分号(%%)。 以PA中的具体例子来分析一下 12345static inline uint32_t inl(int port) { uint32_t data; asm volatile (\"inl %1, %0\" : \"=a\"(data) : \"d\"((uint16_t)port)); return data;} Instruction List是inl %1, %0 ，其中%1指代\"d\"((uint16_t)port)也就是dx，%0指代\"=a\"(data)也就是eax，最后输入的来源是port变量，输出的值保存在了data中。 时钟 根据手册说明，我们可以从RTC寄存器中获取当前时间，在x86.h中找到其地址的宏是RTC_ADDR，也就是说我们可以使用前面介绍的inl()函数，inl(RTC_ADDR)来获取当前时间的值，单位是ms。 我们要先实现的只有_DEVREG_TIMER_UPTIME，AM系统启动时间. 从中读出_DEV_TIMER_UPTIME_t结构体, (hi &lt;&lt; 32LL) | lo是系统启动的毫秒数。 思路很简单，首先设置一个全局变量st_time，在__am_timer_init()中调用inl(RTC_ADDR)获取启动时间，保存在st_time中，然后在__am_timer_read中再读取一次时间，求出差值，就去AM的启动时间，然后按照手册说的格式保存在_DEV_TIMER_UPTIME_t结构体中。代码如下： 123uint64_t time = inl(RTC_ADDR)-st_time;uptime-&gt;hi = (uint32_t)(time&gt;&gt;32);uptime-&gt;lo = (uint32_t)(time &amp; 0xffffffff); 完成时钟以后可以去按照手册说的测试nemu能跑多快，我microbench的跑分是374（感觉一般，放出来给大家一个参考），不过跑测试的时候会发现，其实仍然有许多指令没有完成，方法和PA2.2一样继续完善。但是有个指令我要单独说一下。 rol指令，为什么要单独说这个指令，因为他的辅助函数logic.c中没找到，但是确实用到了rol指令，我不知道是不是老师忘了，而且给的i386指令集里面也没找到，所以我这里需要说一下。 rol指令的功能是循环左移，将dest里面的数据循环左移src次，最后一次从左边移出去的最高位设置CF，如果src=1，就是只循环左移了一次，并且循环左移后的数据与原本的数据异号，则设置OF=1。如果src&gt;1，则OF没有意义。在logic.c加入rol的辅助函数代码如下： 123456789101112131415161718make_EHelper(rol) { s0 = id_dest -&gt; val; int i; for(i = 0; i &lt; id_src -&gt; val; ++ i) { rtl_msb(&amp;s1, &amp;s0, id_dest-&gt;width); s0 = s0 &lt;&lt; 1; s0 |= s1; rtl_set_CF(&amp;s1); } operand_write(id_dest, &amp;s0); if(id_src -&gt; val == 1){ rtl_msb(&amp;s0, &amp;s0, id_dest-&gt;width); s0 ^= s1; rtl_set_CF(&amp;s0); } print_asm_template2(rol); } 键盘 键盘的地址是KBD_ADDR，用inl(KBD_ADDR)获取键盘码，使用掩码KEYDOWN_MASK(0X8000)判断是按下还是松开，然后将键盘码保存在keycode中，代码如下： 1234/* PA2.3 */ uint32_t key=inl(KBD_ADDR); kbd-&gt;keydown = key &amp; KEYDOWN_MASK ? 1 : 0; kbd-&gt;keycode = key; 这样就算完成了，不过还是可以看看手册里面说的MAP宏 12345678#define MAP(c, f) c(f)enum { _KEY_NONE = 0, MAP(_KEYS, _KEY_NAME)};#define _KEY_NAME(k) _KEY_##k, 再结合下面的图 一层层拆开宏，最后的结果就是在enum中，按图中的键盘顺序为枚举了每个键盘号。算是学到了一种方法。 VGA 根据手册说明，宽高是400×300不变，所以__am_video_read中，宽高是常数。 在__am_video_write中由传入参数buf指向一个_DEV_VIDEO_FBCTL_t结构体，其成员变量x和y指示起始坐标，w和h指示要绘制的宽高，pixels是一个行优先存储像素RGBA的数组。我们要做的是在FB_ADDR开始的一片内存中找到上述起始坐标开始的位置然后填入w*h个像素。代码如下： 12345678910_DEV_VIDEO_FBCTL_t *ctl = (_DEV_VIDEO_FBCTL_t *)buf; int x=ctl-&gt;x,y=ctl-&gt;y,h=ctl-&gt;h,w=ctl-&gt;w; uint32_t *pixels = ctl-&gt;pixels; uint32_t *fb=(uint32_t *)(uintptr_t)FB_ADDR; for(int i=0;i&lt;h;i++){ for(int j=0;j&lt;w;j++){ fb[(y+i)*W+x+j]=pixels[i*w+j]; } } 然后在vga.c中，将控制更新屏幕的代码填上： 1234567static void vga_io_handler(uint32_t offset, int len, bool is_write) { // TODO: call `update_screen()` when writing to the sync register /* PA2.3 */ if(is_write){ update_screen(); }} PA2.3就算做完了，输入和输出的代码量很少，主要还是PA2.2工作量比较大，然后PA2.3测试的时候发现居然还有很多指令需要实现，然后又回去填opocde_table很烦。 PA3 我很想吐槽x86后面不都是5星难度了吗，为什么还是感觉比其他指令复杂。 PA 3.1 设置异常入口地址 PA3.1要求实现x86的中断指令int，首先需要认真阅读手册，理解x86的异常响应机制和中断描述符表，大概总结一下。 IDT（中断描述符表）是一个数组，每个元素是一个门描述符，门描述符是一个8字节结构体，简化以后，就只有存在位和异常入口地址这两个重要信息。在_cte_init（cte.c）中创建了一个idt数组： 123456789101112131415161718192021int _cte_init(_Context*(*handler)(_Event, _Context*)) { static GateDesc idt[NR_IRQ]; // initialize IDT for (unsigned int i = 0; i &lt; NR_IRQ; i ++) { idt[i] = GATE(STS_TG32, KSEL(SEG_KCODE), __am_vecnull, DPL_KERN); } // ----------------------- interrupts ---------------------------- idt[32] = GATE(STS_IG32, KSEL(SEG_KCODE), __am_irq0, DPL_KERN); // ---------------------- system call ---------------------------- idt[0x80] = GATE(STS_TG32, KSEL(SEG_KCODE), __am_vecsys, DPL_USER); idt[0x81] = GATE(STS_TG32, KSEL(SEG_KCODE), __am_vectrap, DPL_KERN); set_idt(idt, sizeof(idt)); // register event handler user_handler = handler; return 0;} 设置好IDT以后，要将IDT的地址和长度保存在特殊的寄存器IDTR中，也就是set_idt(idt, sizeof(idt))的任务： 1234567static inline void set_idt(GateDesc *idt, int size) { volatile static uint16_t data[3]; data[0] = size - 1; data[1] = (uint32_t)idt; data[2] = (uint32_t)idt &gt;&gt; 16; asm volatile (\"lidt (%0)\" : : \"r\"(data));} 我们需要实现lidt指令，其源操作数指出了长度和地址的信息所在内存地址，一共是3个双字，第一个双字是长度，后面2个双字是地址，我们需要将这些信息存储在idtr寄存器中，因此首先我们需要修改reg.h文件里面对CPU_state的定义： 12345/* PA3 */ struct{ uint16_t limit; uint32_t base; }idtr; 增加一个idtr结构体成员变量到CPU_state中。 然后我们就可以实现lidt的辅助函数了： 1234567891011make_EHelper(lidt) { cpu.idtr.limit = vaddr_read(id_dest-&gt;addr,2); if(decinfo.isa.is_operand_size_16){ cpu.idtr.base = vaddr_read(id_dest-&gt;addr+2,4) &amp;&amp; 0x00ffffff; }else{ cpu.idtr.base = vaddr_read(id_dest-&gt;addr+2,4); } print_asm_template1(lidt);} 触发自陷操作 实现raise_intr()函数，并借此实现int操作，raise_intr()完成的工作如下： 依次将eflags, cs(代码段寄存器), eip(也就是PC)寄存器的值压栈 从IDTR中读出IDT的首地址 根据异常号在IDT中进行索引, 找到一个门描述符 将门描述符中的offset域组合成异常入口地址 跳转到异常入口地址 12345678910111213141516void raise_intr(uint32_t NO, vaddr_t ret_addr) { /* TODO: Trigger an interrupt/exception with ``NO''. * That is, use ``NO'' to index the IDT. */ /* PA3.1 */ rtl_push(&amp;cpu.eflags_value); rtl_push(&amp;cpu.cs); rtl_push(&amp;ret_addr); cpu.eflags.IF = 0; vaddr_t idt_addr = cpu.idtr.base + sizeof(GateDesc)*NO; vaddr_t low_addr = vaddr_read(idt_addr,2) &amp; 0xffff; vaddr_t high_addr = vaddr_read(idt_addr+4,4) &amp; 0xffff0000; decinfo.jmp_pc = high_addr | low_addr; decinfo.is_jmp = 1; rtl_j(decinfo.jmp_pc);} cs寄存器在PA中并没有发挥作用，但仍需修改reg.h增加对其的定义。 1234567make_EHelper(int) { raise_intr(id_dest-&gt;val,decinfo.seq_pc); print_asm(\"int %s\", id_dest-&gt;str); difftest_skip_dut(1, 2);} 记得在init.c中添加初始化： 123456static void restart() { /* Set the initial program counter. */ cpu.pc = PC_START; cpu.cs = 8; cpu.eflags_value = 0x2;} 上下文保存 为了重新组织_Context结构体，需要先了解压栈顺序，执行int指令，进入raise_intr函数，eflags, cs, ret_addr依次入栈，跳转到IDT，在trap.S中，每个中断先把自己的中断号压栈，然后jmp __am_asm_trap，在 __am_asm_trap中先执行pushal指令也就是pusha： 1234567891011121314make_EHelper(pusha) { s0 = reg_l(R_ESP); rtl_push(&amp;reg_l(R_EAX)); rtl_push(&amp;reg_l(R_ECX)); rtl_push(&amp;reg_l(R_EDX)); rtl_push(&amp;reg_l(R_EBX)); rtl_push(&amp;s0); rtl_push(&amp;reg_l(R_EBP)); rtl_push(&amp;reg_l(R_ESI)); rtl_push(&amp;reg_l(R_EDI)); print_asm(\"pusha\");} 寄存器压栈顺序如上，然后pushl $0，根据手册，这是一个占位符，最后pushl %esp然后call __am_irq_handle： 1_Context* __am_irq_handle(_Context *c); 其传入参数是一个_Context指针，现在我们来看看栈的状态，如下 栈顶的esp是作为_Context指针传入，下面作为_Context结构体的成员，因此_Context结构体定义如下： 123456struct _Context { struct _AddressSpace *as; uintptr_t edi, esi, ebp, esp, ebx, edx, ecx, eax; int irq; uintptr_t eip,cs,eflags;}; 事件分发 首先在__am_irq_handle加入switch case为event赋值，暂时只用到yield事件，其他两个也可以先加上： 123456switch (c-&gt;irq) { case 0x20:ev.event = _EVENT_IRQ_TIMER;break; case 0x80:ev.event = _EVENT_SYSCALL;break; case 0x81:ev.event = _EVENT_YIELD;break; default: ev.event = _EVENT_ERROR; break; } 然后在do_event()中添加输出信息，先输出Log，之后会修改： 12345678static _Context* do_event(_Event e, _Context* c) { switch (e.event) { case _EVENT_YIELD: Log(\"yield event\");break; case _EVENT_SYSCALL: return do_syscall(c);break; default: panic(\"Unhandled event ID = %d\", e.event); } return NULL;} 恢复上下文 实现popa指令和iret指令，记得按照一定顺序： 12345678910111213make_EHelper(popa) { rtl_pop(&amp;cpu.edi); rtl_pop(&amp;cpu.esi); rtl_pop(&amp;cpu.ebp); rtl_pop(&amp;s0); rtl_pop(&amp;cpu.ebx); rtl_pop(&amp;cpu.edx); rtl_pop(&amp;cpu.ecx); rtl_pop(&amp;cpu.eax); print_asm(\"popa\");} 12345678910make_EHelper(iret) { rtl_pop(&amp;decinfo.jmp_pc); rtl_pop(&amp;cpu.cs); rtl_pop(&amp;cpu.eflags_value); rtl_j(decinfo.jmp_pc); print_asm(\"iret\");} PA3.2 实现loader loader后面还要重新修改，第一次不用管输入参数，只用ramdisk_read和ramdisk_write实现： 1234567891011121314151617181920212223static uintptr_t loader(PCB *pcb, const char *filename) { Elf_Ehdr elfheader; Elf_Phdr programheader; size_t offset = 0; size_t p_offset = 0; size_t len = (size_t)sizeof(Elf_Ehdr); ramdisk_read(&amp;elfheader,offset,len); offset = elfheader.e_phoff; for (uint16_t i=0; i&lt;elfheader.e_phnum; i++){ ramdisk_read(&amp;programheader,offset,(size_t)sizeof(Elf_Phdr)); offset+=sizeof(Elf_Phdr); if(programheader.p_type == PT_LOAD){ uint8_t buf[programheader.p_filesz]; ramdisk_read(&amp;buf,programheader.p_offset,programheader.p_filesz); memcpy((void*)programheader.p_vaddr,&amp;buf,programheader.p_filesz); memset((void*)(programheader.p_vaddr+programheader.p_filesz),0,(programheader.p_memsz-programheader.p_filesz)); } } return elfheader.e_entry;} loader的作用是把程序加载到指定内存位置，根据手册说明，一开始dummy的ELF头部文件在偏移为0的位置，从elf头部信息中提取出e_phoff和e_phnum，也就是程序头部偏移位置和个数，接下来从这个位置开始连续读e_phnum次。 从程序头部信息中提取5个重要的成员，第1个是p_type，程序类型，只有当值为PT_LOAD的时候，我们才加载这个头部对应的程序。第2个是p_offset，他指示我们这个头部对应的程序的偏移地址。第3个是p_vaddr，他指示我们应该将程序拷贝到的目的地址，剩下2个成员是p_filesz和p_memsz，分别是文件大小和内存大小。 根据手册说明，我们需要把p_offset开始的p_filesz个字节的程序拷贝到从p_vaddr开始的内存中，另外还需要将p_vaddr+p_filesz到p_vaddr+p_memsz结束的内存设置为0。 12345678void init_proc() { switch_boot_pcb(); Log(\"Initializing processes...\"); // load program here naive_uload(NULL, NULL);} 测试结果应该是触发了一个1号系统调用，显示 1Unhandled syscall ID = 1 系统调用 首先在x86-nemu.h中声明几个系统调用有关的宏： 12345#define GPR1 eax#define GPR2 ebx#define GPR3 ecx#define GPR4 edx#define GPRx eax 在do_event函数中调用do_syscall(c)传递上下文处理系统调用。 在syscall.c中补全do_syscall的switch-case： 1234567891011121314151617_Context* do_syscall(_Context *c) { uintptr_t a[4]; a[0] = c-&gt;GPR1; a[1] = c-&gt;GPR2; a[2] = c-&gt;GPR3; a[3] = c-&gt;GPR4; int result = -1; switch (a[0]) { case SYS_exit: sys_exit(a[1]);break; case SYS_yield: result=sys_yield();break; case SYS_write: result = sys_write(a[1],(void*)a[2],a[3]);break; case SYS_brk: result=sys_brk(a[1]);break; default: panic(\"Unhandled syscall ID = %d\", a[0]); } c-&gt;GPRx=result; return NULL;} 目前只要补充SYS_exit和SYS_yield，其他的马上要做 12345678int sys_yield(){ _yield(); return 0;}void sys_exit(uintptr_t arg){ _halt(arg);} 运行dummy进行测试，成功hit good trap说明实现完成 标准输出 添加sys_write系统调用： 12345678size_t sys_write(int fd,const void *buf,size_t count){ if(fd==1||fd==2){ for(int i=0;i&lt;count;i++){ _putc(((char *)buf)[i]); } } return count;} 另外不要忘记在navy-apps/libs/libos/src/nanos.c的_write()中调用系统调用接口函数，我就是没仔细看手册，漏了这句话，还去调试了半天，很难受 123int _write(int fd, void *buf, size_t count) { return _syscall_(SYS_write,fd,buf,count);} 堆区管理 因为暂时不用实现具体的内存分配，所以按照手册说的只需要系统调用的时候返回0表示成功即可： 123int sys_brk(uintptr_t increment){ return 0;} 接口方面，按照手册说明的流程做 program break一开始的位置位于_end 被调用时, 根据记录的program break位置和参数increment, 计算出新program break 通过SYS_brk系统调用来让操作系统设置新program break 若SYS_brk系统调用成功, 该系统调用会返回0, 此时更新之前记录的program break的位置, 并将旧program break的位置作为_sbrk()的返回值返回 若该系统调用失败, _sbrk()会返回-1 123456789void *_sbrk(intptr_t increment) { static void* program_break = (uintptr_t)&amp;_end; void* old = program_break; if(_syscall_(SYS_brk,(uintptr_t)(program_break+increment),0,0)==0){ program_break+=increment; return(void*)old; } return (void *)-1;} PA3.3 loader使用文件 要求实现一个简单的文件系统，这一步要实现fs_open(), fs_read()和fs_close() fs_close()只要return 0即可 fs_open()要用传入的文件名与file_table中的文件名一一比对，返回找到的下标，并设置open_offset 1234567891011int fs_open(const char *pathname, int flags, int mode){ for(int i=0;i&lt;NR_FILES;i++){ if(strcmp(file_table[i].name,pathname)==0){ file_table[i].open_offset=0; return i; } } printf(\"file %s does not exist!\",pathname); assert(0); return -1;} fs_read()要注意如果文件剩余大小不足len，要更改读的大小，对于stdin, stdout和stderr这三个特殊文件的操作可以直接忽略。其他的使用ramdisk_read进行读操作，并更新open_offset 12345678910111213141516171819202122size_t fs_read(int fd, void *buf, size_t len){ assert(fd &gt;= 0 &amp;&amp; fd &lt; NR_FILES); int r_len = len; if(file_table[fd].size &gt; 0 &amp;&amp; file_table[fd].open_offset + len &gt; file_table[fd].size) { r_len = file_table[fd].size - file_table[fd].open_offset; } assert(r_len &gt;= 0); size_t length = 0; switch (fd) { case FD_STDIN: case FD_STDOUT: case FD_STDERR: break; default: length=ramdisk_read(buf,file_table[fd].disk_offset+file_table[fd].open_offset,r_len); file_table[fd].open_offset += length; break; } return length;} 这里额外实现一个返回disk_offset的函数方便loader使用，后面实现了lseek以后可以删掉 123size_t fs_disk_offset(int fd){ return file_table[fd].disk_offset;} 记得在nanos.c实现接口 修改loader函数，注意地址要加上文件的disk_offset 12345678910111213141516171819202122232425static uintptr_t loader(PCB *pcb, const char *filename) { Elf_Ehdr elfheader; Elf_Phdr programheader; int fd = fs_open(filename,0,0); assert(fd!=-1); fs_read(fd,&amp;elfheader,sizeof(Elf_Ehdr)); size_t offset = 0; size_t p_offset = 0; offset = elfheader.e_phoff+fs_disk_offset(fd); for (uint16_t i=0; i&lt;elfheader.e_phnum; i++){ ramdisk_read(&amp;programheader,offset,(size_t)sizeof(Elf_Phdr)); offset+=sizeof(Elf_Phdr); if(programheader.p_type == PT_LOAD){ uint8_t buf[programheader.p_filesz]; p_offset = programheader.p_offset + fs_disk_offset(fd); ramdisk_read(&amp;buf,p_offset,programheader.p_filesz); memcpy((void*)programheader.p_vaddr,&amp;buf,programheader.p_filesz); memset((void*)(programheader.p_vaddr+programheader.p_filesz),0,(programheader.p_memsz-programheader.p_filesz)); } } fs_close(fd); return elfheader.e_entry;} 修改proc.c，调用naive_uload测试dummy，然后测试hello 1naive_uload(NULL, \"/bin/hello\"); 实现完整的文件系统 用fs_read类似的方法实现fs_write 123456789101112131415161718192021222324252627282930size_t fs_write(int fd, const void *buf, size_t len){ assert(fd &gt;= 0 &amp;&amp; fd &lt; NR_FILES); int w_len = len; if(file_table[fd].size &gt; 0&amp;&amp; file_table[fd].open_offset + len &gt; file_table[fd].size) { w_len = file_table[fd].size - file_table[fd].open_offset; } assert(w_len &gt;= 0); size_t length = 0; switch (fd) { case FD_STDIN: break; case FD_STDOUT: case FD_STDERR: { for(int i=0; i&lt;len; i++){ _putc(((char *)buf)[i]); length=len; } break; } default: length=ramdisk_write(buf,file_table[fd].disk_offset+file_table[fd].open_offset,w_len); file_table[fd].open_offset += length; break; } return length;} fs_lseek要实现3种情况，不过感觉只有SEEK_SET常用： 123456789101112131415161718size_t fs_lseek(int fd, size_t offset, int whence){ assert(fd &gt;= 0 &amp;&amp; fd &lt; NR_FILES); size_t open_offset = file_table[fd].open_offset; switch (whence) { case SEEK_SET: open_offset = offset; break; case SEEK_CUR: open_offset += offset; break; case SEEK_END: open_offset = file_table[fd].size + offset; break; default: panic(\"There is no such whence\"); } file_table[fd].open_offset = open_offset; return open_offset;} 实现这些以后就可以修改loader函数了，注意最开始的实现是有问题的，因为开了一个filesz的数组，但是当换成bin/text测试的时候，会出现越界的问题，数组开的过大，所以这里不要开数组，直接传vaddr的地址给fs_read即可： 123456789101112131415161718192021222324static uintptr_t loader(PCB *pcb, const char *filename) { Elf_Ehdr elfheader; Elf_Phdr programheader; int fd = fs_open(filename,0,0); assert(fd!=-1); fs_read(fd,&amp;elfheader,sizeof(Elf_Ehdr)); fs_lseek(fd,elfheader.e_phoff,SEEK_SET); size_t open_offset; for (uint16_t i=0; i&lt;elfheader.e_phnum; i++){ fs_read(fd,&amp;programheader,sizeof(Elf_Phdr)); open_offset = fs_open_offset(fd); if(programheader.p_type == PT_LOAD){ fs_lseek(fd,programheader.p_offset,SEEK_SET); fs_read(fd,(void *)programheader.p_vaddr,programheader.p_filesz); memset((void*)(programheader.p_vaddr+programheader.p_filesz),0,(programheader.p_memsz-programheader.p_filesz)); } fs_lseek(fd,open_offset,SEEK_SET); } fs_close(fd); return elfheader.e_entry;} 实现完上述文件操作以后记得补充相关的系统调用： 12345678910111213141516171819int _open(const char *path, int flags, mode_t mode) { return _syscall_(SYS_open,(uintptr_t)path,flags,mode);}int _write(int fd, void *buf, size_t count) { return _syscall_(SYS_write,fd,buf,count);}int _read(int fd, void *buf, size_t count) { return _syscall_(SYS_read,fd,(uintptr_t)buf,count);}int _close(int fd) { return _syscall_(SYS_close,fd,0,0);}off_t _lseek(int fd, off_t offset, int whence) { return _syscall_(SYS_lseek,fd,offset,whence);} 123456789101112131415161718192021_Context* do_syscall(_Context *c) { uintptr_t a[4]; a[0] = c-&gt;GPR1; a[1] = c-&gt;GPR2; a[2] = c-&gt;GPR3; a[3] = c-&gt;GPR4; int result = -1; switch (a[0]) { case SYS_exit: sys_exit(a[1]);break; case SYS_yield: result=sys_yield();break; case SYS_open: result=fs_open((char*)a[1],a[2],a[3]);break; case SYS_read: result = fs_read(a[1],(void*)a[2],a[3]);break; case SYS_write: result = fs_write(a[1],(void*)a[2],a[3]);break; case SYS_close: result = fs_close(a[1]);break; case SYS_lseek: result = fs_lseek(a[1],a[2],a[3]);break; case SYS_brk: result=sys_brk(a[1]);break; default: panic(\"Unhandled syscall ID = %d\", a[0]); } c-&gt;GPRx=result; return NULL;} 然后加载/bin/text进行测试 把设备抽象成文件 这一部分类似于在OS课设里面的做过的，将设备也看作文件，实现设备文件的读写操作。包括串口，键盘，时钟，VGA。要在fs.c中为他们设置好对应的读写函数（其中包括下面要讲的VGA设备的相关文件符号）： 1234567891011/* This is the information about all files in disk. */static Finfo file_table[] __attribute__((used)) = { {\"stdin\", 0, 0, 0, invalid_read, invalid_write}, {\"stdout\", 0, 0, 0, invalid_read, serial_write}, {\"stderr\", 0, 0, 0, invalid_read, serial_write}, {\"/dev/fb\", 0, 0, 0, invalid_read, fb_write}, {\"/dev/events\", 0, 0, 0, events_read, invalid_write}, {\"/dev/fbsync\", 0, 0, 0, invalid_read,fbsync_write}, {\"/proc/dispinfo\", 128, 0, 0, dispinfo_read,invalid_write},#include \"files.h\"}; 注意前面4个的顺序，因为之前有个enum的枚举： 1enum {FD_STDIN, FD_STDOUT, FD_STDERR, FD_FB}; 在device.c中实现对应的读写函数 首先是串口的serial_write: 123456size_t serial_write(const void *buf, size_t offset, size_t len) { for(int i=0;i&lt;len;i++){ _putc(((char *)buf)[i]); } return len;} 输入设备有键盘和时钟, 它们对系统来说本质上就是到来了一个事件. 一种简单的方式是把事件以文本的形式表现出来, 我们定义以下事件, 一个事件以换行符\\n结束: t 1234: 返回系统启动后的时间, 单位为毫秒; kd RETURN / ku A: 按下/松开按键, 按键名称全部大写, 使用AM中定义的按键名 要注意的是, 由于时钟事件可以任意时刻进行读取, 我们需要优先处理按键事件, 当不存在按键事件的时候, 才返回时钟事件, 否则用户程序将永远无法读到按键事件. 1234567891011121314151617size_t events_read(void *buf, size_t offset, size_t len) { int key = read_key(); bool down =false; if(key &amp; KEYDOWN_MASK){ key ^=KEYDOWN_MASK; down = true; } if(key != _KEY_NONE){ sprintf(buf,\"%s %s\\n\",down ? \"kd\":\"ku\",keyname[key]); } else { int time =uptime(); sprintf(buf, \"t %d\\n\", time); } return strlen(buf);} 我在实现这个的时候出了一点问题，我忘了sprintf是自己实现的，由于我自己偷懒没有实现%u格式，但是我第一次还是用了%u导致我始终无法正确写入，调试了好久。 做到这里可以先去proc.c中修改测试文件为/bin/events进行键盘和时钟的测试。 把VGA抽象成文件 在手册中已经有了具体的步骤 在init_fs()(在nanos-lite/src/fs.c中定义)中对文件记录表中/dev/fb的大小进行初始化. 1234void init_fs() { // TODO: initialize the size of /dev/fb file_table[FD_FB].size = (screen_width()*screen_height())&lt;&lt;2;} 由于每个像素是4个字节存储，所以要乘以4，也就是左移2位。 实现fb_write()(在nanos-lite/src/device.c中定义), 用于把buf中的len字节写到屏幕上offset处. 你需要先从offset计算出屏幕上的坐标, 然后调用IOE的draw_rect(). 1234567size_t fb_write(const void *buf, size_t offset, size_t len) { offset /= 4; int x= offset % screen_width(); int y= offset / screen_width(); draw_rect((uint32_t*)buf, x, y, len / 4, 1); return len;} 实现fbsync_write()(在nanos-lite/src/device.c中定义), 直接调用IOE的相应API即可. 1234size_t fbsync_write(const void *buf, size_t offset, size_t len) { draw_sync(); return len;} 在init_device()(在nanos-lite/src/device.c中定义)中将/proc/dispinfo的内容提前写入到字符串dispinfo中. 12345678void init_device() { Log(\"Initializing devices...\"); _ioe_init(); // TODO: print the string to array `dispinfo` with the format // described in the Navy-apps convention sprintf(dispinfo, \"WIDTH:%d\\nHEIGHT:%d\\n\", screen_width(), screen_height());} 实现dispinfo_read()(在nanos-lite/src/device.c中定义), 用于把字符串dispinfo中offset开始的len字节写到buf中. 12345size_t dispinfo_read(void *buf, size_t offset, size_t len) { if(len+offset&gt;strlen(dispinfo))len=strlen(dispinfo)-offset; strncpy(buf, &amp;dispinfo[offset], len); return len;} 在VFS中添加对/dev/fb, /dev/fbsync和/proc/dispinfo这三个特殊文件的支持. 这个在前面fs.c中已经加过了，请参考前一节。 让Nanos-lite加载/bin/bmptest, 如果实现正确, 你将会看到屏幕上显示Project-N的logo. 加载仙剑奇侠传 下载老师给的仙剑奇侠传资源，并放在navy-apps/fsimg/share/games/pal/目录下, 更新ramdisk之后, 在Nanos-lite中加载并运行/bin/pal 不过x86性能不高，游戏运行不是很流畅。","categories":[{"name":"课设","slug":"课设","permalink":"http://example.com/categories/%E8%AF%BE%E8%AE%BE/"}],"tags":[{"name":"课设","slug":"课设","permalink":"http://example.com/tags/%E8%AF%BE%E8%AE%BE/"},{"name":"组原","slug":"组原","permalink":"http://example.com/tags/%E7%BB%84%E5%8E%9F/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]}],"categories":[{"name":"-论文阅读笔记","slug":"论文阅读笔记","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"name":"知识图谱","slug":"知识图谱","permalink":"http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"name":"课设","slug":"课设","permalink":"http://example.com/categories/%E8%AF%BE%E8%AE%BE/"}],"tags":[{"name":"-阅读笔记 -因果 -领域泛化","slug":"阅读笔记-因果-领域泛化","permalink":"http://example.com/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%9B%A0%E6%9E%9C-%E9%A2%86%E5%9F%9F%E6%B3%9B%E5%8C%96/"},{"name":"课设","slug":"课设","permalink":"http://example.com/tags/%E8%AF%BE%E8%AE%BE/"},{"name":"组原","slug":"组原","permalink":"http://example.com/tags/%E7%BB%84%E5%8E%9F/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]}