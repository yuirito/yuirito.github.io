<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yuirito&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-15T02:18:18.675Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yuirito</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论文笔记-A Unified Architecture for Accelerating Distributed DNN Training in Heterogeneous GPU or CPU Clusters</title>
    <link href="http://example.com/2021/11/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-A-Unified-Architecture-for-Accelerating-Distributed-DNN-Training-in-Heterogeneous-GPU-or-CPU-Clusters/"/>
    <id>http://example.com/2021/11/15/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-A-Unified-Architecture-for-Accelerating-Distributed-DNN-Training-in-Heterogeneous-GPU-or-CPU-Clusters/</id>
    <published>2021-11-15T02:16:50.000Z</published>
    <updated>2021-11-15T02:18:18.675Z</updated>
    
    
    
    
    <category term="论文笔记" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统 分布式" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>动态知识图谱补全</title>
    <link href="http://example.com/2021/11/03/%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8/"/>
    <id>http://example.com/2021/11/03/%E5%8A%A8%E6%80%81%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E8%A1%A5%E5%85%A8/</id>
    <published>2021-11-03T08:33:32.000Z</published>
    <updated>2021-11-05T04:23:36.534Z</updated>
    
    <content type="html"><![CDATA[<p>由于今天本来准备上课讲的，结果因为时间原因没讲成，很难受，和lyyy聊了以后，决定重新开始写博客做一些成长记录，刚好今天这个报告就可以作为一个新的开始。</p><h1 id="动态知识图谱补全"><a href="#动态知识图谱补全" class="headerlink" title="动态知识图谱补全"></a>动态知识图谱补全</h1><p>虽然标题叫做动态知识图谱补全，但是我今天的报告本来只打算做最近看的4篇论文，不过不知道未来会不会继续看，到时候可以继续加进这个博客里面。</p><h2 id="动态知识图谱的概念和定义"><a href="#动态知识图谱的概念和定义" class="headerlink" title="动态知识图谱的概念和定义"></a>动态知识图谱的概念和定义</h2><p>动态知识图谱是相对静态知识图谱而言的，传统的基于三元组$(s,r,o)$的知识图谱被称为静态知识图谱，但是由于事实会随着时间发生改变，所以引入了时间维度描述该事实成立的一个时间范围，有的动态知识图谱会给每个事实增加一个开始和结束时间戳，这样变成了五元组，但是我看到的大多数动态知识推理方法还是基于增加一个时间戳t形成四元组$(s,r,o,t)$。通常情况下这个时间戳t代表了一段时间，比如RE-NET论文中ICEWS14数据集，每个样本的t持续范围是24小时。然后还有一个值得一提的地方就是动态知识图谱(Dynamic Knowledge Graph)也可以称为时序知识图谱(Temporal Knowledge Graph, TKG)。这里从DEEMB的论文中给出一个TKG的形式化定义：</p><p>$\textbf{时序知识图谱（补全）：}$用$\mathcal{V}$表示实体的一个有限集合，$\mathcal{R}$表示关系类型的一个有限集合，并且用$\mathcal{T}$表示时间戳的一个有限集合。$\mathcal{W} \subset \mathcal{V} \times \mathcal{R} \times \mathcal{V} \times \mathcal{T} $ 表示事实四元组$(s,r,o,t)$的一个有限集合，其中$s,o \in \mathcal{V}, r \in \mathcal{R}, t \in \mathcal{T} $。 一个时序知识图谱$\mathcal{G}$是 $\mathcal{W}$的子集，即$\mathcal{G} \subset \mathcal{W} $。时序知识图谱补全问题可以描述为从$\mathcal{G}$中推理$\mathcal{W}$。</p><p>其实简单来说还是从已有的事实推理潜在的事实，只不过现在加上了时间维度罢了。</p><h2 id="TAE-ILP模型"><a href="#TAE-ILP模型" class="headerlink" title="TAE-ILP模型"></a>TAE-ILP模型</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于今天本来准备上课讲的，结果因为时间原因没讲成，很难受，和lyyy聊了以后，决定重新开始写博客做一些成长记录，刚好今天这个报告就可以作为一个新的开始。&lt;/p&gt;
&lt;h1 id=&quot;动态知识图谱补全&quot;&gt;&lt;a href=&quot;#动态知识图谱补全&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="知识图谱" scheme="http://example.com/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
  </entry>
  
  <entry>
    <title>ics2019 pa</title>
    <link href="http://example.com/2020/11/03/ics2019%20pa/"/>
    <id>http://example.com/2020/11/03/ics2019%20pa/</id>
    <published>2020-11-03T05:21:06.000Z</published>
    <updated>2021-11-05T04:23:36.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h1><p>PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下</p><table><thead><tr><th>命令</th><th align="left">格式</th><th align="left">使用举例</th><th>说明</th></tr></thead><tbody><tr><td>帮助(1)</td><td align="left"><code>help</code></td><td align="left"><code>help</code></td><td>打印命令的帮助信息</td></tr><tr><td>继续运行(1)</td><td align="left"><code>c</code></td><td align="left"><code>c</code></td><td>继续运行被暂停的程序</td></tr><tr><td>退出(1)</td><td align="left"><code>q</code></td><td align="left"><code>q</code></td><td>退出NEMU</td></tr><tr><td>单步执行</td><td align="left"><code>si [N]</code></td><td align="left"><code>si 10</code></td><td>让程序单步执行<code>N</code>条指令后暂停执行, 当<code>N</code>没有给出时, 缺省为<code>1</code></td></tr><tr><td>打印程序状态</td><td align="left"><code>info SUBCMD</code></td><td align="left"><code>info r</code> <code>info w</code></td><td>打印寄存器状态 打印监视点信息</td></tr><tr><td>表达式求值</td><td align="left"><code>p EXPR</code></td><td align="left"><code>p $eax + 1</code></td><td>求出表达式<code>EXPR</code>的值, <code>EXPR</code>支持的 运算请见<a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2019/1.6.html">调试中的表达式求值</a>小节</td></tr><tr><td>扫描内存(2)</td><td align="left"><code>x N EXPR</code></td><td align="left"><code>x 10 $esp</code></td><td>求出表达式<code>EXPR</code>的值, 将结果作为起始内存 地址, 以十六进制形式输出连续的<code>N</code>个4字节</td></tr><tr><td>设置监视点</td><td align="left"><code>w EXPR</code></td><td align="left"><code>w *0x2000</code></td><td>当表达式<code>EXPR</code>的值发生变化时, 暂停程序执行</td></tr><tr><td>删除监视点</td><td align="left"><code>d N</code></td><td align="left"><code>d 2</code></td><td>删除序号为<code>N</code>的监视点</td></tr></tbody></table><p>备注:</p><ul><li><p>(1) 命令已实现</p></li><li><p>(2) 与GDB相比, 我们在这里做了简化, 更改了命令的格式</p></li></ul><p>之后再具体说明上述命令如何实现，先看下PA1需要修改的文件，见下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/11/03/ics2019%20pa/pa1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其中ui.c是主要的交互界面代码，进入主循环后，用户输入的命令在这个文件里面进行解析，再分类处理，PA1.1也是从这里开始，主要增加一些命令，后面PA1.1再详述，包括对reg.c文件的修改。</p><p>expr.c是表达式处理，主要是辅助完成p 命令，以及后面的监视点，个人认为是PA1里面最重要的部分，是PA1.2的核心内容，为了测试表达式处理是否正确，gen-expr.c是自己设计随机生成一些表达式进行检测，与主程序无关，仅仅测试使用。</p><p>watchpoint.h, watchpoint.c是辅助实现w和d命令，也就是建立监视点和删除监视点，另外cpu-exec.c中需要增加几行代码，实现对监视点的监视。后面PA1.3再详述。</p><h2 id="PA1-0"><a href="#PA1-0" class="headerlink" title="PA1.0"></a>PA1.0</h2><p>在正式开始PA1之前，如果你选择的是x86的ISA，还有一些准备工作需要做，如果不是x86，可以直接跳过此节。</p><p>打开nemu/src/isa/x86/include/isa/reg.h文件，可以看到对CPU_state定义的结构体如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line"> <span class="keyword">uint32_t</span> _32;</span><br><span class="line"> <span class="keyword">uint16_t</span> _16;</span><br><span class="line"> <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line"> }gpr[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line"><span class="keyword">vaddr_t</span> pc;</span><br><span class="line">}CPU_state;</span><br></pre></td></tr></tbody></table></figure><p>因为原先定义的是struct，gpr数组和8个寄存器并没有关联，物理上是顺序独立的排列，为了让他们相关联起来，就要使用union，改后的代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">union</span>{</span><br><span class="line">        <span class="keyword">union</span>{</span><br><span class="line">            <span class="keyword">uint32_t</span> _32;</span><br><span class="line">            <span class="keyword">uint16_t</span> _16;</span><br><span class="line">            <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">        } gpr[<span class="number">8</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">            <span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">        };</span><br><span class="line">    };</span><br><span class="line">  <span class="keyword">vaddr_t</span> pc;</span><br><span class="line"></span><br><span class="line">} CPU_state;</span><br></pre></td></tr></tbody></table></figure><p>可以观察reg.c中的reg_test()是如何进行测试的，生成一个随机数，然后赋值给每个32位的寄存器，然后对关联性检查。</p><p>修改完代码以后，在menu目录下执行make run，如果看到欢迎提示，进入(menu)等待输入命令就说明成功了。</p><h2 id="PA1-1"><a href="#PA1-1" class="headerlink" title="PA1.1"></a>PA1.1</h2><p>PA1.1要实现si, x, info r三条命令。</p><p>要增加一条新的命令先写一个对应的函数，然后在cmd_table中增加命令的名称，说明，函数即可</p><p>cmd_table的结构定义如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">char</span> *description;</span><br><span class="line">  <span class="keyword">int</span> (*handler) (<span class="keyword">char</span> *);</span><br><span class="line">} cmd_table []</span><br></pre></td></tr></tbody></table></figure><h4 id="si命令"><a href="#si命令" class="headerlink" title="si命令"></a>si命令</h4><p>我先上我写的cmd_si()，再具体说明</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_si</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>{</span><br><span class="line">    <span class="comment">/* extract the first argument */</span></span><br><span class="line">    <span class="keyword">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">/* no argument given */</span></span><br><span class="line">        cpu_exec(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">int</span> n = atoi(arg);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">            cpu_exec(n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cmd_err(<span class="number">0</span>, <span class="string">"si:N&lt;=0"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>cmd_si是我觉得这几个命令里面相对来说最简单的一个，因为他只要读出命令中的N，转化为数字再传给cpu_exec()即可，cpu_exec(n)是执行程序，其参数n是执行n步，在这里先用strtok函数读入命令格式中的N，如果没有的话就默认执行1步，即cpu_exec(1)，否则的话用atoi转化为数字后再调用。另外这里cmd_err是一个通用的报错函数，定义如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cmd_err</span><span class="params">(<span class="keyword">int</span> err_type,<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>{</span><br><span class="line">    <span class="keyword">switch</span>(err_type){</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Invalid arguments for command '%s'\n"</span>,command);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Lack arguments for command '%s'\n"</span>,command);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Unknown error\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="x命令"><a href="#x命令" class="headerlink" title="x命令"></a>x命令</h4><p>x命令需要用到vaddr_read(addr,n)函数，其中参数addr是内存地址，n是读出的字节数，思路和刚刚一样，先用strtok函数读出命令的2个参数N和exp，这里暂时不考虑复杂的表达式，仅限于16进制数字，所以可以直接使用sscanf(arg2,”%x”,&amp;addr);将第2个参数地址得到，然后再用vaddr_read(addr,4)每次读出4个字节的内存，循环N次即可。</p><h4 id="info-r命令"><a href="#info-r命令" class="headerlink" title="info r命令"></a>info r命令</h4><p>因为监视点是PA1.3建立，相关内容都要在PA1.3实现，所以目前info命令仅限于实现info r查看所有寄存器的值，让我们先到x86下面的reg.c文件，在这里实现一个显示所有寄存器的接口void isa_reg_display()，其实也很简单，就只是printf所有寄存器的值而已，打印的格式可以参考如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isa_reg_display</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">/* PA1.1 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"eax\t0x%-8x\t%u\n"</span>,cpu.eax,cpu.eax);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ecx\t0x%-8x\t%u\n"</span>,cpu.ecx,cpu.ecx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"edx\t0x%-8x\t%u\n"</span>,cpu.edx,cpu.edx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ebx\t0x%-8x\t%u\n"</span>,cpu.ebx,cpu.ebx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"esp\t0x%-8x\t%u\n"</span>,cpu.esp,cpu.esp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ebp\t0x%-8x\t%u\n"</span>,cpu.ebp,cpu.ebp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"esi\t0x%-8x\t%u\n"</span>,cpu.esi,cpu.esi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"edi\t0x%-8x\t%u\n"</span>,cpu.edi,cpu.edi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pc\t0x%-8x\t%u\n"</span>,cpu.pc,cpu.pc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有了这个接口实现info r就很简单了，只需要判断参数==’r’，然后直接调用reg.c里面的isa_reg_display()即可</p><p>至此PA1.1就完成了，PA1.1本身不难，不过要先理解整个代码框架的结构</p><h2 id="PA1-2"><a href="#PA1-2" class="headerlink" title="PA1.2"></a>PA1.2</h2><p>如果你做过编译原理实验，这部分其实也不会太难，就是编译原理实验的一小部分。</p><p>我们一步一步来，首先对于一个表达式，我们要识别其中的符号token，例如对于表达式</p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"4 +3*(2- 1)"</span></span><br></pre></td></tr></tbody></table></figure><p>的token表达式为</p><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+</span><br><span class="line">| NUM | '+' | NUM | '*' | '<span class="params">(' | NUM | '-' | NUM | ')</span>' |</span><br><span class="line">| <span class="string">"4"</span> |     | <span class="string">"3"</span> |     |     | <span class="string">"2"</span> |     | <span class="string">"1"</span> |     |</span><br><span class="line">+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">-----</span>+</span><br></pre></td></tr></tbody></table></figure><p>在expr.c中首先在enum中添加你想定义的token。我推荐一步到位，PA1.2就把全部的表达式做好。</p><table><thead><tr><th>名称</th><th>意义</th><th>优先级</th></tr></thead><tbody><tr><td>TK_NOTYPE</td><td>空格</td><td>0</td></tr><tr><td>TK_NUM</td><td>十进制数字</td><td>0</td></tr><tr><td>TK_HEX</td><td>十六进制数字</td><td>0</td></tr><tr><td>TK_REG</td><td>寄存器</td><td>0</td></tr><tr><td>TK_OR</td><td>||</td><td>1</td></tr><tr><td>TK_AND</td><td>&amp;&amp;</td><td>2</td></tr><tr><td>TK_EQ</td><td>==</td><td>3</td></tr><tr><td>TK_PLUS</td><td>+</td><td>4</td></tr><tr><td>TK_SUB</td><td>-</td><td>4</td></tr><tr><td>TK_MUL</td><td>*</td><td>5</td></tr><tr><td>TK_DIV</td><td>/</td><td>5</td></tr><tr><td>TK_NEGTIVE</td><td>负数</td><td>6</td></tr><tr><td>TK_DEREF</td><td>引用(例:*$eax)</td><td>6</td></tr><tr><td>TK_LBR</td><td>(</td><td>7</td></tr><tr><td>TK_RBR</td><td>）</td><td>7</td></tr></tbody></table><p>TK_NEGTIVE和TK_DEREF比较特殊，因为他们的符号分别和TK_SUB和TK_MUL是一样的，需要特殊处理，将他们区分开来，这个是在识别完所有token之后做的，暂时先忽略这2个，之后会讲。</p><p>还有一点是这里建议引入优先级，便于后续操作，所以你也需要把原先代码里面对于rule结构体增加一项优先级的成员。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> {</span></span><br><span class="line">  <span class="keyword">char</span> *regex;</span><br><span class="line">  <span class="keyword">int</span> token_type;</span><br><span class="line">  <span class="keyword">int</span> priority; <span class="comment">// add priority</span></span><br><span class="line">} rules[]</span><br></pre></td></tr></tbody></table></figure><p>当然Token结构体也不要忘了加。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">token</span> {</span></span><br><span class="line">  <span class="keyword">int</span> type;</span><br><span class="line">  <span class="keyword">char</span> str[<span class="number">32</span>];</span><br><span class="line">  <span class="keyword">int</span> priority; <span class="comment">//add priority</span></span><br><span class="line">} Token</span><br></pre></td></tr></tbody></table></figure><p>填写好rules，正则表达式，符号，优先级。在make_token中会对表达式挨个字符进行分析，从第一条规则开始遍历rules，匹配成功以后，首先对匹配字符串的长度检测，判断是否大于32，如果大于32个字符assert(0)，否则的话，根据匹配的规则，进行进一步操作。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (rules[i].token_type) {</span><br><span class="line">            <span class="keyword">case</span> TK_NOTYPE: <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TK_NUM:</span><br><span class="line">            <span class="keyword">case</span> TK_HEX:</span><br><span class="line">            <span class="keyword">case</span> TK_REG:</span><br><span class="line">                <span class="built_in">strncpy</span>(tokens[nr_token].str, substr_start, substr_len);</span><br><span class="line">        tokens[nr_token].str[substr_len] = <span class="string">'\0'</span>;</span><br><span class="line">          <span class="keyword">default</span>: </span><br><span class="line">                tokens[nr_token].type = rules[i].token_type;</span><br><span class="line">                tokens[nr_token].priority = rules[i].priority;</span><br><span class="line">        nr_token++;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p>对每个规则都要做的是，将其类型和优先级存入tokens数组，而对于数字，额外需要的操作是将其字符串也要保存，为了之后得到具体数值。对于空格就跳过即可。</p><p>另外值得一提的是这里可以把tokens数字开大一点，后面测试的时候需要修改。</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static Token tokens<span class="literal">[<span class="number">65536</span>]</span> <span class="constructor">__attribute__((<span class="params">used</span>)</span>) = {};</span><br></pre></td></tr></tbody></table></figure><p>到这里第一步算是完成了，第一步的工作是利用正则表达式识别给定表达式的token，然后将其顺序的存入tokens数组，保存其类型，优先级，和数字的字符串（相当于是数值）。</p><p>接下来在完成手册中提示的eval()函数之前，我们还需要写2个辅助函数——check_parentheses()和get_main_op()。</p><p>int check_parentheses(int p, int q)，这里建议将返回类型由bool改为int，因为需要返回3种不同情况。参数p和q分别是tokens数组的起始和结束位置。函数的功能是根据tokens数组从p到q这部分所代表的表达式返回以下3种：</p><ul><li>返回1    如果表达式是一个由一对左右括号完整包裹的一个有效表达式。</li><li>返回0    如果表达式是一个有效的表达式，但是并没有被一对左右括号包裹。</li><li>返回-1   如果表达式不是一个有效的表达式。  </li></ul><p>另外值得一提的是这里需要考虑一种特殊情况，就是虽然是一个有效的表达式，同时左右分别是左括号和号，但是这两个括号并不是一对，例如<br>$$<br>(4+3)*(4+4)<br>$$<br>对于这样的表达式，应该返回0而不是1。这里是对括号的匹配性进行检测，其他方面的细节可以不用管。从p位置开始到q位置，用n进行记录，如果遇到左括号n+1如果遇到右括号n-1,在循环过程中，只要n变为负数可以理解退出返回-1，如果循环结束n不为0也返回-1。剩下的就不用多说了，反正直接看代码也就懂了。</p><p>int get_main_op(int p, int q)，参数的意义同上，函数的作用是从p位置开始扫描到q位置，找到一个优先级最低的运算符号且该运算符号不能在括号包裹的表达式里面，同优先级的情况下取最右边的运算符号作为主符号，最后将主符号的位置返回。因为tokens里面有存各个符号的优先级，所以这里就可以非常简单的实现。判断括号内的方法可以参考上面的用n记录的方法，只有当n等于0的时候说明不在括号内，这时候再进行对运算符号优先级的比较。</p><p>两个辅助函数写完的情况下，对于PA1.2来说可以去实现关键的eval()函数了，但是我一开始就说过了要一步到位，所以先不急着去写eval()函数，我们需要先到expr()函数里面完成一些前置工作。</p><p>uint32_t expr(char *e, bool *success)，对字符串e进行表达式求值，如果求值成功*success==true，失败*success==false，返回求值的结果。expr()函数首先调用make_token完成我前面说的第一步，将表达式进行符号解析存入tokens数组中，之后就是我们需要添加的代码，在已经完成第一步解析的基础上，需要对*和-进行进一步的分析，识别出TK_DEREF和TK_NEGTIVE。</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;nr_token; <span class="built_in">i</span>++){</span><br><span class="line">    <span class="keyword">if</span>(tokens[<span class="built_in">i</span>].<span class="built_in">type</span> == TK_MUL &amp;&amp; (<span class="built_in">i</span>==<span class="number">0</span> || (tokens[<span class="built_in">i</span><span class="number">-1</span>].priority!=<span class="number">0</span> &amp;&amp; tokens[<span class="built_in">i</span><span class="number">-1</span>].<span class="built_in">type</span>!=TK_RBR))){</span><br><span class="line">       tokens[<span class="built_in">i</span>].<span class="built_in">type</span> = TK_DEREF;</span><br><span class="line">       tokens[<span class="built_in">i</span>].priority = <span class="number">6</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tokens[<span class="built_in">i</span>].<span class="built_in">type</span> == TK_SUB &amp;&amp; (<span class="built_in">i</span>==<span class="number">0</span> || (tokens[<span class="built_in">i</span><span class="number">-1</span>].priority!=<span class="number">0</span> &amp;&amp; tokens[<span class="built_in">i</span><span class="number">-1</span>].<span class="built_in">type</span>!=TK_RBR))){</span><br><span class="line">       tokens[<span class="built_in">i</span>].<span class="built_in">type</span> = TK_NEGTIVE;</span><br><span class="line">       tokens[<span class="built_in">i</span>].priority = <span class="number">6</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>对tokens数组扫描，对于其中的*也就是type是TK_MUL，如果位置在第一个，或者他的前一个符号不是数字(可以用优先级简单的判断，因为数字的优先级是0)，且不是右括号，那么将这个TK_MUL重新解释为TK_DEREF，优先级为6。同理对TK_NEGTIVE也进行类似的判断识别。现在所有符号都正确的识别了，可以使用eval对其进行求值了。</p><p>uint32_t eval(int p, int q, bool *success)，求出tokens数组从p到q所代表的表达式的值，如果求值成功*success==true，失败*success==false，返回求值的结果。eval的大致框架和思路在手册里面有写，这里就不赘述了。eval流程图如下：</p><pre class="mermaid">graph TDA(开始) --&gt; B{p与q的关系}    B --&gt; |p &gt; q| err[*success=false<br>return -1]    B --&gt; |p == q| E["根据tokens[p].type<br>(10进制,16进制或寄存器)求值"]    B --&gt; |p &lt; q| F["ret=check_parenthese(p,q)"]    F --&gt; G{ret返回值}    G --&gt; |ret == -1| err    G --&gt; |ret == 1| ret1["return eval(p+1,q-1,success)"]    G --&gt; |ret == 0| ret0["pos=get_main_op(p,q)"]    ret0 --&gt; |pos == -1| err    ret0 --&gt; |pos != -1| eval["val1 = eval(p, pos - 1, success);<br>    val2 = eval(pos + 1, q, success);<br>    根据tokens[pos].type进行运算"]</pre><p>有了流程图，大致的代码思路应该已经有了，再来说下其中的细节。</p><p>首先是p==q的时候，这时候说明这个表达式没有运算符号，其本身是一个数值或者寄存器，如果是TK_NUM或者TK_HEX，那么直接strtoul(tokens[p].str, NULL, 0)就可以把字符串转化为数值，如果是TK_REG，那么需要使用isa_reg_str2val(tokens[p].str + 1, success)获取寄存器的值。这个isa_reg_str2val()函数在之前的reg.c中，需要你去实现它。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">isa_reg_str2val</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">bool</span> *success)</span> </span>{</span><br><span class="line">  <span class="comment">/* PA1.2 */</span></span><br><span class="line">  *success = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, <span class="string">"pc"</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(s, <span class="string">"eip"</span>) == <span class="number">0</span>)  <span class="keyword">return</span> cpu.pc;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = R_EAX; i &lt;= R_EDI; ++ i) {</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, regsl[i]) == <span class="number">0</span>) <span class="keyword">return</span> reg_l(i);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i = R_AX; i &lt;= R_DI; ++ i){</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, regsw[i]) == <span class="number">0</span>) <span class="keyword">return</span> reg_w(i);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(i = R_AL; i &lt;= R_BH; ++ i){</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, regsb[i]) == <span class="number">0</span>) <span class="keyword">return</span> reg_b(i);</span><br><span class="line">}</span><br><span class="line">*success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>遍历所有的寄存器，比对传入参数s和寄存器的名字，找到s对应的寄存器然后返回寄存器中的值。</p><p>第2个细节是根据tokens[pos].type进行运算，pos的位置指向主运算符，如果这个主运算符是除法，那么应该注意一下对于除以0行为的处理，也就是判断val2==0?，简单一点直接assert(0)也可以，也可以输出一段提示后，*success=false。其他的运算符都比较简单，注意TK_DEREF是val=vaddr_read(val2,4)以及TK_NEGTIVE是val=-val2即可。(这两个运算符并没有用到val1)</p><p>其实到这里PA1.2已经完成了，但是手册里面要求你还需要对你的表达式写一个程序随机测验，所以你还需要完成gen-expr.c。测试原理在手册里面已经讲了，而我们在这个文件中需要自己补充的仅仅是随机生成一个表达式的部分，我直接贴上我的代码再讲比较方便，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PA1.2 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TOKEN 10</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">5000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">choose</span><span class="params">(<span class="keyword">uint32_t</span> n)</span></span>{</span><br><span class="line"><span class="keyword">return</span> rand() % n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gen_rand_expr</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> op;</span><br><span class="line">  <span class="keyword">if</span>(l==r)buf[l]=choose(<span class="number">10</span>)+<span class="number">48</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(r==l+<span class="number">1</span>){</span><br><span class="line">  buf[l]=choose(<span class="number">9</span>)+<span class="number">1</span>+<span class="number">48</span>;</span><br><span class="line">  buf[r]=choose(<span class="number">10</span>)+<span class="number">48</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span>{</span><br><span class="line">  <span class="keyword">switch</span>(choose(<span class="number">1</span>)){</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              op=l+<span class="number">1</span>+choose(r-l<span class="number">-1</span>);</span><br><span class="line">  gen_rand_expr(l,op<span class="number">-1</span>);</span><br><span class="line">              <span class="keyword">static</span> <span class="keyword">char</span> ops[] = <span class="string">"+-*/"</span>;</span><br><span class="line">  buf[op]=ops[choose(<span class="number">4</span>)];</span><br><span class="line">  gen_rand_expr(op+<span class="number">1</span>,r);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  buf[l]=<span class="string">'('</span>;</span><br><span class="line">  buf[r]=<span class="string">')'</span>;</span><br><span class="line">  gen_rand_expr(l+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>N_TOKEN是最后表达式中token的数目，uint32_t choose(uint32_t n)随机生成一个0~n-1的数。</p><p>void gen_rand_expr(int l,int r)在字符串位置l和r之间随机生成表达式的token，如果r==l生成一个1位数字，如果r==l+1生成一个两位数，此外，从下面2种情况中生成一种：</p><ul><li>在l+1到r-1中随机选取一个位置作为主符号的位置op，并从加减乘除当中随机选择一个符号。递归调用gen_rand_expr(l,op-1)和gen_rand_expr(op+1,r)生成两边的表达式。</li><li>在l和r的位置生成一对括号，递归调用gen_rand_expr(l+1,r-1)，生成被一对括号包裹的表达式。  </li></ul><p>最后修改下面的main函数中对gen_rand_expr()的调用，加上参数，就完成了。别忘了修改buf和code_buf数组的大小，至少保证buf的长度小于code_buf。</p><p>完成了以后记得去ui.c中加入p命令，方式同PA1.1。这里只要调用expr即可，我附上我的代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_p</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>{</span><br><span class="line">    <span class="comment">/* extract the first argument */</span></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">/* no argument given */</span></span><br><span class="line">        cmd_err(<span class="number">0</span>, <span class="string">"p: no argument given\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> result = expr(args,&amp;success);</span><br><span class="line">        <span class="keyword">if</span>(success) <span class="built_in">printf</span>(<span class="string">"0x%x(%d)\n"</span>,result,result);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Invalid expr\n"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="PA1-3"><a href="#PA1-3" class="headerlink" title="PA1.3"></a>PA1.3</h2><p>PA1.3要求实现监视点的创建和删除。首先我们先到watchpoint.h查看WP结构体，可以看到原始定义只有表示WP的序号NO以及作为链表结点必须的next指针，这显然是不够的。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> {</span></span><br><span class="line">  <span class="keyword">int</span> NO;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more members if necessary */</span></span><br><span class="line">  <span class="comment">/* PA1.3*/</span></span><br><span class="line">  <span class="keyword">char</span> expr[<span class="number">128</span>];</span><br><span class="line">  <span class="keyword">uint32_t</span> value;</span><br><span class="line">  <span class="keyword">int</span> hit;</span><br><span class="line">} WP;</span><br></pre></td></tr></tbody></table></figure><p>需要添加的成员有3个：</p><ul><li>char expr[128]：用于记录创建的监视点的表达式，例如$eax</li><li>uint32_t value：求出当前的表达式的值，表达式是不变的，但是其值会变，因为寄存器值会变，当表达式值改变的时候就要暂停程序，算是命中。</li><li>int hit：记录该监视点的命中次数。</li></ul><p>监视点采用链表池的结构管理，所有监视点保存在wp_pool数组中，而正在使用的监视点由head指针串起的一个链表，空闲的监视点链表由free_指向。</p><p>剩下的其实都是基本的链表操作，例如创建一个监视点，就是将free_指向的首结点从空闲链表摘除，加进head指向的链表。并设置其expr,hit,计算expr。而删除一个监视点，就是遍历head指向的链表，找到一个结点其序号NO与给定的相符，将其从head链表中删除，移到free_链表。</p><p>除了添加和删除，还需要展示监视点的内容，这里是继续了PA1.1的info w命令，函数自己命名，展示格式可以参考如下代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_wp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(head == <span class="literal">NULL</span>) {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"There is no watchpoint!\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Num     What     Value\n"</span>);</span><br><span class="line">WP *p = head;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>) {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%-8d%-9s%u(%#x)\n"</span>, p -&gt; NO, p -&gt; expr, p-&gt;value, p-&gt;value);</span><br><span class="line"><span class="keyword">if</span>(p -&gt; hit &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\tbreakpoint already hit %d time\n"</span>, p-&gt;hit);</span><br><span class="line">p = p -&gt; next;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>除此之外，你还需要一个功能，监视点的作用是当监视的表达式的值变化时，暂停程序。我们先实现bool check_wp()，它的功能是检查所有监视点，看是否有监视点的表达式值发生了变化。方法很简单，遍历head指向的所有正在使用的监视点，然后重新计算其expr的值，与之前保存在value当中的值比对，如果不同的话，说明表达式的值发生了变化。然后需要暂停程序，这里手册给了提示，只要把nemu_state.state赋值为NEMU_STOP即可。在cpu_exec.c的cpu_exec()函数，我们会亲切的发现已经有注释写好了你需要添加的位置，而你只需要在这行注释下面添加这么几行代码即可。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> check watchpoints here. */</span></span><br><span class="line">    <span class="comment">/* PA1.3*/</span></span><br><span class="line">  <span class="keyword">bool</span> changed = check_wp();</span><br><span class="line"><span class="keyword">if</span>(changed){</span><br><span class="line">nemu_state.state = NEMU_STOP;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后别忘了回到ui.c完善你所有的命令，整个PA1就算完成了，其实还算简单，真正痛苦的地狱PA2才正要开始。</p><h1 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h1><p>该说不愧是1星难度吗，确实挺难的。</p><h2 id="PA2-1"><a href="#PA2-1" class="headerlink" title="PA2.1"></a>PA2.1</h2><p>我觉得有必要先整理一下结构体定义（不过你可以先暂时跳过这部分，直接看完追踪mov指令执行过程会更加清晰）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *pc)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_EHelper(name) void concat(exec_, name) (vaddr_t *pc)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*EHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  DHelper decode;</span><br><span class="line">  EHelper execute;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">} OpcodeEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">  <span class="keyword">union</span> {</span><br><span class="line">    <span class="keyword">uint32_t</span> reg;</span><br><span class="line">    <span class="keyword">rtlreg_t</span> addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> imm;</span><br><span class="line">    <span class="keyword">int32_t</span> simm;</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">rtlreg_t</span> val;</span><br><span class="line">  <span class="keyword">char</span> str[OP_STR_SIZE];</span><br><span class="line">} Operand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="keyword">uint32_t</span> opcode;</span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="built_in">width</span>;</span><br><span class="line">  <span class="keyword">vaddr_t</span> seq_pc;  <span class="comment">// sequential pc</span></span><br><span class="line">  <span class="keyword">bool</span> is_jmp;</span><br><span class="line">  <span class="keyword">vaddr_t</span> jmp_pc;</span><br><span class="line">  Operand src, dest, src2;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ISADecodeInfo</span> <span class="title">isa</span>;</span></span><br><span class="line">} DecodeInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> {</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">int32_t</span>  simm   : <span class="number">16</span>;</span><br><span class="line"><span class="comment">//  uint32_t rt     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t rs     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t opcode :  6;</span></span><br><span class="line">  };</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">uint32_t</span> imm    : <span class="number">16</span>;</span><br><span class="line"><span class="comment">//  uint32_t rt     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t rs     :  5;</span></span><br><span class="line"><span class="comment">//  uint32_t opcode :  6;</span></span><br><span class="line">  };</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">uint32_t</span> jmp_target : <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> opcode     :  <span class="number">6</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">uint32_t</span> func   : <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> sa     : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> rd     : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> rt     : <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> rs     : <span class="number">5</span>;</span><br><span class="line"><span class="comment">//  uint32_t opcode : 6;</span></span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">uint32_t</span> val;</span><br><span class="line">} Instr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ISADecodeInfo</span> {</span></span><br><span class="line">  Instr instr;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> {</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">uint8_t</span> R_M:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> reg:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> mod:<span class="number">2</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">uint8_t</span> dont_care:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> opcode:<span class="number">3</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">uint8_t</span> val;</span><br><span class="line">} ModR_M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> {</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">uint8_t</span> base:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> index:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> ss:<span class="number">2</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">uint8_t</span> val;</span><br><span class="line">} SIB;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, <span class="keyword">int</span> len)</span> </span>{</span><br><span class="line">  <span class="keyword">uint32_t</span> instr = vaddr_read(*pc, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *p_instr = (<span class="keyword">void</span> *)&amp;instr;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i ++) {</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> log_bytebuf[];</span><br><span class="line">    strcatf(log_bytebuf, <span class="string">"%02x "</span>, p_instr[i]);</span><br><span class="line">  }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  (*pc) += len;</span><br><span class="line">  <span class="keyword">return</span> instr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Instruction Decode and EXecute */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idex</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, OpcodeEntry *e)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;decode)</span><br><span class="line">    e-&gt;decode(pc);</span><br><span class="line">  e-&gt;execute(pc);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make_DHelper(mov_I2r) {</span><br><span class="line">  decode_op_r(pc, id_dest, <span class="literal">false</span>);</span><br><span class="line">  decode_op_I(pc, id_src, <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This helper function is use to decode register encoded in the opcode. */</span></span><br><span class="line"><span class="comment">/* XX: AL, AH, BL, BH, CL, CH, DL, DH</span></span><br><span class="line"><span class="comment"> * eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(r)</span> </span>{</span><br><span class="line">  op-&gt;type = OP_TYPE_REG;</span><br><span class="line">  op-&gt;reg = decinfo.opcode &amp; <span class="number">0x7</span>;</span><br><span class="line">  <span class="keyword">if</span> (load_val) {</span><br><span class="line">    rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;<span class="built_in">width</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">"%%%s"</span>, reg_name(op-&gt;reg, op-&gt;<span class="built_in">width</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Refer to Appendix A in i386 manual for the explanations of these abbreviations */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ib, Iv */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(I)</span> </span>{</span><br><span class="line">  <span class="comment">/* pc here is pointing to the immediate */</span></span><br><span class="line">  op-&gt;type = OP_TYPE_IMM;</span><br><span class="line">  op-&gt;imm = instr_fetch(pc, op-&gt;<span class="built_in">width</span>);</span><br><span class="line">  rtl_li(&amp;op-&gt;val, op-&gt;imm);</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">"$0x%x"</span>, op-&gt;imm);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们以追踪mov指令执行过程为例讲解整个流程。</p><p>从cpu.c开始首先执行exec_once()函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vaddr_t</span> <span class="title">exec_once</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  decinfo.seq_pc = cpu.pc;</span><br><span class="line">  isa_exec(&amp;decinfo.seq_pc);</span><br><span class="line">  update_pc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> decinfo.seq_pc;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将cpu.pc的值保存在了decinfo.seq_pc中，然后将该值的索引传进isa_exec()中，最后调用update_pc()更新pc值。关键的译码和执行显然在isa_exec()中，这个函数也有屏蔽isa差别的功能，来到isa/x86/exec/exec.c中，这里有isa_exec()定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isa_exec</span><span class="params">(<span class="keyword">vaddr_t</span> *pc)</span> </span>{</span><br><span class="line">  <span class="keyword">uint32_t</span> opcode = instr_fetch(pc, <span class="number">1</span>);</span><br><span class="line">  decinfo.opcode = opcode;</span><br><span class="line">  set_width(opcode_table[opcode].<span class="built_in">width</span>);</span><br><span class="line">  idex(pc, &amp;opcode_table[opcode]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>instr_fetch()的定义在include/cpu/exec.h中</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, <span class="keyword">int</span> len)</span> </span>{</span><br><span class="line">  <span class="keyword">uint32_t</span> instr = vaddr_read(*pc, len);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *p_instr = (<span class="keyword">void</span> *)&amp;instr;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i ++) {</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> log_bytebuf[];</span><br><span class="line">    strcatf(log_bytebuf, <span class="string">"%02x "</span>, p_instr[i]);</span><br><span class="line">  }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  (*pc) += len;</span><br><span class="line">  <span class="keyword">return</span> instr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>功能很简单，就是读取pc所指内存len个字节返回，然后pc的值增加len长度。</p><p>回到isa_exec()，很明显先是从pc所指地方读取一个字节作为opcode并且保存在decinfo.opcode中，如果是mov指令，以下面这条mov指令为例：</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100000</span>:    b8 <span class="number">34</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span>        mov    $<span class="number">0x1234</span>,%eax</span><br></pre></td></tr></tbody></table></figure><p>那么这个opcode一定是0xb8，接着我们用opcode作为索引查表opcode_table</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0xb8 */</span><span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>, <span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>, <span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>, <span class="constructor">IDEX(<span class="params">mov_I2r</span>, <span class="params">mov</span>)</span>,</span><br></pre></td></tr></tbody></table></figure><p>也就是IDEX(mov_I2r,mov)，我们先来看看opcode_table的定义。他是一个OpcodeEntry类型的数组，那么OpcodeEntry又是什么呢，他的结构体定义在include/cpu/exec.h中，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  DHelper decode;</span><br><span class="line">  EHelper execute;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">} OpcodeEntry;</span><br></pre></td></tr></tbody></table></figure><p>在这个文件的上面可以找到EHelper的定义：</p><figure class="highlight delphi"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void <span class="comment">(*EHelper) (vaddr_t *)</span>;</span><br></pre></td></tr></tbody></table></figure><p>DHelper的定义在decode.h中可以找到，是类似的。总之就是说这个结构体有2个函数指针和一个int类型变量记录宽度，这两个函数指针分别执行译码函数和执行函数的入口。</p><p>在exec.h中，我们还可以看到IDEX宏的定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEXW(id, ex, w)   {concat(decode_, id), concat(exec_, ex), w}</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEX(id, ex)       IDEXW(id, ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXW(ex, w)         {NULL, concat(exec_, ex), w}</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EX(ex)             EXW(ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPTY              EX(inv)</span></span><br></pre></td></tr></tbody></table></figure><p>IDEX是宽度为0的IDEXW，而IDEXW里面这个concat同样是个宏，这里就不再去找了，直接解释他的作用，就是将后面2个字符串拼接起来，我们回到IDEX(mov_I2r, mov)这个具体实例，通过这层层宏，最终应该被翻译成</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  decode_mov_I2r,</span><br><span class="line">  exec_mov,</span><br><span class="line">  <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们再回到isa_exec()，现在该执行set_width(opcode_table[opcode].width);这行了，不过根据上面分析，这里宽度的值为0，也就是set_width(0);那么set_width会怎么处理，我们需要看下set_width()函数的定义（exec.c文件）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_width</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">width</span> == <span class="number">0</span>) {</span><br><span class="line">    <span class="built_in">width</span> = decinfo.isa.is_operand_size_16 ? <span class="number">2</span> : <span class="number">4</span>;</span><br><span class="line">  }</span><br><span class="line">  decinfo.src.<span class="built_in">width</span> = decinfo.dest.<span class="built_in">width</span> = decinfo.src2.<span class="built_in">width</span> = <span class="built_in">width</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为width==0，而decinfo.isa.is_operand_size_16默认值是false，所以操作数的位宽都被设置为了4。</p><p>继续执行下一行idex(pc, &amp;opcode_table[opcode]);我们需要看一下idex()函数的定义(exec.h)：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Instruction Decode and EXecute */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idex</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, OpcodeEntry *e)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;decode)</span><br><span class="line">    e-&gt;decode(pc);</span><br><span class="line">  e-&gt;execute(pc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>前面也说了OpcodeEntry里面有译码函数指针和执行函数指针，这里检测译码函数指针是否为NULL，如果为NULL，就直接进入执行函数，否则以pc作为参数进入译码函数，作为例子的译码函数是decode_mov_I2r()，不过这个函数也是宏定义的，我们先得找到。</p><p>我们来到isa/x86/decode.c文件，这里有很多用宏定义构成的译码函数，我们来看看是怎么构成的。</p><p>从结果说起吧，第157行make_DHelper(mov_I2r)就是我们要找的decode_mov_I2r().</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make_DHelper(mov_I2r) {</span><br><span class="line">  decode_op_r(pc, id_dest, <span class="literal">false</span>);</span><br><span class="line">  decode_op_I(pc, id_src, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先去include/cpu/decode.h里面可以看到make_DHelper(name)宏定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *pc)</span></span><br></pre></td></tr></tbody></table></figure><p>因此按照这个宏定义，将make_DHelper(mov_I2r)翻译过来就是</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode_mov_I2r</span><span class="params">(<span class="keyword">vaddr_t</span> *pc)</span></span></span><br></pre></td></tr></tbody></table></figure><p>没错，正是我们所要找的函数，这个函数里面调用了2个decode_op_前缀的函数，在decode.c中我们可以在开头第4行看到这样一行宏定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *pc, Operand *op, bool load_val)</span></span><br></pre></td></tr></tbody></table></figure><p>所以，类似的，我们要找make_DopHelper(r)和make_DopHelper(I)，分别在59行和第9行：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(r)</span> </span>{</span><br><span class="line">  op-&gt;type = OP_TYPE_REG;</span><br><span class="line">  op-&gt;reg = decinfo.opcode &amp; <span class="number">0x7</span>;</span><br><span class="line">  <span class="keyword">if</span> (load_val) {</span><br><span class="line">    rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;<span class="built_in">width</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">"%%%s"</span>, reg_name(op-&gt;reg, op-&gt;<span class="built_in">width</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Refer to Appendix A in i386 manual for the explanations of these abbreviations */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ib, Iv */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(I)</span> </span>{</span><br><span class="line">  <span class="comment">/* pc here is pointing to the immediate */</span></span><br><span class="line">  op-&gt;type = OP_TYPE_IMM;</span><br><span class="line">  op-&gt;imm = instr_fetch(pc, op-&gt;<span class="built_in">width</span>);</span><br><span class="line">  rtl_li(&amp;op-&gt;val, op-&gt;imm);</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">"$0x%x"</span>, op-&gt;imm);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们先将make_DopHelper(r)翻译一下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">decode_op_r</span> <span class="params">(<span class="keyword">vaddr_t</span> *pc, Operand *op, <span class="keyword">bool</span> load_val)</span> </span>{</span><br><span class="line">  op-&gt;type = OP_TYPE_REG;</span><br><span class="line">  op-&gt;reg = decinfo.opcode &amp; <span class="number">0x7</span>;</span><br><span class="line">  <span class="keyword">if</span> (load_val) {</span><br><span class="line">    rtl_lr(&amp;op-&gt;val, op-&gt;reg, op-&gt;<span class="built_in">width</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">"%%%s"</span>, reg_name(op-&gt;reg, op-&gt;<span class="built_in">width</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里就很明显了，这个函数将op的类型赋值为OP_TYPE_REG，也就是标注为寄存器，寄存器的编号是opcode&amp;0x7，我们例子中opcode为0xb8，所以寄存器编号是0，而0号寄存器就是EAX，而load_val为false所以跳过，不过我认为这里还是先说明一下rtl函数，它们在include/isa/rtl.h文件和include/rtl目录中，目前只实现了几个，后面很多需要我们来补充。手册里面说过了，在NEMU中, 我们使用RTL（寄存器传输语言）来描述简单的操作.例如：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_lr</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">int</span> r, <span class="keyword">int</span> <span class="built_in">width</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">width</span>) {</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: rtl_mv(dest, &amp;reg_l(r)); <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: rtl_host_lm(dest, &amp;reg_b(r), <span class="number">1</span>); <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: rtl_host_lm(dest, &amp;reg_w(r), <span class="number">2</span>); <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在rtl-wrapper.h里面有相关宏定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL_PREFIX interpret</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rtl_mv        concat(RTL_PREFIX, _rtl_mv      )</span></span><br></pre></td></tr></tbody></table></figure><p>而在include/rtl/rtl.h中有具体的函数定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">interpret_rtl_mv</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1)</span> </span>{</span><br><span class="line">  *dest = *src1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我想这个先暂时讲到这里，让我们回到decode_mov_I2r()函数，我们仅仅分析了它调用的一个函数，不过其实第2个也类似，这个函数从名字上也可以看出它的功能是把立即数（Imm）送入寄存器(reg)，因此它先调用了decode_op_r(pc, id_dest, false)这里id_dest也是一个宏，翻译过来其实就是&amp;decinfo.dest，也就是说这个函数作用是把目的操作数的类型确定为了寄存器，并记录了寄存器编号，为后续做好准备。那么decode_op_r(pc, id_src, true)函数的结果也显而易见了，将源操作数的类型设置为立即数，同时设置好立即数的值，从它的代码中我们可以看到instr_fetch(pc, op-&gt;width);也就是说从opcode字节后面又取了4个字节作为立即数的值。然后使用rtl_li(&amp;op-&gt;val, op-&gt;imm)将值保存进了op-&gt;val中。整个译码过程就算结束了。</p><p>接下来是执行过程，先找执行函数也就是exec_mov()函数，与前面类似，也就是说我们要找make_EHelper(mov)，这里看下x86/exec目录下，根据指令的类型不同分类出了arith.c存放运算类执行函数，control.c存放控制类执行函数,data-mov.c存放数据传输执行函数。所以我们来到data-mov.c文件中。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(mov) {</span><br><span class="line">  operand_write(id_dest, &amp;id_src-&gt;val);</span><br><span class="line">  print_asm_template2(mov);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还是先把宏都翻译一下，包括id_dest</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec_mov</span><span class="params">(<span class="keyword">vaddr_t</span> *pc)</span></span>{</span><br><span class="line">  operand_write(&amp;decinfo.dest, &amp;id_src-&gt;val);</span><br><span class="line">  print_asm(#mov <span class="string">"%c %s,%s"</span>, suffix_char((&amp;decinfo.dest)-&gt;<span class="built_in">width</span>), id_src-&gt;str, id_dest-&gt;str)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>很显然，operand_write(&amp;decinfo.dest, &amp;id_src-&gt;val)的功能是把源操作数的值，写入目的操作数中。我们来具体看下operand_write()定义（decode.c）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operand_write</span><span class="params">(Operand *op, <span class="keyword">rtlreg_t</span>* src)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (op-&gt;type == OP_TYPE_REG) { rtl_sr(op-&gt;reg, src, op-&gt;<span class="built_in">width</span>); }</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (op-&gt;type == OP_TYPE_MEM) { rtl_sm(&amp;op-&gt;addr, src, op-&gt;<span class="built_in">width</span>); }</span><br><span class="line">  <span class="keyword">else</span> { assert(<span class="number">0</span>); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据目的操作数的类型不同，调用rtl_sr()将源操作数的值送入寄存器(reg)或者调用rtl_sm()送入内存(mem)。</p><p>执行函数执行完以后不要完了exec_once最后还调用了update_pc()，让我们也看下它的定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update_pc</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (decinfo.is_jmp) { decinfo.is_jmp = <span class="number">0</span>; }</span><br><span class="line">  <span class="keyword">else</span> { cpu.pc = decinfo.seq_pc; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>作为mov指令，自然是没有跳转的，再读完了一个字节的opcode和4个字节的立即数后decinfo.seq_pc自然已经来到了下一条指令的opcode位置，将其赋值给cpu.pc完成pc更新的工作就算真正的执行完了一条指令。</p><p>再以movw为例讲一下复杂指令的流程：</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100017</span>:    <span class="number">66</span> c7 <span class="number">84</span> <span class="number">99</span> <span class="number">00</span> e0 ff    movw   $<span class="number">0x1</span>,<span class="number">-0x2000</span>(%ecx,%ebx,<span class="number">4</span>)</span><br><span class="line"><span class="number">10001</span>e:    ff <span class="number">01</span> <span class="number">00</span></span><br></pre></td></tr></tbody></table></figure><p>按照之前讲的流程先取到了opcode_table[0x66]的元素，会发现是一个EX(operand_size)，这个宏翻译过来译码辅助函数为NULL，只有执行函数的指针，所以我们直接看它的执行函数，在prefix.c中</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(operand_size) {</span><br><span class="line">  decinfo.isa.is_operand_size_16 = <span class="literal">true</span>;</span><br><span class="line">  isa_exec(pc);</span><br><span class="line">  decinfo.isa.is_operand_size_16 = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将is_operand_size_16设置为true，也就是更改宽度为16位，然后从下个字节开始执行isa_exec(pc)。这完成的就是operand-size prefix的功能。因为它的存在mov指令被识别为了movw指令。</p><p>接下来是真正的opcode，其值为0xc7，opcode_table[0xc7]=IDEX(mov_I2E, mov)，我们直接看译码函数(decode.c)：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make_DHelper(I2E) {</span><br><span class="line">  decode_op_rm(pc, id_dest, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>);</span><br><span class="line">  decode_op_I(pc, id_src, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>decode_op_I()跟前面一样就不用说了，不同的仅限于这次是取2个字节作为立即数。</p><p>让我们看下decode_op_rm()的定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* I386 manual does not contain this abbreviation.</span></span><br><span class="line"><span class="comment"> * We decode everything of modR/M byte by one time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* Eb, Ew, Ev</span></span><br><span class="line"><span class="comment"> * Gb, Gv</span></span><br><span class="line"><span class="comment"> * Cd,</span></span><br><span class="line"><span class="comment"> * M</span></span><br><span class="line"><span class="comment"> * Rd</span></span><br><span class="line"><span class="comment"> * Sw</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decode_op_rm</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, Operand *rm, <span class="keyword">bool</span> load_rm_val, Operand *reg, <span class="keyword">bool</span> load_reg_val)</span> </span>{</span><br><span class="line">  read_ModR_M(pc, rm, load_rm_val, reg, load_reg_val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在src/isa/x86/decode/modrm.c中可以找到read_ModR_M()定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_ModR_M</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, Operand *rm, <span class="keyword">bool</span> load_rm_val, Operand *reg, <span class="keyword">bool</span> load_reg_val)</span> </span>{</span><br><span class="line">  ModR_M m;</span><br><span class="line">  m.val = instr_fetch(pc, <span class="number">1</span>);</span><br><span class="line">  decinfo.isa.ext_opcode = m.opcode;</span><br><span class="line">  <span class="keyword">if</span> (reg != <span class="literal">NULL</span>) {</span><br><span class="line">    reg-&gt;type = OP_TYPE_REG;</span><br><span class="line">    reg-&gt;reg = m.reg;</span><br><span class="line">    <span class="keyword">if</span> (load_reg_val) {</span><br><span class="line">      rtl_lr(&amp;reg-&gt;val, reg-&gt;reg, reg-&gt;<span class="built_in">width</span>);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">snprintf</span>(reg-&gt;str, OP_STR_SIZE, <span class="string">"%%%s"</span>, reg_name(reg-&gt;reg, reg-&gt;<span class="built_in">width</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m.mod == <span class="number">3</span>) {</span><br><span class="line">    rm-&gt;type = OP_TYPE_REG;</span><br><span class="line">    rm-&gt;reg = m.R_M;</span><br><span class="line">    <span class="keyword">if</span> (load_rm_val) {</span><br><span class="line">      rtl_lr(&amp;rm-&gt;val, m.R_M, rm-&gt;<span class="built_in">width</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">sprintf</span>(rm-&gt;str, <span class="string">"%%%s"</span>, reg_name(m.R_M, rm-&gt;<span class="built_in">width</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    load_addr(pc, &amp;m, rm);</span><br><span class="line">    <span class="keyword">if</span> (load_rm_val) {</span><br><span class="line">      rtl_lm(&amp;rm-&gt;val, &amp;rm-&gt;addr, rm-&gt;<span class="built_in">width</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先看一下ModR_M的联合定义(x86/include/isa/decode.h)：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> {</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">uint8_t</span> R_M:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> reg:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> mod:<span class="number">2</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">uint8_t</span> dont_care:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> opcode:<span class="number">3</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">uint8_t</span> val;</span><br><span class="line">} ModR_M;</span><br></pre></td></tr></tbody></table></figure><p>我们需要结合x86指令格式的ModR/M去看</p><figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ModR/M byte</span><br><span class="line">7    6    5    4    3    2    1    0</span><br><span class="line"><span class="code">+--------+</span>-------------<span class="code">+-------------+</span></span><br><span class="line">|  mod   | reg/opcode  |     r/m     |</span><br><span class="line"><span class="code">+--------+</span>-------------<span class="code">+-------------+</span></span><br></pre></td></tr></tbody></table></figure><p>m.val又读取了一个字节，也就是0x84，把这个字节按照上面进行拆分，mod部分是2，reg/opcode是0,因此read_ModR_M()函数执行最后一个else块，先load_addr(pc, &amp;m, rm)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_addr</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, ModR_M *m, Operand *rm)</span> </span>{</span><br><span class="line">  assert(m-&gt;mod != <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int32_t</span> disp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> disp_size = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> base_reg = <span class="number">-1</span>, index_reg = <span class="number">-1</span>, scale = <span class="number">0</span>;</span><br><span class="line">  rtl_li(&amp;s0, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;R_M == R_ESP) {</span><br><span class="line">    SIB s;</span><br><span class="line">    s.val = instr_fetch(pc, <span class="number">1</span>);</span><br><span class="line">    base_reg = s.base;</span><br><span class="line">    scale = s.ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.index != R_ESP) { index_reg = s.index; }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">/* no SIB */</span></span><br><span class="line">    base_reg = m-&gt;R_M;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m-&gt;mod == <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">if</span> (base_reg == R_EBP) { base_reg = <span class="number">-1</span>; }</span><br><span class="line">    <span class="keyword">else</span> { disp_size = <span class="number">0</span>; }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (m-&gt;mod == <span class="number">1</span>) { disp_size = <span class="number">1</span>; }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (disp_size != <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">/* has disp */</span></span><br><span class="line">    disp = instr_fetch(pc, disp_size);</span><br><span class="line">    <span class="keyword">if</span> (disp_size == <span class="number">1</span>) { disp = (<span class="keyword">int8_t</span>)disp; }</span><br><span class="line"></span><br><span class="line">    rtl_addi(&amp;s0, &amp;s0, disp);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (base_reg != <span class="number">-1</span>) {</span><br><span class="line">    rtl_add(&amp;s0, &amp;s0, &amp;reg_l(base_reg));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index_reg != <span class="number">-1</span>) {</span><br><span class="line">    rtl_shli(&amp;s1, &amp;reg_l(index_reg), scale);</span><br><span class="line">    rtl_add(&amp;s0, &amp;s0, &amp;s1);</span><br><span class="line">  }</span><br><span class="line">  rtl_mv(&amp;rm-&gt;addr, &amp;s0);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="keyword">char</span> disp_buf[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">char</span> base_buf[<span class="number">8</span>];</span><br><span class="line">  <span class="keyword">char</span> index_buf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (disp_size != <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">/* has disp */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(disp_buf, <span class="string">"%s%#x"</span>, (disp &lt; <span class="number">0</span> ? <span class="string">"-"</span> : <span class="string">""</span>), (disp &lt; <span class="number">0</span> ? -disp : disp));</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> { disp_buf[<span class="number">0</span>] = <span class="string">'\0'</span>; }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (base_reg == <span class="number">-1</span>) { base_buf[<span class="number">0</span>] = <span class="string">'\0'</span>; }</span><br><span class="line">  <span class="keyword">else</span> { </span><br><span class="line">    <span class="built_in">sprintf</span>(base_buf, <span class="string">"%%%s"</span>, reg_name(base_reg, <span class="number">4</span>));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index_reg == <span class="number">-1</span>) { index_buf[<span class="number">0</span>] = <span class="string">'\0'</span>; }</span><br><span class="line">  <span class="keyword">else</span> { </span><br><span class="line">    <span class="built_in">sprintf</span>(index_buf, <span class="string">",%%%s,%d"</span>, reg_name(index_reg, <span class="number">4</span>), <span class="number">1</span> &lt;&lt; scale);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (base_reg == <span class="number">-1</span> &amp;&amp; index_reg == <span class="number">-1</span>) {</span><br><span class="line">    <span class="built_in">sprintf</span>(rm-&gt;str, <span class="string">"%s"</span>, disp_buf);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">sprintf</span>(rm-&gt;str, <span class="string">"%s(%s%s)"</span>, disp_buf, base_buf, index_buf);</span><br><span class="line">  }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  rm-&gt;type = OP_TYPE_MEM;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>R_ESP是一个常量值为4，在PA1的reg.h里面有定义，本例中m-&gt;R_M也是等于4,说明之后还有一个SIB字节，这个字节指示了如何寻址：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">displacement</span><span class="params">(R[base_reg], R[index_reg], scale_factor)</span></span></span><br></pre></td></tr></tbody></table></figure><p>我们看下SIB联合的定义(decode.h)：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> {</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">uint8_t</span> base:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> index:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> ss:<span class="number">2</span>;</span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">uint8_t</span> val;</span><br><span class="line">} SIB;</span><br></pre></td></tr></tbody></table></figure><p>结合x86指令格式：</p><figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SIB (scale index base) byte</span><br><span class="line">7    6    5    4    3    2    1    0</span><br><span class="line"><span class="code">+--------+</span>-------------<span class="code">+-------------+</span></span><br><span class="line">|   ss   |    index    |    base     |</span><br><span class="line"><span class="code">+--------+</span>-------------<span class="code">+-------------+</span></span><br></pre></td></tr></tbody></table></figure><p>本例中SIB字节是0x99，因此base=1,index=3,ss=2。base_reg=1，也就是R_ECX，index_reg是3，也就是EBX，然后因为前面得到的mod的值为2，所以disp_size取默认值4，说明后面有4个字节的偏移量，disp = instr_fetch(pc, disp_size);在本例中取得0xffffe000，也就是-0x2000。ss=2，代表scale=2，向左移2位也就是乘4.</p><p>因此最后计算的地址是</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr = R[ECX] + R[EBX] * <span class="number">4</span> - <span class="number">0x2000</span></span><br></pre></td></tr></tbody></table></figure><p>而从代码里面我们可以看到是用了一系列的rtl完成上面这个表达式的计算，用了2个临时寄存器s0和s1保存中间计算结果，具体看代码应该看得懂。总之计算完地址后可以把目的操作数类型填写为OP_TYPE_MEM，并将地址保存在其addr成员中。译码阶段算是完成了，执行阶段与前面mov指令类型就不再赘述了，我们直接开始完成PA2.1。</p><p>按照手册的提示，要运行第一个程序需要完成<code>call</code>, <code>push</code>, <code>sub</code>, <code>xor</code>, <code>ret</code>五条指令。更具体的来说，我们需要完成nexus-am/tests/cputest/build/dummy-$ISA-nemu.txt中的这5条指令。（建议配合i386手册食用)</p><h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><p>查看反汇编结果，可以看到这里有2条call指令，且它们的形式相同，都是e8 cd的形式，我们以第一条为例。</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span>a:e8 <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       call   <span class="number">100014</span> &lt;_trm_init&gt;</span><br></pre></td></tr></tbody></table></figure><p>e8是opcode，后面4个字节是偏移量，跳转的地址是pc+指令长度+偏移量，也就是</p><p>0x10000a + 0x5 + 0x5 = 0x100014</p><p>我们首先要去填写opcode_table[0xe8]，指示它的译码函数和执行函数，这个需要提前查看所有的译码函数选择恰当的一个，这里选择decode_J(),执行函数也是类似，选择exec_call()，位宽是4个字节，因此</p><p>opcode_table[0xe8]=IDEX(J, call)</p><p>接下来看译码函数，先明确译码函数的任务应该是再取4个字节作为偏移量，计算出跳转地址并保存在decoinfo中。</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_DHelper(J)</span> {</span><br><span class="line">  decode<span class="constructor">_op_SI(<span class="params">pc</span>, <span class="params">id_dest</span>, <span class="params">false</span>)</span>;</span><br><span class="line">  <span class="comment">// the target address can be computed in the decode stage</span></span><br><span class="line">  decinfo.jmp_pc = id_dest-&gt;simm + *pc;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个辅助函数是写好的，不用我们补充，但是decode_op_SI()函数需要我们自己填写，而且其实主要的工作还是这个函数完成，取width宽度的字节作为偏移量，然后如果width小于4的话，还要进一步进行符号位扩展，最后保存在op-&gt;simm中：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* I386 manual does not contain this abbreviation, but it is different from</span></span><br><span class="line"><span class="comment"> * the one above from the view of implementation. So we use another helper</span></span><br><span class="line"><span class="comment"> * function to decode it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* sign immediate */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">make_DopHelper</span><span class="params">(SI)</span> </span>{</span><br><span class="line">  assert(op-&gt;<span class="built_in">width</span> == <span class="number">1</span> || op-&gt;<span class="built_in">width</span> == <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  op-&gt;type = OP_TYPE_IMM;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Use instr_fetch() to read `op-&gt;width' bytes of memory</span></span><br><span class="line"><span class="comment">   * pointed by 'pc'. Interpret the result as a signed immediate,</span></span><br><span class="line"><span class="comment">   * and assign it to op-&gt;simm.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   op-&gt;simm = ???</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  s0 = instr_fetch(pc, op-&gt;<span class="built_in">width</span>);</span><br><span class="line">  rtl_sext(&amp;s0, &amp;s0, op -&gt; <span class="built_in">width</span>);</span><br><span class="line">  op -&gt; simm = s0;</span><br><span class="line"></span><br><span class="line">  rtl_li(&amp;op-&gt;val, op-&gt;simm);</span><br><span class="line"></span><br><span class="line">  print_Dop(op-&gt;str, OP_STR_SIZE, <span class="string">"$0x%x"</span>, op-&gt;simm);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里使用rtl_sext进行符号位扩展，不过rtl_sext()也需要自己补充：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_sext</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> <span class="built_in">width</span>)</span> </span>{</span><br><span class="line">  <span class="comment">// dest &lt;- signext(src1[(width * 8 - 1) .. 0])</span></span><br><span class="line">  <span class="keyword">int32_t</span> val = *src1;</span><br><span class="line">  *dest = (val &lt;&lt; (<span class="number">32</span> - <span class="built_in">width</span> * <span class="number">8</span>)) &gt;&gt; (<span class="number">32</span> - <span class="built_in">width</span> * <span class="number">8</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>译码函数算是写完了，再来看执行函数，还是先明确call执行函数的任务：先把下一条指令的地址(seq_pc)压栈，然后跳转到译码函数计算出来的地址(jmp_pc)。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(call) {</span><br><span class="line">  <span class="comment">// the target address is calculated at the decode stage</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl_push(&amp;decinfo.seq_pc);</span><br><span class="line">  rtl_j(decinfo.jmp_pc);</span><br><span class="line"></span><br><span class="line">  print_asm(<span class="string">"call %x"</span>, decinfo.jmp_pc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>rtl_j()已经给出，我们需要实现rtl_push()：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1)</span> </span>{</span><br><span class="line">  <span class="comment">// esp &lt;- esp - 4</span></span><br><span class="line">  <span class="comment">// M[esp] &lt;- src1</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  reg_l(R_ESP) -= <span class="number">4</span>;</span><br><span class="line">  rtl_sm(&amp;reg_l(R_ESP), src1, <span class="number">4</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用rtl_sm作为客户访存，把地址压栈。</p><p>整个call指令就算完成了，感觉还是蛮简单的，理解了过程以后真的做起来就感觉不难了。</p><h3 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h3><p>ret指令只有一个字节的opcode：</p><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100012</span>:<span class="keyword">c</span><span class="number">3</span>                   <span class="keyword">ret</span></span><br></pre></td></tr></tbody></table></figure><p>opcode_table[0xc3]=EX(ret)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(ret) {</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl_pop(&amp;decinfo.jmp_pc);</span><br><span class="line">  rtl_j(decinfo.jmp_pc);</span><br><span class="line"></span><br><span class="line">  print_asm(<span class="string">"ret"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>rtl_pop()</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_pop</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span> </span>{</span><br><span class="line">  <span class="comment">// dest &lt;- M[esp]</span></span><br><span class="line">  <span class="comment">// esp &lt;- esp + 4</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl_lm(dest, &amp;reg_l(R_ESP), <span class="number">4</span>);</span><br><span class="line">  reg_l(R_ESP) += <span class="number">4</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ret指令比较简单，就不用多讲了。</p><h3 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h3><p>push指令的opcode是0x68还有</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10001</span>a:<span class="number">68</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push   $<span class="number">0x0</span></span><br></pre></td></tr></tbody></table></figure><p>opcode_table[0x68]=IDEX(push_SI, push)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make_DHelper(push_SI) {</span><br><span class="line">  decode_op_SI(pc, id_dest, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>译码函数和call类似，不过不用计算和填写jmp_pc，只需要取到立即数。</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_EHelper(<span class="params">push</span>)</span> {</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl<span class="constructor">_push(&amp;<span class="params">id_dest</span>-&gt;<span class="params">val</span>)</span>;</span><br><span class="line"></span><br><span class="line">  print<span class="constructor">_asm_template1(<span class="params">push</span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>rtl_push已经实现过了，这样push指令也算完成了。</p><p>还有一条push的opcode是0x55，不要忘了。</p><h3 id="xor指令"><a href="#xor指令" class="headerlink" title="xor指令"></a>xor指令</h3><p>xor指令的opcode是0x31</p><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100010</span>:<span class="number">31</span> <span class="keyword">c</span><span class="number">0</span>                <span class="keyword">xor</span>    <span class="symbol">%eax</span>,<span class="symbol">%eax</span></span><br></pre></td></tr></tbody></table></figure><p>opcode_table[0x31]=IDEX(G2E, xor)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make_DHelper(G2E) {</span><br><span class="line">  decode_op_rm(pc, id_dest, <span class="literal">true</span>, id_src, <span class="literal">true</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decode_op_rm</span><span class="params">(<span class="keyword">vaddr_t</span> *pc, Operand *rm, <span class="keyword">bool</span> load_rm_val, Operand *reg, <span class="keyword">bool</span> load_reg_val)</span> </span>{</span><br><span class="line">  read_ModR_M(pc, rm, load_rm_val, reg, load_reg_val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>read_ModR_M再读取一个<code>ModR/M</code>字节,0xc0拆分后mod是3代表是reg类型，reg=0代表是EAX，r/m=0代表另一个操作数也是EAX。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(<span class="keyword">xor</span>) {</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl_xor(&amp;s0, &amp;id_dest-&gt;val, &amp;id_src-&gt;val);</span><br><span class="line">  operand_write(id_dest, &amp;s0);</span><br><span class="line">  rtl_update_ZFSF(&amp;s0, id_dest -&gt; <span class="built_in">width</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// CF = 0, OF = 0</span></span><br><span class="line">  s1 = <span class="number">0</span>;</span><br><span class="line">  rtl_set_CF(&amp;s1);</span><br><span class="line">  rtl_set_OF(&amp;s1);</span><br><span class="line">  </span><br><span class="line">  print_asm_template2(<span class="keyword">xor</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据手册提示，xor会把CF和OF设置为0，另外需要更新ZF和SF。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_update_ZF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> <span class="built_in">width</span>)</span> </span>{</span><br><span class="line">  <span class="comment">// eflags.ZF &lt;- is_zero(result[width * 8 - 1 .. 0])</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  t0 = *result &lt;&lt; (<span class="number">32</span> - <span class="built_in">width</span> * <span class="number">8</span>);</span><br><span class="line">  t0 = (t0 == <span class="number">0</span>);</span><br><span class="line">  rtl_set_ZF(&amp;t0);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_update_SF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> <span class="built_in">width</span>)</span> </span>{</span><br><span class="line">  <span class="comment">// eflags.SF &lt;- is_sign(result[width * 8 - 1 .. 0])</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  t0 = (*result) &gt;&gt; (<span class="number">8</span>*<span class="built_in">width</span><span class="number">-1</span>);</span><br><span class="line">  t0 = (t0 &amp; <span class="number">1</span>);</span><br><span class="line">  rtl_set_SF(&amp;t0);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要在这里补充，如何设置符号位，首先需要到PA1里面的reg.h里面修改CPU_state的定义，增加符号位寄存器，并且我们只需要关心其中的CF,ZF,SF,IF,OF。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">union</span>{</span><br><span class="line">        <span class="keyword">union</span>{</span><br><span class="line">            <span class="keyword">uint32_t</span> _32;</span><br><span class="line">            <span class="keyword">uint16_t</span> _16;</span><br><span class="line">            <span class="keyword">uint8_t</span> _8[<span class="number">2</span>];</span><br><span class="line">        } gpr[<span class="number">8</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">            <span class="keyword">rtlreg_t</span> eax, ecx, edx, ebx, esp, ebp, esi, edi;</span><br><span class="line">        };</span><br><span class="line">    };</span><br><span class="line">  <span class="comment">/* Do NOT change the order of the GPRs' definitions. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In NEMU, rtlreg_t is exactly uint32_t. This makes RTL instructions</span></span><br><span class="line"><span class="comment">   * in PA2 able to directly access these registers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">vaddr_t</span> pc;</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  <span class="keyword">union</span>{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">  <span class="keyword">uint32_t</span> CF:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> :<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> ZF:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> SF:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> :<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> IF:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> :<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> OF:<span class="number">1</span>;</span><br><span class="line">  }eflags;</span><br><span class="line">  <span class="keyword">uint32_t</span> eflags_value;</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">} CPU_state;</span><br></pre></td></tr></tbody></table></figure><p>这里要提醒一句，这里的结构体定义中，寄存器的顺序是不能随意改变的，要保证和qemu一致，否则后面的diff-test过不了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/11/03/ics2019%20pa/pa2_qemu-reg.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>顺便增加一条宏方便使用：</p><figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define reg_f(<span class="name">flag</span>) (<span class="name">cpu</span>.eflags.flag)</span><br></pre></td></tr></tbody></table></figure><p>然后到rtl.h修改set/get代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_rtl_setget_eflags(f) \</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">concat</span><span class="params">(rtl_set_, f)</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span> </span>{ \</span><br><span class="line">    reg_f(f) = *src;  \</span><br><span class="line">  } \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">concat</span><span class="params">(rtl_get_, f)</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span> </span>{ \</span><br><span class="line">    *dest = reg_f(f); \</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h3 id="sub指令"><a href="#sub指令" class="headerlink" title="sub指令"></a>sub指令</h3><p>sub指令的opcode=0x83</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100017</span>:<span class="number">83</span> ec <span class="number">14</span>             sub    $<span class="number">0x14</span>,%esp</span><br></pre></td></tr></tbody></table></figure><p>opcode_table已经填好了这一项</p><p>IDEX(SI2E, gp1)</p><p>译码函数已经写好，直接看执行函数exec_gp1，首先我们需要看exec.c文件里面</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_group(name, item0, item1, item2, item3, item4, item5, item6, item7) \</span></span><br><span class="line">  static OpcodeEntry concat(opcode_table_, name) [8] = { \</span><br><span class="line">    <span class="comment">/* 0x00 */</span>item0, item1, item2, item3, \</span><br><span class="line">    <span class="comment">/* 0x04 */</span>item4, item5, item6, item7  \</span><br><span class="line">  }; \</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">make_EHelper</span><span class="params">(name)</span> </span>{ \</span><br><span class="line">  idex(pc, &amp;concat(opcode_table_, name)[decinfo.isa.ext_opcode]); \</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 0x80, 0x81, 0x83 */</span></span><br><span class="line">make_group(gp1,</span><br><span class="line">    EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">    EMPTY, EMPTY, EMPTY, EMPTY)</span><br></pre></td></tr></tbody></table></figure><p>ext_opcode是5，因为译码的时候读了一个<code>ModR/M</code>字节0xec，其中3-5位作为ext_opcode，上面这一段可以翻译为</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exec_gp1</span><span class="params">(<span class="keyword">addr_t</span> *pc)</span></span>{</span><br><span class="line">    idex(pc, &amp;opcode_table_gp1[decinfo.isa.ext_opcode]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>也就是说又进行了一次译码，执行。因为ext_opcode是5，先把sub真正的执行函数填写进make_group</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0x80, 0x81, 0x83 */</span></span><br><span class="line">make_group(gp1,</span><br><span class="line">    EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">    EMPTY, EX(sub), EMPTY, EMPTY)</span><br></pre></td></tr></tbody></table></figure><p>SUB指令涉及到CF,OF,SF,ZF的更新：</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_EHelper(<span class="params">sub</span>)</span> {</span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  rtl<span class="constructor">_sub(&amp;<span class="params">s0</span>,&amp;<span class="params">id_dest</span>-&gt;<span class="params">val</span>,&amp;<span class="params">id_src</span>-&gt;<span class="params">val</span>)</span>;</span><br><span class="line">  operand<span class="constructor">_write(<span class="params">id_dest</span>,&amp;<span class="params">s0</span>)</span>;</span><br><span class="line">  <span class="comment">// update ZF SF</span></span><br><span class="line">  rtl<span class="constructor">_update_ZFSF(&amp;<span class="params">s0</span>,<span class="params">id_dest</span>-&gt;<span class="params">width</span>)</span>;</span><br><span class="line">  <span class="comment">// update CF</span></span><br><span class="line">  rtl<span class="constructor">_is_sub_carry(&amp;<span class="params">s1</span>,&amp;<span class="params">s0</span>,&amp;<span class="params">id_dest</span>-&gt;<span class="params">val</span>)</span>;</span><br><span class="line">  rtl<span class="constructor">_set_CF(&amp;<span class="params">s1</span>)</span>;</span><br><span class="line">  <span class="comment">// update OF</span></span><br><span class="line">  rtl<span class="constructor">_is_sub_overflow(&amp;<span class="params">s1</span>,&amp;<span class="params">s0</span>,&amp;<span class="params">id_dest</span>-&gt;<span class="params">val</span>,&amp;<span class="params">id_src</span>-&gt;<span class="params">val</span>,<span class="params">id_dest</span>-&gt;<span class="params">width</span>)</span>;</span><br><span class="line">  rtl<span class="constructor">_set_OF(&amp;<span class="params">s1</span>)</span>;</span><br><span class="line"></span><br><span class="line">  print<span class="constructor">_asm_template2(<span class="params">sub</span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>CF的判断比较简单：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rtl_is_sub_carry</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* res, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1)</span> </span>{</span><br><span class="line">  <span class="comment">// dest &lt;- is_carry(src1 - src2)</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  *dest = (*res &gt; *src1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>OF的判断标准是x与y异号，同时(x-y)与x异号：</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static inline <span class="built_in">void</span> rtl_is_sub_overflow(rtlreg_t* dest,</span><br><span class="line">    <span class="keyword">const</span> rtlreg_t* res, <span class="keyword">const</span> rtlreg_t* src1, <span class="keyword">const</span> rtlreg_t* src2, <span class="built_in">int</span> width) {</span><br><span class="line">  <span class="comment">// dest &lt;- is_overflow(src1 - src2)</span></span><br><span class="line">  <span class="comment">/* PA2.1 */</span></span><br><span class="line">  t0 =  ((*src1)&gt;&gt;(<span class="number">8</span>*width<span class="number">-1</span>)) &amp; <span class="number">1</span>;  </span><br><span class="line">  t1 =  ((*src2)&gt;&gt;(<span class="number">8</span>*width<span class="number">-1</span>)) &amp; <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">  rtl_xor(&amp;t1,&amp;t0,&amp;t1);</span><br><span class="line">  <span class="keyword">if</span>(t1==<span class="number">0</span>) *dest=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span>{</span><br><span class="line">    t1=((*res)&gt;&gt;(<span class="number">8</span>*width<span class="number">-1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">    rtl_xor(&amp;t0,&amp;t0,&amp;t1);</span><br><span class="line">    *dest = t0;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后不要忘记在all-instr.h里面加上你声明的函数。</p><p>PA2.1到此为止</p><h2 id="PA2-2"><a href="#PA2-2" class="headerlink" title="PA2.2"></a>PA2.2</h2><p>一上来先把tests里面的测试用例都要做了，这真没办法，一个个的实现，从add.c开始，这里我不可能再分步细说如何去做，步骤和PA2.1其实都一样，个别特殊的指令我会提一下，其他的（其实全部）都可以去看代码读明白。</p><h3 id="sete指令"><a href="#sete指令" class="headerlink" title="sete指令"></a>sete指令</h3><p>这是一条双字节opcode的指令，指令的格式如下</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>F  <span class="number">94</span>   SETE r/m8    <span class="number">4</span>/<span class="number">5</span>     Set byte <span class="keyword">if</span> equal (ZF=<span class="number">1</span>)</span><br><span class="line"><span class="comment">//IF condition THEN r/m8 := 1 ELSE r/m8 := 0; FI;</span></span><br></pre></td></tr></tbody></table></figure><p>opcode_table[0x0f]=EX(2byte_esc)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">make_EHelper</span><span class="params">(<span class="number">2b</span>yte_esc)</span> </span>{</span><br><span class="line">  <span class="keyword">uint32_t</span> opcode = instr_fetch(pc, <span class="number">1</span>) | <span class="number">0x100</span>;</span><br><span class="line">  decinfo.opcode = opcode;</span><br><span class="line">  set_width(opcode_table[opcode].<span class="built_in">width</span>);</span><br><span class="line">  idex(pc, &amp;opcode_table[opcode]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可见，需要再读入一个字节，然后以0x100+读入的字节作为索引重新搜索opcode_table。</p><p>另外根据第2个字节的低4位确定condition：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> invert = subcode &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">enum</span> {</span><br><span class="line">    CC_O, CC_NO, CC_B,  CC_NB,</span><br><span class="line">    CC_E, CC_NE, CC_BE, CC_NBE,</span><br><span class="line">    CC_S, CC_NS, CC_P,  CC_NP,</span><br><span class="line">    CC_L, CC_NL, CC_LE, CC_NLE</span><br><span class="line">  };</span><br></pre></td></tr></tbody></table></figure><p>需要完成cc.c文件里面的rtl_setcc()。</p><h3 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h3><p>按照手册提示，在这些测试文件中，string.c和hello-str.c需要实现常用的字符串库函数还有printf和sprintf，字符串库函数就不说了，大一的时候就经常做了。这里主要说下sprintf的实现。</p><p>在开始之前我要先说一些我在抄代码的时候发现的问题，我做实验的时候参考了2个github的代码，我抄的时候也会相互借鉴，有些地方我觉得可以改善的也会自己修改，因此会有些不同，我相信如果有人抄我代码的时候也不会无脑全抄吧。但是就是这细微的差别我发现使得我和github上面的opcode_table不一样，我来从头到尾讲一下，首先是对于sprintf的实现，其中%d的实现，我觉得其中一个人的不太好，开了个定长数组再倒叙输出数字，于是我选择了使用指针在原字符串的基础上进行倒叙，就不受长度限制了。但是我本来抄他的代码hit good trap了，也就是通过了测试，但是在我修改完sprintf的实现后，突然就告诉我有未实现的汇编指令，然后我打开反汇编一看，确实有一条我没有实现的汇编指令，然后我去看GitHub的opcode_table，发现他也没有实现，我又把代码抄回去，试了下他的代码，然后还是hit good trap了，我马上对比了一下反汇编结果，发现他的反汇编与我的反汇编是不一样的，他没有这条指令，也就是说，根据你对于sprintf的实现，你的反汇编结果是不一样的，要实现的汇编指令也不一定相同，因此如果你抄我的代码，但是又想修改，那你也有可能要加新的汇编指令。</p><p>接下来我们具体说下如何实现sprintf：</p><p>首先有必要了解下变长参数的原理，对va_list和va_start,va_end,va_arg的用法了解，可以自行上网搜索原理和用法，我看到的这篇博客感觉还可以<a href="https://www.cnblogs.com/pengdonglin137/p/3345911.html">理解可变参数va_list、va_start、va_arg、va_end原理及使用方法</a></p><p>刚好博客里面也有%d,%s的实现，我这里也就不用多说了，省点字:)</p><h3 id="diff-test"><a href="#diff-test" class="headerlink" title="diff-test"></a>diff-test</h3><p>很烦，这里我犯了一个蠢，所以我要先写在前面，不过我觉得应该没有多少人会和我一样:(，因为我觉得PA0不重要，就直接从PA1开始，结果我在这里diff-test就突然报错，好像是什么东西没装，我就感觉是自己环境配置有问题，然后反思了好久，最后想起来自己PA0没做，不会 PA0里面有什么关键的东西我没有装吧，然后一看果然diff-test最关键的qemu我没装:( 当然如果你是用的老师给的镜像装的话就不用管了，我现在也明白了，老师给的就是已经做好了PA0，把里面的工具环境都配置好的结果，谁让我不知道为啥非要从0开始。</p><p>回到正题，从手册可以知道，diff-test的方法是将自己的nemu作为ref，然后与qemu的执行一条一条比对从而及时发现错误，整个diff-test的代码大部分已经实现，唯一留给我们实现的只有x86/diff-test.c里面的isa_difftest_checkregs()，也就是对寄存器的状态进行比对，如果有一个寄存器的值不一致就返回false，否则返回true。代码倒是很简单，（而且手册说的顺序问题，反正抄就完事了）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isa_difftest_checkregs</span><span class="params">(CPU_state *ref_r, <span class="keyword">vaddr_t</span> pc)</span> </span>{</span><br><span class="line">  <span class="comment">/* PA2.2 */</span></span><br><span class="line">  <span class="keyword">if</span> (ref_r-&gt;eax != reg_l(R_EAX) || ref_r-&gt;ebx != reg_l(R_EBX) || ref_r-&gt;ecx != reg_l(R_ECX) || </span><br><span class="line">ref_r-&gt;edx != reg_l(R_EDX) || ref_r-&gt;ebp != reg_l(R_EBP) || ref_r-&gt;esi != reg_l(R_ESI) ||</span><br><span class="line">ref_r-&gt;edi != reg_l(R_EDI) || ref_r-&gt;pc != cpu.pc ) </span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在common.h里面将#define DIFF_TEST注释关掉，然后再nemu目录下执行bash runall.sh ISA=x86，反正我一次就全过了。</p><h2 id="PA2-3"><a href="#PA2-3" class="headerlink" title="PA2.3"></a>PA2.3</h2><h4 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h4><p>做法与PA2.2是差不多的，不过这里要实现IO的辅助函数，先去common.h中把HAS_IOE宏打开，然后按照手册的提示进行测试，会发现要求实现out指令。out的执行辅助函数实现如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(out) {</span><br><span class="line">  <span class="comment">//TODO();</span></span><br><span class="line">   <span class="keyword">switch</span>(id_src-&gt;<span class="built_in">width</span>){</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:pio_write_b(id_dest-&gt;val,id_src-&gt;val);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:pio_write_w(id_dest-&gt;val,id_src-&gt;val);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:pio_write_l(id_dest-&gt;val,id_src-&gt;val);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  print_asm_template2(out);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>in的也类似，这里也一起给出吧</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(in) {</span><br><span class="line">  <span class="comment">//TODO();</span></span><br><span class="line">  <span class="keyword">switch</span>(id_src-&gt;<span class="built_in">width</span>){</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:s0=pio_read_b(id_src-&gt;val);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:s0=pio_read_w(id_src-&gt;val);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:s0=pio_read_l(id_src-&gt;val);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  operand_write(id_dest,&amp;s0);</span><br><span class="line"></span><br><span class="line">  print_asm_template2(in);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="asm-volatile"><a href="#asm-volatile" class="headerlink" title="asm volatile"></a><strong>asm</strong> <strong>volatile</strong></h4><p>在进行下个阶段前，我觉得有必要先了解内嵌汇编语法，详细的请自行搜索了解，我给出一篇我觉得讲的不错的<a href="https://blog.csdn.net/ts_54eagle/article/details/1611399?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control"><strong>asm</strong> <strong>volatile</strong> GCC的内嵌汇编语法 AT&amp;T汇编语言语法</a></p><p>然后我总结一下</p><p>基本内联汇编的格式是</p><figure class="highlight sqf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">__asm__</span> <span class="variable">__volatile__</span>(<span class="string">"Instruction List"</span>);</span><br></pre></td></tr></tbody></table></figure><p>Instruction List是汇编指令序列，可以为空。</p><p>而在PA里面我们见到的更多的是带有C/C++表达式的内联汇编格式：</p><figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__　__volatile__(<span class="string">"Instruction List"</span> : <span class="type">Output</span> : <span class="type">Input</span> : <span class="type">Clobber</span>/Modify);</span><br></pre></td></tr></tbody></table></figure><p>两种格式对寄存器语法的要求不同：基本格式要求寄存器前只能使用一个百分号(%)，这一点和非内联汇编相同；而带有C/C++表达式格式则要求寄存器前必须使用两个百分号(%%)。</p><h5 id="output"><a href="#output" class="headerlink" title="output"></a>output</h5><p>Output用来指定当前内联汇编语句的输出。来看一个例子：</p><figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__(<span class="string">"movl %%cr0, %0"</span>: <span class="string">"=a"</span> (<span class="name">cr0</span>))<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure><p>这个输出操作由两部分组成：括号括住的部分(cr0)和引号引住的部分”=a”。括号括住的部分是一个C/C++表达式，用来保存内联汇编的一个输出值，其操作就等于C/C++的相等赋值cr0 = output_value，因此，括号中的输出表达式只能是C/C++的左值表达式。</p><p>引号中的内容，被称作“操作约束”（Operation Constraint），在这个例子中操作约束为”=a”，它包含两个约束：等号(=)和字母a，其中等号(=)说明括号中左值表达式cr0是一个 Write-Only的，只能够被作为当前内联汇编的输入，而不能作为输入。而字母a是寄存器EAX / AX / AL的简写，说明cr0的值要从eax寄存器中获取，也就是说cr0 = eax，最终这一点被转化成汇编指令就是movl %eax, address_of_cr0。</p><p>GCC的文档中声明等号(=)约束说明当前的表达式是一个 Write-Only的，加号(+)用来说明当前表达式是一个Read-Write的，如果一个操作约束中没有给出这两个符号中的任何一个，则说明当前表达式是Read-Only的。</p><h5 id="input"><a href="#input" class="headerlink" title="input"></a>input</h5><p>input域的内容用来指定当前内联汇编语句的输入。还是举个例子：</p><figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__(<span class="string">"movl %0, %%db7"</span> : : <span class="string">"a"</span> (<span class="name">cpu-&gt;db7</span>))<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure><p>像输出表达式一样，一个输入表达式也分为两部分：带括号的部分(cpu-&gt;db7)和带引号的部分”a”。括号中的表达式cpu-&gt;db7是一个C/C++语言的表达式，它不必是一个左值表达式，也就是说它不仅可以是放在C/C++赋值操作左边的表达式，还可以是放在C/C++赋值操作右边的表达式。</p><p>引号号中的部分是约束部分，和输出表达式约束不同的是，它不允许指定加号(+)约束和等号(=)约束，也就是说它只能是默认的Read-Only的。约束中必须指定一个寄存器约束，例中的字母a表示当前输入变量cpu-&gt;db7要通过寄存器eax输入到当前内联汇编中。</p><h5 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h5><p>一个带有C/C++表达式的内联汇编，其操作表达式被按照被列出的顺序编号，第一个是0，第2个是1，依次类推，GCC最多允许有10个操作表达式。举个例子：</p><figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__asm__ (<span class="string">"addl %1, %0/n/t"</span></span><br><span class="line">: <span class="string">"=a"</span>(<span class="name">__out</span>)</span><br><span class="line">: <span class="string">"m"</span> (<span class="name">__in1</span>), <span class="string">"a"</span> (<span class="name">__in2</span>))<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure><p>这个例子中的%0和%1就是占位符。每一个占位符对应一个Input/Output操作表达式。我们在之前已经提到，GCC规定一个内联汇编语句最多可以有 10个Input/Output操作表达式，然后按照它们被列出的顺序依次赋予编号0到9。对于占位符中的数字而言，和这些编号是对应的。</p><p>由于占位符前面使用一个百分号(%)，为了区别占位符和寄存器，GCC规定在带有C/C++表达式的内联汇编中，”Instruction List”中直接写出的寄存器前必须使用两个百分号(%%)。</p><p>以PA中的具体例子来分析一下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">inl</span><span class="params">(<span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">  <span class="keyword">uint32_t</span> data;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"inl %1, %0"</span> : <span class="string">"=a"</span>(data) : <span class="string">"d"</span>((<span class="keyword">uint16_t</span>)port))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Instruction List是inl %1, %0 ，其中%1指代”d”((uint16_t)port)也就是dx，%0指代”=a”(data)也就是eax，最后输入的来源是port变量，输出的值保存在了data中。</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>根据手册说明，我们可以从RTC寄存器中获取当前时间，在x86.h中找到其地址的宏是RTC_ADDR，也就是说我们可以使用前面介绍的inl()函数，inl(RTC_ADDR)来获取当前时间的值，单位是ms。</p><p>我们要先实现的只有_DEVREG_TIMER_UPTIME，AM系统启动时间. 从中读出<code>_DEV_TIMER_UPTIME_t</code>结构体, <code>(hi &lt;&lt; 32LL) | lo</code>是系统启动的毫秒数。</p><p>思路很简单，首先设置一个全局变量st_time，在<code>__am_timer_init()</code>中调用inl(RTC_ADDR)获取启动时间，保存在st_time中，然后在<code>__am_timer_read</code>中再读取一次时间，求出差值，就去AM的启动时间，然后按照手册说的格式保存在<code>_DEV_TIMER_UPTIME_t</code>结构体中。代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> time = inl(RTC_ADDR)-st_time;</span><br><span class="line">uptime-&gt;hi = (<span class="keyword">uint32_t</span>)(time&gt;&gt;<span class="number">32</span>);</span><br><span class="line">uptime-&gt;lo = (<span class="keyword">uint32_t</span>)(time &amp; <span class="number">0xffffffff</span>);</span><br></pre></td></tr></tbody></table></figure><p>完成时钟以后可以去按照手册说的测试nemu能跑多快，我microbench的跑分是374（感觉一般，放出来给大家一个参考），不过跑测试的时候会发现，其实仍然有许多指令没有完成，方法和PA2.2一样继续完善。但是有个指令我要单独说一下。</p><p>rol指令，为什么要单独说这个指令，因为他的辅助函数logic.c中没找到，但是确实用到了rol指令，我不知道是不是老师忘了，而且给的i386指令集里面也没找到，所以我这里需要说一下。</p><p>rol指令的功能是循环左移，将dest里面的数据循环左移src次，最后一次从左边移出去的最高位设置CF，如果src=1，就是只循环左移了一次，并且循环左移后的数据与原本的数据异号，则设置OF=1。如果src&gt;1，则OF没有意义。在logic.c加入rol的辅助函数代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(rol) {</span><br><span class="line">s0 = id_dest -&gt; val;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; id_src -&gt; val; ++ i){</span><br><span class="line">rtl_msb(&amp;s1, &amp;s0, id_dest-&gt;<span class="built_in">width</span>);</span><br><span class="line">s0 = s0 &lt;&lt; <span class="number">1</span>;</span><br><span class="line">s0 |= s1;</span><br><span class="line">rtl_set_CF(&amp;s1);</span><br><span class="line">}</span><br><span class="line">  operand_write(id_dest, &amp;s0);</span><br><span class="line"><span class="keyword">if</span>(id_src -&gt; val == <span class="number">1</span>){</span><br><span class="line">    rtl_msb(&amp;s0, &amp;s0, id_dest-&gt;<span class="built_in">width</span>);</span><br><span class="line">    s0 ^= s1;</span><br><span class="line">    rtl_set_CF(&amp;s0);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">print_asm_template2(rol);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>键盘的地址是KBD_ADDR，用inl(KBD_ADDR)获取键盘码，使用掩码KEYDOWN_MASK(0X8000)判断是按下还是松开，然后将键盘码保存在keycode中，代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PA2.3 */</span></span><br><span class="line">      <span class="keyword">uint32_t</span> key=inl(KBD_ADDR);</span><br><span class="line">      kbd-&gt;keydown = key &amp; KEYDOWN_MASK ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      kbd-&gt;keycode = key;</span><br></pre></td></tr></tbody></table></figure><p>这样就算完成了，不过还是可以看看手册里面说的MAP宏</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP(c, f) c(f)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> {</span><br><span class="line">  _KEY_NONE = <span class="number">0</span>,</span><br><span class="line">  MAP(_KEYS, _KEY_NAME)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _KEY_NAME(k) _KEY_##k,</span></span><br></pre></td></tr></tbody></table></figure><p>再结合下面的图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/11/03/ics2019%20pa/pa2_f.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一层层拆开宏，最后的结果就是在enum中，按图中的键盘顺序为枚举了每个键盘号。算是学到了一种方法。</p><h3 id="VGA"><a href="#VGA" class="headerlink" title="VGA"></a>VGA</h3><p>根据手册说明，宽高是400×300不变，所以<code>__am_video_read</code>中，宽高是常数。</p><p>在<code>__am_video_write</code>中由传入参数buf指向一个<code>_DEV_VIDEO_FBCTL_t</code>结构体，其成员变量x和y指示起始坐标，w和h指示要绘制的宽高，pixels是一个行优先存储像素RGBA的数组。我们要做的是在FB_ADDR开始的一片内存中找到上述起始坐标开始的位置然后填入w*h个像素。代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_DEV_VIDEO_FBCTL_t *ctl = (_DEV_VIDEO_FBCTL_t *)buf;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> x=ctl-&gt;x,y=ctl-&gt;y,h=ctl-&gt;h,w=ctl-&gt;w;</span><br><span class="line">      <span class="keyword">uint32_t</span> *pixels = ctl-&gt;pixels;</span><br><span class="line">      <span class="keyword">uint32_t</span> *fb=(<span class="keyword">uint32_t</span> *)(<span class="keyword">uintptr_t</span>)FB_ADDR;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++){</span><br><span class="line">          fb[(y+i)*W+x+j]=pixels[i*w+j];</span><br><span class="line">        }</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p>然后在vga.c中，将控制更新屏幕的代码填上：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vga_io_handler</span><span class="params">(<span class="keyword">uint32_t</span> offset, <span class="keyword">int</span> len, <span class="keyword">bool</span> is_write)</span> </span>{</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> call `update_screen()` when writing to the sync register</span></span><br><span class="line">  <span class="comment">/* PA2.3 */</span></span><br><span class="line">  <span class="keyword">if</span>(is_write){</span><br><span class="line">    update_screen();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>PA2.3就算做完了，输入和输出的代码量很少，主要还是PA2.2工作量比较大，然后PA2.3测试的时候发现居然还有很多指令需要实现，然后又回去填opocde_table很烦。</p><h1 id="PA3"><a href="#PA3" class="headerlink" title="PA3"></a>PA3</h1><p>我很想吐槽x86后面不都是5星难度了吗，为什么还是感觉比其他指令复杂。</p><h2 id="PA-3-1"><a href="#PA-3-1" class="headerlink" title="PA 3.1"></a>PA 3.1</h2><h3 id="设置异常入口地址"><a href="#设置异常入口地址" class="headerlink" title="设置异常入口地址"></a>设置异常入口地址</h3><p>PA3.1要求实现x86的中断指令int，首先需要认真阅读手册，理解x86的异常响应机制和中断描述符表，大概总结一下。</p><p>IDT（中断描述符表）是一个数组，每个元素是一个门描述符，门描述符是一个8字节结构体，简化以后，就只有存在位和异常入口地址这两个重要信息。在<code>_cte_init</code>（cte.c）中创建了一个idt数组：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _cte_init(_Context*(*handler)(_Event, _Context*)) {</span><br><span class="line">  <span class="keyword">static</span> GateDesc idt[NR_IRQ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize IDT</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_IRQ; i ++) {</span><br><span class="line">    idt[i] = GATE(STS_TG32, KSEL(SEG_KCODE), __am_vecnull, DPL_KERN);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------------- interrupts ----------------------------</span></span><br><span class="line">  idt[<span class="number">32</span>]   = GATE(STS_IG32, KSEL(SEG_KCODE), __am_irq0,   DPL_KERN);</span><br><span class="line">  <span class="comment">// ---------------------- system call ----------------------------</span></span><br><span class="line">  idt[<span class="number">0x80</span>] = GATE(STS_TG32, KSEL(SEG_KCODE), __am_vecsys, DPL_USER);</span><br><span class="line">  idt[<span class="number">0x81</span>] = GATE(STS_TG32, KSEL(SEG_KCODE), __am_vectrap, DPL_KERN);</span><br><span class="line"></span><br><span class="line">  set_idt(idt, <span class="keyword">sizeof</span>(idt));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register event handler</span></span><br><span class="line">  user_handler = handler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>设置好IDT以后，要将IDT的地址和长度保存在特殊的寄存器IDTR中，也就是<code>set_idt(idt, sizeof(idt))</code>的任务：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_idt</span><span class="params">(GateDesc *idt, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">uint16_t</span> data[<span class="number">3</span>];</span><br><span class="line">  data[<span class="number">0</span>] = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">  data[<span class="number">1</span>] = (<span class="keyword">uint32_t</span>)idt;</span><br><span class="line">  data[<span class="number">2</span>] = (<span class="keyword">uint32_t</span>)idt &gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"lidt (%0)"</span> : : <span class="string">"r"</span>(data))</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们需要实现lidt指令，其源操作数指出了长度和地址的信息所在内存地址，一共是3个双字，第一个双字是长度，后面2个双字是地址，我们需要将这些信息存储在idtr寄存器中，因此首先我们需要修改reg.h文件里面对CPU_state的定义：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PA3 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line">    <span class="keyword">uint16_t</span> limit;</span><br><span class="line">    <span class="keyword">uint32_t</span> base;</span><br><span class="line">  }idtr;</span><br></pre></td></tr></tbody></table></figure><p>增加一个idtr结构体成员变量到CPU_state中。</p><p>然后我们就可以实现lidt的辅助函数了：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(lidt) {</span><br><span class="line">  </span><br><span class="line">  cpu.idtr.limit = vaddr_read(id_dest-&gt;addr,<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span>(decinfo.isa.is_operand_size_16){</span><br><span class="line">    cpu.idtr.base = vaddr_read(id_dest-&gt;addr+<span class="number">2</span>,<span class="number">4</span>) &amp;&amp; <span class="number">0x00ffffff</span>;</span><br><span class="line">  }<span class="keyword">else</span>{</span><br><span class="line">    cpu.idtr.base = vaddr_read(id_dest-&gt;addr+<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  print_asm_template1(lidt);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="触发自陷操作"><a href="#触发自陷操作" class="headerlink" title="触发自陷操作"></a>触发自陷操作</h3><p>实现raise_intr()函数，并借此实现int操作，raise_intr()完成的工作如下：</p><ol><li>依次将eflags, cs(代码段寄存器), eip(也就是PC)寄存器的值压栈</li><li>从IDTR中读出IDT的首地址</li><li>根据异常号在IDT中进行索引, 找到一个门描述符</li><li>将门描述符中的offset域组合成异常入口地址</li><li>跳转到异常入口地址</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_intr</span><span class="params">(<span class="keyword">uint32_t</span> NO, <span class="keyword">vaddr_t</span> ret_addr)</span> </span>{</span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Trigger an interrupt/exception with ``NO''.</span></span><br><span class="line"><span class="comment">   * That is, use ``NO'' to index the IDT.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* PA3.1 */</span></span><br><span class="line">   rtl_push(&amp;cpu.eflags_value);</span><br><span class="line">   rtl_push(&amp;cpu.cs);</span><br><span class="line">   rtl_push(&amp;ret_addr);</span><br><span class="line">   cpu.eflags.IF = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">vaddr_t</span> idt_addr = cpu.idtr.base + <span class="keyword">sizeof</span>(GateDesc)*NO;</span><br><span class="line">   <span class="keyword">vaddr_t</span> low_addr = vaddr_read(idt_addr,<span class="number">2</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">   <span class="keyword">vaddr_t</span> high_addr = vaddr_read(idt_addr+<span class="number">4</span>,<span class="number">4</span>) &amp; <span class="number">0xffff0000</span>;</span><br><span class="line">   decinfo.jmp_pc = high_addr | low_addr;</span><br><span class="line">   decinfo.is_jmp = <span class="number">1</span>;</span><br><span class="line">   rtl_j(decinfo.jmp_pc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>cs寄存器在PA中并没有发挥作用，但仍需修改reg.h增加对其的定义。</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_EHelper(<span class="params">int</span>)</span> {</span><br><span class="line">  </span><br><span class="line">  raise<span class="constructor">_intr(<span class="params">id_dest</span>-&gt;<span class="params">val</span>,<span class="params">decinfo</span>.<span class="params">seq_pc</span>)</span>;</span><br><span class="line">  print<span class="constructor">_asm(<span class="string">"int %s"</span>, <span class="params">id_dest</span>-&gt;<span class="params">str</span>)</span>;</span><br><span class="line"></span><br><span class="line">  difftest<span class="constructor">_skip_dut(1, 2)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>记得在init.c中添加初始化：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">/* Set the initial program counter. */</span></span><br><span class="line">  cpu.pc = PC_START;</span><br><span class="line">  cpu.cs = <span class="number">8</span>;</span><br><span class="line">  cpu.eflags_value = <span class="number">0x2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="上下文保存"><a href="#上下文保存" class="headerlink" title="上下文保存"></a>上下文保存</h3><p>为了重新组织_Context结构体，需要先了解压栈顺序，执行int指令，进入raise_intr函数，eflags, cs, ret_addr依次入栈，跳转到IDT，在trap.S中，每个中断先把自己的中断号压栈，然后jmp __am_asm_trap，在 <code>__am_asm_trap</code>中先执行pushal指令也就是pusha：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(pusha) {</span><br><span class="line">  </span><br><span class="line">  s0 = reg_l(R_ESP);</span><br><span class="line">  rtl_push(&amp;reg_l(R_EAX));</span><br><span class="line">  rtl_push(&amp;reg_l(R_ECX));</span><br><span class="line">  rtl_push(&amp;reg_l(R_EDX));</span><br><span class="line">  rtl_push(&amp;reg_l(R_EBX));</span><br><span class="line">  rtl_push(&amp;s0);</span><br><span class="line">  rtl_push(&amp;reg_l(R_EBP));</span><br><span class="line">  rtl_push(&amp;reg_l(R_ESI));</span><br><span class="line">  rtl_push(&amp;reg_l(R_EDI));</span><br><span class="line"></span><br><span class="line">  print_asm(<span class="string">"pusha"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>寄存器压栈顺序如上，然后pushl $0，根据手册，这是一个占位符，最后pushl %esp然后call __am_irq_handle：</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Context* <span class="constructor">__am_irq_handle(<span class="params">_Context</span> <span class="operator">*</span><span class="params">c</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><p>其传入参数是一个_Context指针，现在我们来看看栈的状态，如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2020/11/03/ics2019%20pa/pa3_stack.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>栈顶的esp是作为_Context指针传入，下面作为_Context结构体的成员，因此_Context结构体定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Context</span> {</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">AddressSpace</span> *<span class="title">as</span>;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> edi, esi, ebp, esp, ebx, edx, ecx, eax;</span><br><span class="line">  <span class="keyword">int</span> irq;</span><br><span class="line">  <span class="keyword">uintptr_t</span> eip,cs,eflags;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><p>首先在<code>__am_irq_handle</code>加入switch case为event赋值，暂时只用到yield事件，其他两个也可以先加上：</p><figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c-&gt;irq) {</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x20</span>:ev.<span class="keyword">event</span> = _EVENT_IRQ_TIMER;<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x80</span>:ev.<span class="keyword">event</span> = _EVENT_SYSCALL;<span class="keyword">break</span>; </span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x81</span>:ev.<span class="keyword">event</span> = _EVENT_YIELD;<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: ev.<span class="keyword">event</span> = _EVENT_ERROR; <span class="keyword">break</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>然后在<code>do_event()</code>中添加输出信息，先输出Log，之后会修改：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> _Context* <span class="title">do_event</span><span class="params">(_Event e, _Context* c)</span> </span>{</span><br><span class="line">  <span class="keyword">switch</span> (e.event) {</span><br><span class="line">    <span class="keyword">case</span> _EVENT_YIELD: Log(<span class="string">"yield event"</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _EVENT_SYSCALL: <span class="keyword">return</span> do_syscall(c);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">"Unhandled event ID = %d"</span>, e.event);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="恢复上下文"><a href="#恢复上下文" class="headerlink" title="恢复上下文"></a>恢复上下文</h3><p>实现popa指令和iret指令，记得按照一定顺序：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(popa) {</span><br><span class="line">  </span><br><span class="line">  rtl_pop(&amp;cpu.edi);</span><br><span class="line">  rtl_pop(&amp;cpu.esi);</span><br><span class="line">  rtl_pop(&amp;cpu.ebp);</span><br><span class="line">  rtl_pop(&amp;s0);</span><br><span class="line">  rtl_pop(&amp;cpu.ebx);</span><br><span class="line">  rtl_pop(&amp;cpu.edx);</span><br><span class="line">  rtl_pop(&amp;cpu.ecx);</span><br><span class="line">  rtl_pop(&amp;cpu.eax);</span><br><span class="line"></span><br><span class="line">  print_asm(<span class="string">"popa"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">make<span class="constructor">_EHelper(<span class="params">iret</span>)</span> {</span><br><span class="line">  </span><br><span class="line">  rtl<span class="constructor">_pop(&amp;<span class="params">decinfo</span>.<span class="params">jmp_pc</span>)</span>;</span><br><span class="line">  rtl<span class="constructor">_pop(&amp;<span class="params">cpu</span>.<span class="params">cs</span>)</span>;</span><br><span class="line">  rtl<span class="constructor">_pop(&amp;<span class="params">cpu</span>.<span class="params">eflags_value</span>)</span>;</span><br><span class="line">  </span><br><span class="line">  rtl<span class="constructor">_j(<span class="params">decinfo</span>.<span class="params">jmp_pc</span>)</span>;</span><br><span class="line"></span><br><span class="line">  print<span class="constructor">_asm(<span class="string">"iret"</span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="PA3-2"><a href="#PA3-2" class="headerlink" title="PA3.2"></a>PA3.2</h2><h3 id="实现loader"><a href="#实现loader" class="headerlink" title="实现loader"></a>实现loader</h3><p>loader后面还要重新修改，第一次不用管输入参数，只用<code>ramdisk_read</code>和<code>ramdisk_write</code>实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> <span class="title">loader</span><span class="params">(PCB *pcb, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span> </span>{</span><br><span class="line">  Elf_Ehdr elfheader;</span><br><span class="line">  Elf_Phdr programheader;</span><br><span class="line">  <span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> p_offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> len = (<span class="keyword">size_t</span>)<span class="keyword">sizeof</span>(Elf_Ehdr);</span><br><span class="line">  </span><br><span class="line">  ramdisk_read(&amp;elfheader,offset,len);</span><br><span class="line">  offset = elfheader.e_phoff;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i=<span class="number">0</span>; i&lt;elfheader.e_phnum; i++){</span><br><span class="line"></span><br><span class="line">    ramdisk_read(&amp;programheader,offset,(<span class="keyword">size_t</span>)<span class="keyword">sizeof</span>(Elf_Phdr));</span><br><span class="line">    offset+=<span class="keyword">sizeof</span>(Elf_Phdr);</span><br><span class="line">    <span class="keyword">if</span>(programheader.p_type == PT_LOAD){</span><br><span class="line">      <span class="keyword">uint8_t</span> buf[programheader.p_filesz];</span><br><span class="line">      ramdisk_read(&amp;buf,programheader.p_offset,programheader.p_filesz);</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)programheader.p_vaddr,&amp;buf,programheader.p_filesz);</span><br><span class="line">      <span class="built_in">memset</span>((<span class="keyword">void</span>*)(programheader.p_vaddr+programheader.p_filesz),<span class="number">0</span>,(programheader.p_memsz-programheader.p_filesz));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> elfheader.e_entry;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>loader的作用是把程序加载到指定内存位置，根据手册说明，一开始dummy的ELF头部文件在偏移为0的位置，从elf头部信息中提取出e_phoff和e_phnum，也就是程序头部偏移位置和个数，接下来从这个位置开始连续读e_phnum次。</p><p>从程序头部信息中提取5个重要的成员，第1个是p_type，程序类型，只有当值为PT_LOAD的时候，我们才加载这个头部对应的程序。第2个是p_offset，他指示我们这个头部对应的程序的偏移地址。第3个是p_vaddr，他指示我们应该将程序拷贝到的目的地址，剩下2个成员是p_filesz和p_memsz，分别是文件大小和内存大小。</p><p>根据手册说明，我们需要把p_offset开始的p_filesz个字节的程序拷贝到从p_vaddr开始的内存中，另外还需要将p_vaddr+p_filesz到p_vaddr+p_memsz结束的内存设置为0。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_proc</span><span class="params">()</span> </span>{</span><br><span class="line">  switch_boot_pcb();</span><br><span class="line"></span><br><span class="line">  Log(<span class="string">"Initializing processes..."</span>);</span><br><span class="line">  <span class="comment">// load program here</span></span><br><span class="line">  naive_uload(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试结果应该是触发了一个1号系统调用，显示</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unhandled syscall ID = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>首先在x86-nemu.h中声明几个系统调用有关的宏：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPR1 eax</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPR2 ebx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPR3 ecx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPR4 edx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPRx eax</span></span><br></pre></td></tr></tbody></table></figure><p>在<code>do_event</code>函数中调用<code>do_syscall(c)</code>传递上下文处理系统调用。</p><p>在syscall.c中补全<code>do_syscall</code>的switch-case：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_Context* <span class="title">do_syscall</span><span class="params">(_Context *c)</span> </span>{</span><br><span class="line">  <span class="keyword">uintptr_t</span> a[<span class="number">4</span>];</span><br><span class="line">  a[<span class="number">0</span>] = c-&gt;GPR1;</span><br><span class="line">  a[<span class="number">1</span>] = c-&gt;GPR2;</span><br><span class="line">  a[<span class="number">2</span>] = c-&gt;GPR3;</span><br><span class="line">  a[<span class="number">3</span>] = c-&gt;GPR4;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">switch</span> (a[<span class="number">0</span>]) {</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: sys_exit(a[<span class="number">1</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_yield: result=sys_yield();<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: result = sys_write(a[<span class="number">1</span>],(<span class="keyword">void</span>*)a[<span class="number">2</span>],a[<span class="number">3</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_brk: result=sys_brk(a[<span class="number">1</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">"Unhandled syscall ID = %d"</span>, a[<span class="number">0</span>]);</span><br><span class="line">  }</span><br><span class="line">  c-&gt;GPRx=result;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>目前只要补充<code>SYS_exit</code>和<code>SYS_yield</code>，其他的马上要做</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_yield</span><span class="params">()</span></span>{</span><br><span class="line">  _yield();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">uintptr_t</span> arg)</span></span>{</span><br><span class="line">  _halt(arg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行dummy进行测试，成功hit good trap说明实现完成</p><h3 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h3><p>添加<code>sys_write</code>系统调用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> count)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(fd==<span class="number">1</span>||fd==<span class="number">2</span>){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++){</span><br><span class="line">      _putc(((<span class="keyword">char</span> *)buf)[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外不要忘记在<code>navy-apps/libs/libos/src/nanos.c</code>的<code>_write()</code>中调用系统调用接口函数，我就是没仔细看手册，漏了这句话，还去调试了半天，很难受</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _write(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count) {</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_write,fd,buf,count);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="堆区管理"><a href="#堆区管理" class="headerlink" title="堆区管理"></a>堆区管理</h3><p>因为暂时不用实现具体的内存分配，所以按照手册说的只需要系统调用的时候返回0表示成功即可：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_brk</span><span class="params">(<span class="keyword">uintptr_t</span> increment)</span></span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接口方面，按照手册说明的流程做</p><ol><li><p>program break一开始的位置位于<code>_end</code></p></li><li><p>被调用时, 根据记录的program break位置和参数<code>increment</code>, 计算出新program break</p></li><li><p>通过<code>SYS_brk</code>系统调用来让操作系统设置新program break</p></li><li><p>若<code>SYS_brk</code>系统调用成功, 该系统调用会返回<code>0</code>, 此时更新之前记录的program break的位置, 并将旧program break的位置作为<code>_sbrk()</code>的返回值返回</p></li><li><p>若该系统调用失败, <code>_sbrk()</code>会返回-1</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *_sbrk(<span class="keyword">intptr_t</span> increment) {</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* program_break = (<span class="keyword">uintptr_t</span>)&amp;_end;</span><br><span class="line">  <span class="keyword">void</span>* old = program_break;</span><br><span class="line">  <span class="keyword">if</span>(_syscall_(SYS_brk,(<span class="keyword">uintptr_t</span>)(program_break+increment),<span class="number">0</span>,<span class="number">0</span>)==<span class="number">0</span>){</span><br><span class="line">    program_break+=increment;</span><br><span class="line">    <span class="keyword">return</span>(<span class="keyword">void</span>*)old;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="PA3-3"><a href="#PA3-3" class="headerlink" title="PA3.3"></a>PA3.3</h2><h3 id="loader使用文件"><a href="#loader使用文件" class="headerlink" title="loader使用文件"></a>loader使用文件</h3><p>要求实现一个简单的文件系统，这一步要实现<code>fs_open()</code>, <code>fs_read()</code>和<code>fs_close()</code></p><p><code>fs_close()</code>只要return 0即可</p><p><code>fs_open()</code>要用传入的文件名与<code>file_table</code>中的文件名一一比对，返回找到的下标，并设置<code>open_offset</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fs_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode)</span></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NR_FILES;i++){</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(file_table[i].name,pathname)==<span class="number">0</span>){</span><br><span class="line">      file_table[i].open_offset=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"file %s does not exist!"</span>,pathname);</span><br><span class="line">  assert(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>fs_read()</code>要注意如果文件剩余大小不足len，要更改读的大小，对于<code>stdin</code>, <code>stdout</code>和<code>stderr</code>这三个特殊文件的操作可以直接忽略。其他的使用<code>ramdisk_read</code>进行读操作，并更新<code>open_offset</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fs_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span></span>{</span><br><span class="line">assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r_len = len;</span><br><span class="line"><span class="keyword">if</span>(file_table[fd].<span class="built_in">size</span> &gt; <span class="number">0</span> &amp;&amp; file_table[fd].open_offset + len &gt; file_table[fd].<span class="built_in">size</span>) {</span><br><span class="line">r_len = file_table[fd].<span class="built_in">size</span> - file_table[fd].open_offset;</span><br><span class="line">}</span><br><span class="line">assert(r_len &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (fd)</span><br><span class="line">  {</span><br><span class="line">  <span class="keyword">case</span> FD_STDIN:</span><br><span class="line">  <span class="keyword">case</span> FD_STDOUT:</span><br><span class="line">  <span class="keyword">case</span> FD_STDERR: <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    length=ramdisk_read(buf,file_table[fd].disk_offset+file_table[fd].open_offset,r_len);</span><br><span class="line">    file_table[fd].open_offset += length;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里额外实现一个返回<code>disk_offset</code>的函数方便loader使用，后面实现了lseek以后可以删掉</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fs_disk_offset</span><span class="params">(<span class="keyword">int</span> fd)</span></span>{</span><br><span class="line">  <span class="keyword">return</span> file_table[fd].disk_offset;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>记得在nanos.c实现接口</p><p>修改loader函数，注意地址要加上文件的<code>disk_offset</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> <span class="title">loader</span><span class="params">(PCB *pcb, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span> </span>{</span><br><span class="line">  Elf_Ehdr elfheader;</span><br><span class="line">  Elf_Phdr programheader;</span><br><span class="line">  <span class="keyword">int</span> fd = fs_open(filename,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  assert(fd!=<span class="number">-1</span>);</span><br><span class="line">  fs_read(fd,&amp;elfheader,<span class="keyword">sizeof</span>(Elf_Ehdr));</span><br><span class="line">  <span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> p_offset = <span class="number">0</span>;</span><br><span class="line">  offset = elfheader.e_phoff+fs_disk_offset(fd);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i=<span class="number">0</span>; i&lt;elfheader.e_phnum; i++){</span><br><span class="line"></span><br><span class="line">    ramdisk_read(&amp;programheader,offset,(<span class="keyword">size_t</span>)<span class="keyword">sizeof</span>(Elf_Phdr));</span><br><span class="line">    offset+=<span class="keyword">sizeof</span>(Elf_Phdr);</span><br><span class="line">    <span class="keyword">if</span>(programheader.p_type == PT_LOAD){</span><br><span class="line">      <span class="keyword">uint8_t</span> buf[programheader.p_filesz];</span><br><span class="line">      p_offset = programheader.p_offset + fs_disk_offset(fd);</span><br><span class="line">      ramdisk_read(&amp;buf,p_offset,programheader.p_filesz);</span><br><span class="line">      <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)programheader.p_vaddr,&amp;buf,programheader.p_filesz);</span><br><span class="line">      <span class="built_in">memset</span>((<span class="keyword">void</span>*)(programheader.p_vaddr+programheader.p_filesz),<span class="number">0</span>,(programheader.p_memsz-programheader.p_filesz));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">  fs_close(fd);</span><br><span class="line">  <span class="keyword">return</span> elfheader.e_entry;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改proc.c，调用<code>naive_uload</code>测试dummy，然后测试hello</p><figure class="highlight lisp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">naive_uload(<span class="name">NULL</span>, <span class="string">"/bin/hello"</span>)<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="实现完整的文件系统"><a href="#实现完整的文件系统" class="headerlink" title="实现完整的文件系统"></a>实现完整的文件系统</h3><p>用<code>fs_read</code>类似的方法实现<code>fs_write</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fs_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span></span>{</span><br><span class="line">assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w_len = len;</span><br><span class="line"><span class="keyword">if</span>(file_table[fd].<span class="built_in">size</span> &gt; <span class="number">0</span>&amp;&amp; file_table[fd].open_offset + len &gt; file_table[fd].<span class="built_in">size</span>) {</span><br><span class="line">w_len = file_table[fd].<span class="built_in">size</span> - file_table[fd].open_offset;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">assert(w_len &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (fd)</span><br><span class="line">  {</span><br><span class="line">  <span class="keyword">case</span> FD_STDIN: <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> FD_STDOUT:</span><br><span class="line">  <span class="keyword">case</span> FD_STDERR: {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++){</span><br><span class="line">      _putc(((<span class="keyword">char</span> *)buf)[i]);</span><br><span class="line">      length=len;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    length=ramdisk_write(buf,file_table[fd].disk_offset+file_table[fd].open_offset,w_len);</span><br><span class="line">    file_table[fd].open_offset += length;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>fs_lseek</code>要实现3种情况，不过感觉只有<code>SEEK_SET</code>常用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fs_lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">size_t</span> offset, <span class="keyword">int</span> whence)</span></span>{</span><br><span class="line">assert(fd &gt;= <span class="number">0</span> &amp;&amp; fd &lt; NR_FILES);</span><br><span class="line"><span class="keyword">size_t</span> open_offset = file_table[fd].open_offset;</span><br><span class="line"><span class="keyword">switch</span> (whence) {</span><br><span class="line"><span class="keyword">case</span> SEEK_SET: </span><br><span class="line">open_offset = offset;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SEEK_CUR:</span><br><span class="line">open_offset += offset;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SEEK_END:</span><br><span class="line">open_offset = file_table[fd].<span class="built_in">size</span> + offset;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: panic(<span class="string">"There is no such whence"</span>);</span><br><span class="line">}</span><br><span class="line">file_table[fd].open_offset = open_offset;</span><br><span class="line"><span class="keyword">return</span> open_offset;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现这些以后就可以修改loader函数了，注意最开始的实现是有问题的，因为开了一个filesz的数组，但是当换成bin/text测试的时候，会出现越界的问题，数组开的过大，所以这里不要开数组，直接传vaddr的地址给<code>fs_read</code>即可：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> <span class="title">loader</span><span class="params">(PCB *pcb, <span class="keyword">const</span> <span class="keyword">char</span> *filename)</span> </span>{</span><br><span class="line">  Elf_Ehdr elfheader;</span><br><span class="line">  Elf_Phdr programheader;</span><br><span class="line">  <span class="keyword">int</span> fd = fs_open(filename,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  assert(fd!=<span class="number">-1</span>);</span><br><span class="line">  fs_read(fd,&amp;elfheader,<span class="keyword">sizeof</span>(Elf_Ehdr));</span><br><span class="line">  fs_lseek(fd,elfheader.e_phoff,SEEK_SET);</span><br><span class="line">  <span class="keyword">size_t</span> open_offset;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint16_t</span> i=<span class="number">0</span>; i&lt;elfheader.e_phnum; i++){</span><br><span class="line"></span><br><span class="line">    fs_read(fd,&amp;programheader,<span class="keyword">sizeof</span>(Elf_Phdr));</span><br><span class="line">    open_offset = fs_open_offset(fd);</span><br><span class="line">    <span class="keyword">if</span>(programheader.p_type == PT_LOAD){</span><br><span class="line">      fs_lseek(fd,programheader.p_offset,SEEK_SET);</span><br><span class="line">      fs_read(fd,(<span class="keyword">void</span> *)programheader.p_vaddr,programheader.p_filesz);</span><br><span class="line">      <span class="built_in">memset</span>((<span class="keyword">void</span>*)(programheader.p_vaddr+programheader.p_filesz),<span class="number">0</span>,(programheader.p_memsz-programheader.p_filesz));</span><br><span class="line">    }</span><br><span class="line">    fs_lseek(fd,open_offset,SEEK_SET);</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">  fs_close(fd);</span><br><span class="line">  <span class="keyword">return</span> elfheader.e_entry;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现完上述文件操作以后记得补充相关的系统调用：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _open(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode) {</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_open,(<span class="keyword">uintptr_t</span>)path,flags,mode);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _write(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count) {</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_write,fd,buf,count);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count) {</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_read,fd,(<span class="keyword">uintptr_t</span>)buf,count);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _close(<span class="keyword">int</span> fd) {</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_close,fd,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> _lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence) {</span><br><span class="line">  <span class="keyword">return</span> _syscall_(SYS_lseek,fd,offset,whence);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_Context* <span class="title">do_syscall</span><span class="params">(_Context *c)</span> </span>{</span><br><span class="line">  <span class="keyword">uintptr_t</span> a[<span class="number">4</span>];</span><br><span class="line">  a[<span class="number">0</span>] = c-&gt;GPR1;</span><br><span class="line">  a[<span class="number">1</span>] = c-&gt;GPR2;</span><br><span class="line">  a[<span class="number">2</span>] = c-&gt;GPR3;</span><br><span class="line">  a[<span class="number">3</span>] = c-&gt;GPR4;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">switch</span> (a[<span class="number">0</span>]) {</span><br><span class="line">    <span class="keyword">case</span> SYS_exit: sys_exit(a[<span class="number">1</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_yield: result=sys_yield();<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_open: result=fs_open((<span class="keyword">char</span>*)a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_read: result = fs_read(a[<span class="number">1</span>],(<span class="keyword">void</span>*)a[<span class="number">2</span>],a[<span class="number">3</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_write: result = fs_write(a[<span class="number">1</span>],(<span class="keyword">void</span>*)a[<span class="number">2</span>],a[<span class="number">3</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_close: result = fs_close(a[<span class="number">1</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_lseek: result = fs_lseek(a[<span class="number">1</span>],a[<span class="number">2</span>],a[<span class="number">3</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_brk: result=sys_brk(a[<span class="number">1</span>]);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: panic(<span class="string">"Unhandled syscall ID = %d"</span>, a[<span class="number">0</span>]);</span><br><span class="line">  }</span><br><span class="line">  c-&gt;GPRx=result;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后加载<code>/bin/text</code>进行测试</p><h3 id="把设备抽象成文件"><a href="#把设备抽象成文件" class="headerlink" title="把设备抽象成文件"></a>把设备抽象成文件</h3><p>这一部分类似于在OS课设里面的做过的，将设备也看作文件，实现设备文件的读写操作。包括串口，键盘，时钟，VGA。要在fs.c中为他们设置好对应的读写函数（其中包括下面要讲的VGA设备的相关文件符号）：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the information about all files in disk. */</span></span><br><span class="line"><span class="keyword">static</span> Finfo file_table[] __attribute__((used)) = {</span><br><span class="line">  {<span class="string">"stdin"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, invalid_write},</span><br><span class="line">  {<span class="string">"stdout"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write},</span><br><span class="line">  {<span class="string">"stderr"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, serial_write},</span><br><span class="line">  {<span class="string">"/dev/fb"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read, fb_write},</span><br><span class="line">  {<span class="string">"/dev/events"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, events_read, invalid_write},</span><br><span class="line">  {<span class="string">"/dev/fbsync"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, invalid_read,fbsync_write},</span><br><span class="line">  {<span class="string">"/proc/dispinfo"</span>, <span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>, dispinfo_read,invalid_write},</span><br><span class="line">#include <span class="string">"files.h"</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>注意前面4个的顺序，因为之前有个enum的枚举：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> {FD_STDIN, FD_STDOUT, FD_STDERR, FD_FB};</span><br></pre></td></tr></tbody></table></figure><p>在device.c中实现对应的读写函数</p><p>首先是串口的<code>serial_write</code>:</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size_t serial<span class="constructor">_write(<span class="params">const</span> <span class="params">void</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">size_t</span> <span class="params">offset</span>, <span class="params">size_t</span> <span class="params">len</span>)</span> {</span><br><span class="line">  for(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">    <span class="constructor">_putc(((<span class="params">char</span> <span class="operator">*</span>)</span>buf)<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">  }</span><br><span class="line">  return len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输入设备有键盘和时钟, 它们对系统来说本质上就是到来了一个事件. 一种简单的方式是把事件以文本的形式表现出来, 我们定义以下事件, 一个事件以换行符<code>\n</code>结束:</p><ul><li><code>t 1234</code>: 返回系统启动后的时间, 单位为毫秒;</li><li><code>kd RETURN</code> / <code>ku A</code>: 按下/松开按键, 按键名称全部大写, 使用AM中定义的按键名</li></ul><p>要注意的是, 由于时钟事件可以任意时刻进行读取, 我们需要优先处理按键事件, 当不存在按键事件的时候, 才返回时钟事件, 否则用户程序将永远无法读到按键事件.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">events_read</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> key = read_key();</span><br><span class="line">  <span class="keyword">bool</span> down =<span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(key &amp; KEYDOWN_MASK){</span><br><span class="line">    key ^=KEYDOWN_MASK;</span><br><span class="line">    down = <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span>(key != _KEY_NONE){</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">"%s %s\n"</span>,down ? <span class="string">"kd"</span>:<span class="string">"ku"</span>,keyname[key]);</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">int</span> time =uptime();</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"t %d\n"</span>, time);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我在实现这个的时候出了一点问题，我忘了sprintf是自己实现的，由于我自己偷懒没有实现%u格式，但是我第一次还是用了%u导致我始终无法正确写入，调试了好久。</p><p>做到这里可以先去proc.c中修改测试文件为<code>/bin/events</code>进行键盘和时钟的测试。</p><h3 id="把VGA抽象成文件"><a href="#把VGA抽象成文件" class="headerlink" title="把VGA抽象成文件"></a>把VGA抽象成文件</h3><p>在手册中已经有了具体的步骤</p><ul><li>在<code>init_fs()</code>(在<code>nanos-lite/src/fs.c</code>中定义)中对文件记录表中<code>/dev/fb</code>的大小进行初始化.</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_fs</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> initialize the size of /dev/fb</span></span><br><span class="line">  file_table[FD_FB].<span class="built_in">size</span> = (screen_width()*screen_height())&lt;&lt;<span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于每个像素是4个字节存储，所以要乘以4，也就是左移2位。</p><ul><li>实现<code>fb_write()</code>(在<code>nanos-lite/src/device.c</code>中定义), 用于把<code>buf</code>中的<code>len</code>字节写到屏幕上<code>offset</code>处. 你需要先从<code>offset</code>计算出屏幕上的坐标, 然后调用IOE的<code>draw_rect()</code>.</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fb_write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">  offset /= <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> x= offset % screen_width(); </span><br><span class="line">  <span class="keyword">int</span> y= offset / screen_width();</span><br><span class="line">  draw_rect((<span class="keyword">uint32_t</span>*)buf, x, y, len / <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>实现<code>fbsync_write()</code>(在<code>nanos-lite/src/device.c</code>中定义), 直接调用IOE的相应API即可.</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fbsync_write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">  draw_sync();</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在<code>init_device()</code>(在<code>nanos-lite/src/device.c</code>中定义)中将<code>/proc/dispinfo</code>的内容提前写入到字符串<code>dispinfo</code>中.</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_device</span><span class="params">()</span> </span>{</span><br><span class="line">  Log(<span class="string">"Initializing devices..."</span>);</span><br><span class="line">  _ioe_init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> print the string to array `dispinfo` with the format</span></span><br><span class="line">  <span class="comment">// described in the Navy-apps convention</span></span><br><span class="line">  <span class="built_in">sprintf</span>(dispinfo, <span class="string">"WIDTH:%d\nHEIGHT:%d\n"</span>, screen_width(), screen_height());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>实现<code>dispinfo_read()</code>(在<code>nanos-lite/src/device.c</code>中定义), 用于把字符串<code>dispinfo</code>中<code>offset</code>开始的<code>len</code>字节写到<code>buf</code>中.</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">dispinfo_read</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> len)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span>(len+offset&gt;<span class="built_in">strlen</span>(dispinfo))len=<span class="built_in">strlen</span>(dispinfo)-offset;</span><br><span class="line">  <span class="built_in">strncpy</span>(buf, &amp;dispinfo[offset], len);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在VFS中添加对<code>/dev/fb</code>, <code>/dev/fbsync</code>和<code>/proc/dispinfo</code>这三个特殊文件的支持.</li></ul><p>这个在前面fs.c中已经加过了，请参考前一节。</p><p>让Nanos-lite加载<code>/bin/bmptest</code>, 如果实现正确, 你将会看到屏幕上显示Project-N的logo.</p><h3 id="加载仙剑奇侠传"><a href="#加载仙剑奇侠传" class="headerlink" title="加载仙剑奇侠传"></a>加载仙剑奇侠传</h3><p>下载老师给的仙剑奇侠传资源，并放在<code>navy-apps/fsimg/share/games/pal/</code>目录下, 更新ramdisk之后, 在Nanos-lite中加载并运行<code>/bin/pal</code></p><p>不过x86性能不高，游戏运行不是很流畅。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PA1&quot;&gt;&lt;a href=&quot;#PA1&quot; class=&quot;headerlink&quot; title=&quot;PA1&quot;&gt;&lt;/a&gt;PA1&lt;/h1&gt;&lt;p&gt;PA1的内容分为3个部分，不过核心是实现手册里面的基础设施中的调试器的一些功能，具体功能列表如下&lt;/p&gt;
&lt;table&gt;
&lt;thea</summary>
      
    
    
    
    <category term="课设" scheme="http://example.com/categories/%E8%AF%BE%E8%AE%BE/"/>
    
    
  </entry>
  
</feed>
